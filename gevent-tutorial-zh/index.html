<!DOCTYPE html>
<!-- saved from url=(0035)http://xlambda.com/gevent-tutorial/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <script src="./static/jquery.js"></script><style type="text/css"></style>
    <script src="./static/highlight.min.js"></script>
    <script src="./static/nav.js"></script>

    <!-- Code Monospace Font -->
    <link href="http://fonts.useso.com/css?family=Inconsolata" rel="stylesheet">

    <link rel="stylesheet" href="http://xlambda.com/gevent-tutorial/base.css">
    <link rel="stylesheet" href="http://xlambda.com/gevent-tutorial/skeleton.css">
    <link rel="stylesheet" href="http://xlambda.com/gevent-tutorial/layout.css">
    <link rel="stylesheet" href="http://xlambda.com/gevent-tutorial/gevent.css">

    <!-- Syntax Highlighting Theme -->
    <link rel="stylesheet" href="http://xlambda.com/gevent-tutorial/github.min.css">

    <title>Gevent指南</title>
<style>

</style><link type="text/css" rel="stylesheet" href="chrome-extension://cpngackimfmofbokmjmljamhdncknpmg/style.css"><script type="text/javascript" charset="utf-8" src="chrome-extension://cpngackimfmofbokmjmljamhdncknpmg/js/page_context.js"></script></head>

<body screen_capture_injected="true">
<div class="container">

<div id="sidebar" class="three columns sidebar">
<ul>
<li><a href="http://xlambda.com/gevent-tutorial/#">介绍</a><ul style="display: block;">
<li><a href="http://xlambda.com/gevent-tutorial/#_1">贡献者</a></li>
</ul>
</li>
<li><a href="http://xlambda.com/gevent-tutorial/#_2">核心部分</a><ul style="display: block;">
<li><a href="http://xlambda.com/gevent-tutorial/#greenlets" class="active">Greenlets</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#_3">同步和异步执行</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#_4">确定性</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#greenlets_1">创建Greenlets</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#greenlet">Greenlet状态</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#_5">程序停止</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#_6">超时</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#monkey-patching">猴子补丁(Monkey patching)</a></li>
</ul>
</li>
<li><a href="http://xlambda.com/gevent-tutorial/#_7">数据结构</a><ul style="display: none;">
<li><a href="http://xlambda.com/gevent-tutorial/#_8">事件</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#_9">队列</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#_10">组和池</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#_11">锁和信号量</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#_12">线程局部变量</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#_13">子进程</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#actors">Actors</a></li>
</ul>
</li>
<li><a href="http://xlambda.com/gevent-tutorial/#_14">真实世界的应用</a><ul style="display: none;">
<li><a href="http://xlambda.com/gevent-tutorial/#gevent-zeromq">Gevent ZeroMQ</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#server">简单server</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#wsgi-servers">WSGI Servers</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#server_1">流式server</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#long-polling">Long Polling</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#websockets">Websockets</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/#server_2">聊天server</a></li>
</ul>
</li>
</ul>
</div>

<div class="twelve columns offset-by-three content">

    <header>
        <h1><span class="green">gevent</span>程序员指南</h1>
        <h3 class="author">
            由Gevent社区编写
        </h3>

        <blockquote>
        gevent是一个基于<a href="http://software.schmorp.de/pkg/libev.html">libev</a>的并发库。它为各种并发和网络相关的任务提供了整洁的API。
        </blockquote>
    </header>

    <div class="toc"></div>
<h1 id="">介绍</h1>
<p>本指南假定读者有中级Python水平，但不要求有其它更多的知识，不期待读者有
并发方面的知识。本指南的目标在于给予你需要的工具来开始使用gevent，帮助你
驯服现有的并发问题，并从今开始编写异步应用程序。</p>
<h3 id="_1">贡献者</h3>
<p>按提供贡献的时间先后顺序列出如下:
<a href="http://www.stephendiehl.com/">Stephen Diehl</a>
<a href="https://github.com/jerem">Jérémy Bethmont</a>
<a href="https://github.com/sww">sww</a>
<a href="https://github.com/brunoqc">Bruno Bigras</a>
<a href="https://github.com/dripton">David Ripton</a>
<a href="https://github.com/traviscline">Travis Cline</a>
<a href="https://github.com/Lothiraldan">Boris Feld</a>
<a href="https://github.com/youngsterxyf">youngsterxyf</a>
<a href="https://github.com/ehebert">Eddie Hebert</a>
<a href="http://notmyidea.org/">Alexis Metaireau</a>
<a href="https://github.com/djv">Daniel Velkov</a></p>
<p>同时感谢Denis Bilenko写了gevent和相应的指导以形成本指南。</p>
<p>这是一个以MIT许可证发布的协作文档。你想添加一些内容？或看见一个排版错误？
Fork一个分支发布一个request到
<a href="https://github.com/sdiehl/gevent-tutorial">Github</a>.
我们欢迎任何贡献。</p>
<p>本页也有<a href="http://methane.github.com/gevent-tutorial-ja">日文版本</a>。</p>
<h1 id="_2">核心部分</h1>
<h2 id="greenlets">Greenlets</h2>
<p>在gevent中用到的主要模式是<strong>Greenlet</strong>,
它是以C扩展模块形式接入Python的轻量级协程。
Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</p>
<blockquote>
<p>在任何时刻，只有一个协程在运行。</p>
</blockquote>
<p>这与<code>multiprocessing</code>或<code>threading</code>等提供真正并行构造的库是不同的。
这些库轮转使用操作系统调度的进程和线程，是真正的并行。</p>
<h2 id="_3">同步和异步执行</h2>
<p>并发的核心思想在于，大的任务可以分解成一系列的子任务，后者可以被调度成
同时执行或<em>异步</em>执行，而不是一次一个地或者<em>同步</em>地执行。两个子任务之间的
切换也就是<em>上下文切换</em>。</p>
<p>在gevent里面，上下文切换是通过<em>yielding</em>来完成的. 在下面的例子里，
我们有两个上下文，通过调用<code>gevent.sleep(0)</code>，它们各自yield向对方。</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> gevent

<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span>
    <span class="keyword">print</span>(<span class="string">'Running in foo'</span>)
    gevent.sleep(<span class="number">0</span>)
    <span class="keyword">print</span>(<span class="string">'Explicit context switch to foo again'</span>)

<span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span>
    <span class="keyword">print</span>(<span class="string">'Explicit context to bar'</span>)
    gevent.sleep(<span class="number">0</span>)
    <span class="keyword">print</span>(<span class="string">'Implicit context switch back to bar'</span>)

gevent.joinall([
    gevent.spawn(foo),
    gevent.spawn(bar),
])
</code></pre><code class="python">

</code><p><code class="python"></code>
</p><pre><code class="python" data-result="[object Object]">
Running <span class="keyword">in</span> foo
Explicit context to bar
Explicit context switch to foo again
Implicit context switch back to bar
</code></pre><p></p>
<p>下图将控制流形象化，就像在调试器中单步执行整个程序，以说明上下文切换如何发生。</p>
<p><img alt="Greenlet Control Flow" src="./static/flow.gif"></p>
<p>当我们在受限于网络或IO的函数中使用gevent，这些函数会被协作式的调度，
gevent的真正能力会得到发挥。Gevent处理了所有的细节，
来保证你的网络库会在可能的时候，隐式交出greenlet上下文的执行权。
这样的一种用法是如何强大，怎么强调都不为过。或者我们举些例子来详述。</p>
<p>下面例子中的<code>select()</code>函数通常是一个在各种文件描述符上轮询的阻塞调用。</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> time
<span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent <span class="keyword">import</span> select

start = time.time()
tic = <span class="keyword">lambda</span>: <span class="string">'at %1.1f seconds'</span> % (time.time() - start)

<span class="function"><span class="keyword">def</span> <span class="title">gr1</span><span class="params">()</span>:</span>
    <span class="comment"># Busy waits for a second, but we don't want to stick around...</span>
    <span class="keyword">print</span>(<span class="string">'Started Polling: %s'</span> % tic())
    select.select([], [], [], <span class="number">2</span>)
    <span class="keyword">print</span>(<span class="string">'Ended Polling: %s'</span> % tic())

<span class="function"><span class="keyword">def</span> <span class="title">gr2</span><span class="params">()</span>:</span>
    <span class="comment"># Busy waits for a second, but we don't want to stick around...</span>
    <span class="keyword">print</span>(<span class="string">'Started Polling: %s'</span> % tic())
    select.select([], [], [], <span class="number">2</span>)
    <span class="keyword">print</span>(<span class="string">'Ended Polling: %s'</span> % tic())

<span class="function"><span class="keyword">def</span> <span class="title">gr3</span><span class="params">()</span>:</span>
    <span class="keyword">print</span>(<span class="string">"Hey lets do some stuff while the greenlets poll, %s"</span> % tic())
    gevent.sleep(<span class="number">1</span>)

gevent.joinall([
    gevent.spawn(gr1),
    gevent.spawn(gr2),
    gevent.spawn(gr3),
])
</code></pre><code class="python">

</code><p><code class="python"></code>
</p><pre><code class="python" data-result="[object Object]">
Started Polling: at <span class="number">0.0</span> seconds
Started Polling: at <span class="number">0.0</span> seconds
Hey lets do some stuff <span class="keyword">while</span> the greenlets poll, at <span class="number">0.0</span> seconds
Ended Polling: at <span class="number">2.0</span> seconds
Ended Polling: at <span class="number">2.0</span> seconds
</code></pre><p></p>
<p>下面是另外一个多少有点人造色彩的例子，定义一个<em>非确定性的(non-deterministic)</em>
的<code>task</code>函数(给定相同输入的情况下，它的输出不保证相同)。
此例中执行这个函数的副作用就是，每次task在它的执行过程中都会随机地停某些秒。</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> gevent
<span class="keyword">import</span> random

<span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(pid)</span>:</span>
    <span class="string">"""
    Some non-deterministic task
    """</span>
    gevent.sleep(random.randint(<span class="number">0</span>,<span class="number">2</span>)*<span class="number">0.001</span>)
    <span class="keyword">print</span>(<span class="string">'Task %s done'</span> % pid)

<span class="function"><span class="keyword">def</span> <span class="title">synchronous</span><span class="params">()</span>:</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):
        task(i)

<span class="function"><span class="keyword">def</span> <span class="title">asynchronous</span><span class="params">()</span>:</span>
    threads = [gevent.spawn(task, i) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>)]
    gevent.joinall(threads)

<span class="keyword">print</span>(<span class="string">'Synchronous:'</span>)
synchronous()

<span class="keyword">print</span>(<span class="string">'Asynchronous:'</span>)
asynchronous()
</code></pre><code class="python">

</code><p><code class="python"></code>
</p><pre><code class="python" data-result="[object Object]">
Synchronous:
Task <span class="number">1</span> done
Task <span class="number">2</span> done
Task <span class="number">3</span> done
Task <span class="number">4</span> done
Task <span class="number">5</span> done
Task <span class="number">6</span> done
Task <span class="number">7</span> done
Task <span class="number">8</span> done
Task <span class="number">9</span> done
Asynchronous:
Task <span class="number">3</span> done
Task <span class="number">7</span> done
Task <span class="number">9</span> done
Task <span class="number">2</span> done
Task <span class="number">4</span> done
Task <span class="number">1</span> done
Task <span class="number">8</span> done
Task <span class="number">6</span> done
Task <span class="number">0</span> done
Task <span class="number">5</span> done
</code></pre><p></p>
<p>上例中，在同步的部分，所有的task都同步的执行，
结果当每个task在执行时主流程被<em>阻塞</em>(主流程的执行暂时停住)。</p>
<p>程序的重要部分是将task函数封装到Greenlet内部线程的<code>gevent.spawn</code>。
初始化的greenlet列表存放在数组<code>threads</code>中，此数组被传给<code>gevent.joinall</code>
函数，后者阻塞当前流程，并执行所有给定的greenlet。执行流程只会在
所有greenlet执行完后才会继续向下走。</p>
<p>要重点留意的是，异步的部分本质上是随机的，而且异步部分的整体运行时间比同步
要大大减少。事实上，同步部分的最大运行时间，即是每个task停0.002秒，结果整个
队列要停0.02秒。而异步部分的最大运行时间大致为0.002秒，因为没有任何一个task会
阻塞其它task的执行。</p>
<p>一个更常见的应用场景，如异步地向服务器取数据，取数据操作的执行时间
依赖于发起取数据请求时远端服务器的负载，各个请求的执行时间会有差别。</p>
<pre><code class="python" data-result="[object Object]"><span class="keyword">import</span> gevent.monkey
gevent.monkey.patch_socket()

<span class="keyword">import</span> gevent
<span class="keyword">import</span> urllib2
<span class="keyword">import</span> simplejson <span class="keyword">as</span> json

<span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(pid)</span>:</span>
    response = urllib2.urlopen(<span class="string">'http://json-time.appspot.com/time.json'</span>)
    result = response.read()
    json_result = json.loads(result)
    datetime = json_result[<span class="string">'datetime'</span>]

    <span class="keyword">print</span>(<span class="string">'Process %s: %s'</span> % (pid, datetime))
    <span class="keyword">return</span> json_result[<span class="string">'datetime'</span>]

<span class="function"><span class="keyword">def</span> <span class="title">synchronous</span><span class="params">()</span>:</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):
        fetch(i)

<span class="function"><span class="keyword">def</span> <span class="title">asynchronous</span><span class="params">()</span>:</span>
    threads = []
    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):
        threads.append(gevent.spawn(fetch, i))
    gevent.joinall(threads)

<span class="keyword">print</span>(<span class="string">'Synchronous:'</span>)
synchronous()

<span class="keyword">print</span>(<span class="string">'Asynchronous:'</span>)
asynchronous()
</code>
</pre>

<h2 id="_4">确定性</h2>
<p>就像之前所提到的，greenlet具有确定性。在相同配置相同输入的情况下，它们总是
会产生相同的输出。下面就有例子，我们在multiprocessing的pool之间执行一系列的
任务，与在gevent的pool之间执行作比较。</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> time

<span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(i)</span>:</span>
    time.sleep(<span class="number">0.001</span>)
    <span class="keyword">return</span> i

<span class="comment"># Non Deterministic Process Pool</span>

<span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> Pool

p = Pool(<span class="number">10</span>)
run1 = [a <span class="keyword">for</span> a <span class="keyword">in</span> p.imap_unordered(echo, xrange(<span class="number">10</span>))]
run2 = [a <span class="keyword">for</span> a <span class="keyword">in</span> p.imap_unordered(echo, xrange(<span class="number">10</span>))]
run3 = [a <span class="keyword">for</span> a <span class="keyword">in</span> p.imap_unordered(echo, xrange(<span class="number">10</span>))]
run4 = [a <span class="keyword">for</span> a <span class="keyword">in</span> p.imap_unordered(echo, xrange(<span class="number">10</span>))]

<span class="keyword">print</span>(run1 == run2 == run3 == run4)

<span class="comment"># Deterministic Gevent Pool</span>

<span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Pool

p = Pool(<span class="number">10</span>)
run1 = [a <span class="keyword">for</span> a <span class="keyword">in</span> p.imap_unordered(echo, xrange(<span class="number">10</span>))]
run2 = [a <span class="keyword">for</span> a <span class="keyword">in</span> p.imap_unordered(echo, xrange(<span class="number">10</span>))]
run3 = [a <span class="keyword">for</span> a <span class="keyword">in</span> p.imap_unordered(echo, xrange(<span class="number">10</span>))]
run4 = [a <span class="keyword">for</span> a <span class="keyword">in</span> p.imap_unordered(echo, xrange(<span class="number">10</span>))]

<span class="keyword">print</span>(run1 == run2 == run3 == run4)
</code>
</pre>

<pre><code class="python" data-result="[object Object]"><span class="built_in">False</span>
<span class="built_in">True</span></code>
</pre>

<p>即使gevent通常带有确定性，当开始与如socket或文件等外部服务交互时，
不确定性也可能溜进你的程序中。因此尽管gevent线程是一种“确定的并发”形式，
使用它仍然可能会遇到像使用POSIX线程或进程时遇到的那些问题。</p>
<p>涉及并发长期存在的问题就是<em>竞争条件(race condition)</em>。简单来说，
当两个并发线程/进程都依赖于某个共享资源同时都尝试去修改它的时候，
就会出现竞争条件。这会导致资源修改的结果状态依赖于时间和执行顺序。
这是个问题，我们一般会做很多努力尝试避免竞争条件，
因为它会导致整个程序行为变得不确定。</p>
<p>最好的办法是始终避免所有全局的状态。全局状态和导入时(import-time)副作用总是会
反咬你一口！</p>
<h2 id="greenlets_1">创建Greenlets</h2>
<p>gevent对Greenlet初始化提供了一些封装，最常用的使用模板之一有</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent <span class="keyword">import</span> Greenlet

<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(message, n)</span>:</span>
    <span class="string">"""
    Each thread will be passed the message, and n arguments
    in its initialization.
    """</span>
    gevent.sleep(n)
    <span class="keyword">print</span>(message)

<span class="comment"># Initialize a new Greenlet instance running the named function</span>
<span class="comment"># foo</span>
thread1 = Greenlet.spawn(foo, <span class="string">"Hello"</span>, <span class="number">1</span>)

<span class="comment"># Wrapper for creating and running a new Greenlet from the named</span>
<span class="comment"># function foo, with the passed arguments</span>
thread2 = gevent.spawn(foo, <span class="string">"I live!"</span>, <span class="number">2</span>)

<span class="comment"># Lambda expressions</span>
thread3 = gevent.spawn(<span class="keyword">lambda</span> x: (x+<span class="number">1</span>), <span class="number">2</span>)

threads = [thread1, thread2, thread3]

<span class="comment"># Block until all threads complete.</span>
gevent.joinall(threads)
</code></pre><code class="python">

</code><p><code class="python"></code>
</p><pre><code class="python" data-result="[object Object]">
Hello
I live!
</code></pre><p></p>
<p>除使用基本的Greenlet类之外，你也可以子类化Greenlet类，重载它的<code>_run</code>方法。</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent <span class="keyword">import</span> Greenlet

<span class="class"><span class="keyword">class</span> <span class="title">MyGreenlet</span><span class="params">(Greenlet)</span>:</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, message, n)</span>:</span>
        Greenlet.__init__(self)
        self.message = message
        self.n = n

    <span class="function"><span class="keyword">def</span> <span class="title">_run</span><span class="params">(self)</span>:</span>
        <span class="keyword">print</span>(self.message)
        gevent.sleep(self.n)

g = MyGreenlet(<span class="string">"Hi there!"</span>, <span class="number">3</span>)
g.start()
g.join()
</code></pre><code class="python">

</code><p><code class="python"></code>
</p><pre><code class="python" data-result="[object Object]">
Hi there!
</code></pre><p></p>
<h2 id="greenlet">Greenlet状态</h2>
<p>就像任何其他成段代码，Greenlet也可能以不同的方式运行失败。
Greenlet可能未能成功抛出异常，不能停止运行，或消耗了太多的系统资源。</p>
<p>一个greenlet的状态通常是一个依赖于时间的参数。在greenlet中有一些标志，
让你可以监视它的线程内部状态：</p>
<ul>
<li><code>started</code> -- Boolean, 指示此Greenlet是否已经启动</li>
<li><code>ready()</code> -- Boolean, 指示此Greenlet是否已经停止</li>
<li><code>successful()</code> -- Boolean, 指示此Greenlet是否已经停止而且没抛异常</li>
<li><code>value</code> -- 任意值, 此Greenlet代码返回的值</li>
<li><code>exception</code> -- 异常, 此Greenlet内抛出的未捕获异常</li>
</ul>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> gevent

<span class="function"><span class="keyword">def</span> <span class="title">win</span><span class="params">()</span>:</span>
    <span class="keyword">return</span> <span class="string">'You win!'</span>

<span class="function"><span class="keyword">def</span> <span class="title">fail</span><span class="params">()</span>:</span>
    <span class="keyword">raise</span> Exception(<span class="string">'You fail at failing.'</span>)

winner = gevent.spawn(win)
loser = gevent.spawn(fail)

<span class="keyword">print</span>(winner.started) <span class="comment"># True</span>
<span class="keyword">print</span>(loser.started)  <span class="comment"># True</span>

<span class="comment"># Exceptions raised in the Greenlet, stay inside the Greenlet.</span>
<span class="keyword">try</span>:
    gevent.joinall([winner, loser])
<span class="keyword">except</span> Exception <span class="keyword">as</span> e:
    <span class="keyword">print</span>(<span class="string">'This will never be reached'</span>)

<span class="keyword">print</span>(winner.value) <span class="comment"># 'You win!'</span>
<span class="keyword">print</span>(loser.value)  <span class="comment"># None</span>

<span class="keyword">print</span>(winner.ready()) <span class="comment"># True</span>
<span class="keyword">print</span>(loser.ready())  <span class="comment"># True</span>

<span class="keyword">print</span>(winner.successful()) <span class="comment"># True</span>
<span class="keyword">print</span>(loser.successful())  <span class="comment"># False</span>

<span class="comment"># The exception raised in fail, will not propogate outside the</span>
<span class="comment"># greenlet. A stack trace will be printed to stdout but it</span>
<span class="comment"># will not unwind the stack of the parent.</span>

<span class="keyword">print</span>(loser.exception)

<span class="comment"># It is possible though to raise the exception again outside</span>
<span class="comment"># raise loser.exception</span>
<span class="comment"># or with</span>
<span class="comment"># loser.get()</span>
</code></pre><code class="python">

</code><p><code class="python"></code>
</p><pre><code class="python" data-result="[object Object]">
<span class="built_in">True</span>
<span class="built_in">True</span>
You win!
<span class="built_in">None</span>
<span class="built_in">True</span>
<span class="built_in">True</span>
<span class="built_in">True</span>
<span class="built_in">False</span>
You fail at failing.
</code></pre><p></p>
<h2 id="_5">程序停止</h2>
<p>当主程序(main program)收到一个SIGQUIT信号时，不能成功做yield操作的
Greenlet可能会令意外地挂起程序的执行。这导致了所谓的僵尸进程，
它需要在Python解释器之外被kill掉。</p>
<p>对此，一个通用的处理模式就是在主程序中监听SIGQUIT信号，在程序退出
调用<code>gevent.shutdown</code>。</p>
<pre><code class="python" data-result="[object Object]"><span class="keyword">import</span> gevent
<span class="keyword">import</span> signal

<span class="function"><span class="keyword">def</span> <span class="title">run_forever</span><span class="params">()</span>:</span>
    gevent.sleep(<span class="number">1000</span>)

<span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:
    gevent.signal(signal.SIGQUIT, gevent.shutdown)
    thread = gevent.spawn(run_forever)
    thread.join()
</code>
</pre>

<h2 id="_6">超时</h2>
<p>超时是一种对一块代码或一个Greenlet的运行时间的约束。</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent <span class="keyword">import</span> Timeout

seconds = <span class="number">10</span>

timeout = Timeout(seconds)
timeout.start()

<span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">()</span>:</span>
    gevent.sleep(<span class="number">10</span>)

<span class="keyword">try</span>:
    gevent.spawn(wait).join()
<span class="keyword">except</span> Timeout:
    <span class="keyword">print</span>(<span class="string">'Could not complete'</span>)

</code>
</pre>

<p>超时类也可以用在上下文管理器(context manager)中, 也就是with语句内。</p>
<pre><code class="python" data-result="[object Object]"><span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent <span class="keyword">import</span> Timeout

time_to_wait = <span class="number">5</span> <span class="comment"># seconds</span>

<span class="class"><span class="keyword">class</span> <span class="title">TooLong</span><span class="params">(Exception)</span>:</span>
    <span class="keyword">pass</span>

<span class="keyword">with</span> Timeout(time_to_wait, TooLong):
    gevent.sleep(<span class="number">10</span>)
</code>
</pre>

<p>另外，对各种Greenlet和数据结构相关的调用，gevent也提供了超时参数。
例如：</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent <span class="keyword">import</span> Timeout

<span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">()</span>:</span>
    gevent.sleep(<span class="number">2</span>)

timer = Timeout(<span class="number">1</span>).start()
thread1 = gevent.spawn(wait)

<span class="keyword">try</span>:
    thread1.join(timeout=timer)
<span class="keyword">except</span> Timeout:
    <span class="keyword">print</span>(<span class="string">'Thread 1 timed out'</span>)

<span class="comment"># --</span>

timer = Timeout.start_new(<span class="number">1</span>)
thread2 = gevent.spawn(wait)

<span class="keyword">try</span>:
    thread2.get(timeout=timer)
<span class="keyword">except</span> Timeout:
    <span class="keyword">print</span>(<span class="string">'Thread 2 timed out'</span>)

<span class="comment"># --</span>

<span class="keyword">try</span>:
    gevent.with_timeout(<span class="number">1</span>, wait)
<span class="keyword">except</span> Timeout:
    <span class="keyword">print</span>(<span class="string">'Thread 3 timed out'</span>)

</code></pre><code class="python">

</code><p><code class="python"></code>
</p><pre><code class="python" data-result="[object Object]">
Thread <span class="number">1</span> timed out
Thread <span class="number">2</span> timed out
Thread <span class="number">3</span> timed out
</code></pre><p></p>
<h2 id="monkey-patching">猴子补丁(Monkey patching)</h2>
<p>我们现在来到gevent的死角了. 在此之前，我已经避免提到猴子补丁(monkey patching)
以尝试使gevent这个强大的协程模型变得生动有趣，但现在到了讨论猴子补丁的黑色艺术
的时候了。你之前可能注意到我们提到了<code>monkey.patch_socket()</code>这个命令，这个
纯粹副作用命令是用来改变标准socket库的。</p>
<pre><code class="python" data-result="[object Object]"><span class="keyword">import</span> socket
<span class="keyword">print</span>(socket.socket)

<span class="keyword">print</span>(<span class="string">"After monkey patch"</span>)
<span class="keyword">from</span> gevent <span class="keyword">import</span> monkey
monkey.patch_socket()
<span class="keyword">print</span>(socket.socket)

<span class="keyword">import</span> select
<span class="keyword">print</span>(select.select)
monkey.patch_select()
<span class="keyword">print</span>(<span class="string">"After monkey patch"</span>)
<span class="keyword">print</span>(select.select)
</code>
</pre>

<pre><code class="python null" data-result="[object Object]">class 'socket.socket'
After monkey patch
class 'gevent.socket.socket'

built-in function select
After monkey patch
function select at 0x1924de8
</code>
</pre>

<p>Python的运行环境允许我们在运行时修改大部分的对象，包括模块，类甚至函数。
这是个一般说来令人惊奇的坏主意，因为它创造了“隐式的副作用”，如果出现问题
它很多时候是极难调试的。虽然如此，在极端情况下当一个库需要修改Python本身
的基础行为的时候，猴子补丁就派上用场了。在这种情况下，gevent能够
修改标准库里面大部分的阻塞式系统调用，包括<code>socket</code>、<code>ssl</code>、<code>threading</code>和
<code>select</code>等模块，而变为协作式运行。</p>
<p>例如，Redis的python绑定一般使用常规的tcp socket来与<code>redis-server</code>实例通信。
通过简单地调用<code>gevent.monkey.patch_all()</code>，可以使得redis的绑定协作式的调度
请求，与gevent栈的其它部分一起工作。</p>
<p>这让我们可以将一般不能与gevent共同工作的库结合起来，而不用写哪怕一行代码。
虽然猴子补丁仍然是邪恶的(evil)，但在这种情况下它是“有用的邪恶(useful evil)”。</p>
<h1 id="_7">数据结构</h1>
<h2 id="_8">事件</h2>
<p>事件(event)是一个在Greenlet之间异步通信的形式。</p>
<pre><code class="python" data-result="[object Object]"><span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent.event <span class="keyword">import</span> Event

<span class="string">'''
Illustrates the use of events
'''</span>

evt = Event()

<span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">()</span>:</span>
    <span class="string">'''After 3 seconds, wake all threads waiting on the value of evt'''</span>
    <span class="keyword">print</span>(<span class="string">'A: Hey wait for me, I have to do something'</span>)
    gevent.sleep(<span class="number">3</span>)
    <span class="keyword">print</span>(<span class="string">"Ok, I'm done"</span>)
    evt.set()

<span class="function"><span class="keyword">def</span> <span class="title">waiter</span><span class="params">()</span>:</span>
    <span class="string">'''After 3 seconds the get call will unblock'''</span>
    <span class="keyword">print</span>(<span class="string">"I'll wait for you"</span>)
    evt.wait()  <span class="comment"># blocking</span>
    <span class="keyword">print</span>(<span class="string">"It's about time"</span>)

<span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>
    gevent.joinall([
        gevent.spawn(setter),
        gevent.spawn(waiter),
        gevent.spawn(waiter),
        gevent.spawn(waiter),
        gevent.spawn(waiter),
        gevent.spawn(waiter)
    ])

<span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: main()

</code>
</pre>

<p>事件对象的一个扩展是AsyncResult，它允许你在唤醒调用上附加一个值。
它有时也被称作是future或defered，因为它持有一个指向将来任意时间可设置
为任何值的引用。</p>
<pre><code class="python" data-result="[object Object]"><span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent.event <span class="keyword">import</span> AsyncResult
a = AsyncResult()

<span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">()</span>:</span>
    <span class="string">"""
    After 3 seconds set the result of a.
    """</span>
    gevent.sleep(<span class="number">3</span>)
    a.set(<span class="string">'Hello!'</span>)

<span class="function"><span class="keyword">def</span> <span class="title">waiter</span><span class="params">()</span>:</span>
    <span class="string">"""
    After 3 seconds the get call will unblock after the setter
    puts a value into the AsyncResult.
    """</span>
    <span class="keyword">print</span>(a.get())

gevent.joinall([
    gevent.spawn(setter),
    gevent.spawn(waiter),
])

</code>
</pre>

<h2 id="_9">队列</h2>
<p>队列是一个排序的数据集合，它有常见的<code>put</code> / <code>get</code>操作，
但是它是以在Greenlet之间可以安全操作的方式来实现的。</p>
<p>举例来说，如果一个Greenlet从队列中取出一项，此项就不会被
同时执行的其它Greenlet再取到了。</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue

tasks = Queue()

<span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(n)</span>:</span>
    <span class="keyword">while</span> <span class="keyword">not</span> tasks.empty():
        task = tasks.get()
        <span class="keyword">print</span>(<span class="string">'Worker %s got task %s'</span> % (n, task))
        gevent.sleep(<span class="number">0</span>)

    <span class="keyword">print</span>(<span class="string">'Quitting time!'</span>)

<span class="function"><span class="keyword">def</span> <span class="title">boss</span><span class="params">()</span>:</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>,<span class="number">25</span>):
        tasks.put_nowait(i)

gevent.spawn(boss).join()

gevent.joinall([
    gevent.spawn(worker, <span class="string">'steve'</span>),
    gevent.spawn(worker, <span class="string">'john'</span>),
    gevent.spawn(worker, <span class="string">'nancy'</span>),
])
</code></pre><code class="python">

</code><p><code class="python"></code>
</p><pre><code class="python" data-result="[object Object]">
Worker steve got task <span class="number">1</span>
Worker john got task <span class="number">2</span>
Worker nancy got task <span class="number">3</span>
Worker steve got task <span class="number">4</span>
Worker nancy got task <span class="number">5</span>
Worker john got task <span class="number">6</span>
Worker steve got task <span class="number">7</span>
Worker john got task <span class="number">8</span>
Worker nancy got task <span class="number">9</span>
Worker steve got task <span class="number">10</span>
Worker nancy got task <span class="number">11</span>
Worker john got task <span class="number">12</span>
Worker steve got task <span class="number">13</span>
Worker john got task <span class="number">14</span>
Worker nancy got task <span class="number">15</span>
Worker steve got task <span class="number">16</span>
Worker nancy got task <span class="number">17</span>
Worker john got task <span class="number">18</span>
Worker steve got task <span class="number">19</span>
Worker john got task <span class="number">20</span>
Worker nancy got task <span class="number">21</span>
Worker steve got task <span class="number">22</span>
Worker nancy got task <span class="number">23</span>
Worker john got task <span class="number">24</span>
Quitting time!
Quitting time!
Quitting time!
</code></pre><p></p>
<p>如果需要，队列也可以阻塞在<code>put</code>或<code>get</code>操作上。</p>
<p><code>put</code>和<code>get</code>操作都有非阻塞的版本，<code>put_nowait</code>和<code>get_nowait</code>不会阻塞，
然而在操作不能完成时抛出<code>gevent.queue.Empty</code>或<code>gevent.queue.Full</code>异常。</p>
<p>在下面例子中，我们让boss与多个worker同时运行，并限制了queue不能放入多于3个元素。
这个限制意味着，直到queue有空余空间之间，<code>put</code>操作会被阻塞。相反地，如果队列中
没有元素，<code>get</code>操作会被阻塞。它同时带一个timeout参数，允许在超时时间内如果
队列没有元素无法完成操作就抛出<code>gevent.queue.Empty</code>异常。</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue, Empty

tasks = Queue(maxsize=<span class="number">3</span>)

<span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(n)</span>:</span>
    <span class="keyword">try</span>:
        <span class="keyword">while</span> <span class="built_in">True</span>:
            task = tasks.get(timeout=<span class="number">1</span>) <span class="comment"># decrements queue size by 1</span>
            <span class="keyword">print</span>(<span class="string">'Worker %s got task %s'</span> % (n, task))
            gevent.sleep(<span class="number">0</span>)
    <span class="keyword">except</span> Empty:
        <span class="keyword">print</span>(<span class="string">'Quitting time!'</span>)

<span class="function"><span class="keyword">def</span> <span class="title">boss</span><span class="params">()</span>:</span>
    <span class="string">"""
    Boss will wait to hand out work until a individual worker is
    free since the maxsize of the task queue is 3.
    """</span>

    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>,<span class="number">10</span>):
        tasks.put(i)
    <span class="keyword">print</span>(<span class="string">'Assigned all work in iteration 1'</span>)

    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>,<span class="number">20</span>):
        tasks.put(i)
    <span class="keyword">print</span>(<span class="string">'Assigned all work in iteration 2'</span>)

gevent.joinall([
    gevent.spawn(boss),
    gevent.spawn(worker, <span class="string">'steve'</span>),
    gevent.spawn(worker, <span class="string">'john'</span>),
    gevent.spawn(worker, <span class="string">'bob'</span>),
])
</code></pre><code class="python">

</code><p><code class="python"></code>
</p><pre><code class="python" data-result="[object Object]">
Worker steve got task <span class="number">1</span>
Worker john got task <span class="number">2</span>
Worker bob got task <span class="number">3</span>
Worker steve got task <span class="number">4</span>
Worker bob got task <span class="number">5</span>
Worker john got task <span class="number">6</span>
Assigned all work <span class="keyword">in</span> iteration <span class="number">1</span>
Worker steve got task <span class="number">7</span>
Worker john got task <span class="number">8</span>
Worker bob got task <span class="number">9</span>
Worker steve got task <span class="number">10</span>
Worker bob got task <span class="number">11</span>
Worker john got task <span class="number">12</span>
Worker steve got task <span class="number">13</span>
Worker john got task <span class="number">14</span>
Worker bob got task <span class="number">15</span>
Worker steve got task <span class="number">16</span>
Worker bob got task <span class="number">17</span>
Worker john got task <span class="number">18</span>
Assigned all work <span class="keyword">in</span> iteration <span class="number">2</span>
Worker steve got task <span class="number">19</span>
Quitting time!
Quitting time!
Quitting time!
</code></pre><p></p>
<h2 id="_10">组和池</h2>
<p>组(group)是一个运行中greenlet的集合，集合中的greenlet像一个组一样
会被共同管理和调度。 它也兼饰了像Python的<code>multiprocessing</code>库那样的
平行调度器的角色。</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Group

<span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(msg)</span>:</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">3</span>):
        <span class="keyword">print</span>(msg)

g1 = gevent.spawn(talk, <span class="string">'bar'</span>)
g2 = gevent.spawn(talk, <span class="string">'foo'</span>)
g3 = gevent.spawn(talk, <span class="string">'fizz'</span>)

group = Group()
group.add(g1)
group.add(g2)
group.join()

group.add(g3)
group.join()
</code></pre><code class="python">

</code><p><code class="python"></code>
</p><pre><code class="python" data-result="[object Object]">
bar
bar
bar
foo
foo
foo
fizz
fizz
fizz
</code></pre><p></p>
<p>在管理异步任务的分组上它是非常有用的。</p>
<p>就像上面所说，<code>Group</code>也以不同的方式为分组greenlet/分发工作和收集它们的结果也提供了API。</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent <span class="keyword">import</span> getcurrent
<span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Group

group = Group()

<span class="function"><span class="keyword">def</span> <span class="title">hello_from</span><span class="params">(n)</span>:</span>
    <span class="keyword">print</span>(<span class="string">'Size of group %s'</span> % len(group))
    <span class="keyword">print</span>(<span class="string">'Hello from Greenlet %s'</span> % id(getcurrent()))

group.map(hello_from, xrange(<span class="number">3</span>))

<span class="function"><span class="keyword">def</span> <span class="title">intensive</span><span class="params">(n)</span>:</span>
    gevent.sleep(<span class="number">3</span> - n)
    <span class="keyword">return</span> <span class="string">'task'</span>, n

<span class="keyword">print</span>(<span class="string">'Ordered'</span>)

ogroup = Group()
<span class="keyword">for</span> i <span class="keyword">in</span> ogroup.imap(intensive, xrange(<span class="number">3</span>)):
    <span class="keyword">print</span>(i)

<span class="keyword">print</span>(<span class="string">'Unordered'</span>)

igroup = Group()
<span class="keyword">for</span> i <span class="keyword">in</span> igroup.imap_unordered(intensive, xrange(<span class="number">3</span>)):
    <span class="keyword">print</span>(i)

</code></pre><code class="python">

</code><p><code class="python"></code>
</p><pre><code class="python" data-result="[object Object]">
Size of group <span class="number">3</span>
Hello <span class="keyword">from</span> Greenlet <span class="number">31048720</span>
Size of group <span class="number">3</span>
Hello <span class="keyword">from</span> Greenlet <span class="number">31049200</span>
Size of group <span class="number">3</span>
Hello <span class="keyword">from</span> Greenlet <span class="number">31049040</span>
Ordered
(<span class="string">'task'</span>, <span class="number">0</span>)
(<span class="string">'task'</span>, <span class="number">1</span>)
(<span class="string">'task'</span>, <span class="number">2</span>)
Unordered
(<span class="string">'task'</span>, <span class="number">2</span>)
(<span class="string">'task'</span>, <span class="number">1</span>)
(<span class="string">'task'</span>, <span class="number">0</span>)
</code></pre><p></p>
<p>池(pool)是一个为处理数量变化并且需要限制并发的greenlet而设计的结构。
在需要并行地做很多受限于网络和IO的任务时常常需要用到它。</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Pool

pool = Pool(<span class="number">2</span>)

<span class="function"><span class="keyword">def</span> <span class="title">hello_from</span><span class="params">(n)</span>:</span>
    <span class="keyword">print</span>(<span class="string">'Size of pool %s'</span> % len(pool))

pool.map(hello_from, xrange(<span class="number">3</span>))
</code></pre><code class="python">

</code><p><code class="python"></code>
</p><pre><code class="python" data-result="[object Object]">
Size of pool <span class="number">2</span>
Size of pool <span class="number">2</span>
Size of pool <span class="number">1</span>
</code></pre><p></p>
<p>当构造gevent驱动的服务时，经常会将围绕一个池结构的整个服务作为中心。
一个例子就是在各个socket上轮询的类。</p>
<pre><code class="python" data-result="[object Object]"><span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Pool

<span class="class"><span class="keyword">class</span> <span class="title">SocketPool</span><span class="params">(object)</span>:</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>
        self.pool = Pool(<span class="number">1000</span>)
        self.pool.start()

    <span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(self, socket)</span>:</span>
        <span class="keyword">while</span> <span class="built_in">True</span>:
            socket.recv()

    <span class="function"><span class="keyword">def</span> <span class="title">add_handler</span><span class="params">(self, socket)</span>:</span>
        <span class="keyword">if</span> self.pool.full():
            <span class="keyword">raise</span> Exception(<span class="string">"At maximum pool size"</span>)
        <span class="keyword">else</span>:
            self.pool.spawn(self.listen, socket)

    <span class="function"><span class="keyword">def</span> <span class="title">shutdown</span><span class="params">(self)</span>:</span>
        self.pool.kill()

</code>
</pre>

<h2 id="_11">锁和信号量</h2>
<p>信号量是一个允许greenlet相互合作，限制并发访问或运行的低层次的同步原语。
信号量有两个方法，<code>acquire</code>和<code>release</code>。在信号量是否已经被
acquire或release，和拥有资源的数量之间不同，被称为此信号量的范围
(the bound of the semaphore)。如果一个信号量的范围已经降低到0，它会
阻塞acquire操作直到另一个已经获得信号量的greenlet作出释放。</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">from</span> gevent <span class="keyword">import</span> sleep
<span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Pool
<span class="keyword">from</span> gevent.coros <span class="keyword">import</span> BoundedSemaphore

sem = BoundedSemaphore(<span class="number">2</span>)

<span class="function"><span class="keyword">def</span> <span class="title">worker1</span><span class="params">(n)</span>:</span>
    sem.acquire()
    <span class="keyword">print</span>(<span class="string">'Worker %i acquired semaphore'</span> % n)
    sleep(<span class="number">0</span>)
    sem.release()
    <span class="keyword">print</span>(<span class="string">'Worker %i released semaphore'</span> % n)

<span class="function"><span class="keyword">def</span> <span class="title">worker2</span><span class="params">(n)</span>:</span>
    <span class="keyword">with</span> sem:
        <span class="keyword">print</span>(<span class="string">'Worker %i acquired semaphore'</span> % n)
        sleep(<span class="number">0</span>)
    <span class="keyword">print</span>(<span class="string">'Worker %i released semaphore'</span> % n)

pool = Pool()
pool.map(worker1, xrange(<span class="number">0</span>,<span class="number">2</span>))
pool.map(worker2, xrange(<span class="number">3</span>,<span class="number">6</span>))
</code></pre><code class="python">

</code><p><code class="python"></code>
</p><pre><code class="python" data-result="[object Object]">
Worker <span class="number">0</span> acquired semaphore
Worker <span class="number">1</span> acquired semaphore
Worker <span class="number">0</span> released semaphore
Worker <span class="number">1</span> released semaphore
Worker <span class="number">3</span> acquired semaphore
Worker <span class="number">4</span> acquired semaphore
Worker <span class="number">3</span> released semaphore
Worker <span class="number">4</span> released semaphore
Worker <span class="number">5</span> acquired semaphore
Worker <span class="number">5</span> released semaphore
</code></pre><p></p>
<p>范围为1的信号量也称为锁(lock)。它向单个greenlet提供了互斥访问。
信号量和锁常常用来保证资源只在程序上下文被单次使用。</p>
<h2 id="_12">线程局部变量</h2>
<p>Gevent也允许你指定局部于greenlet上下文的数据。
在内部，它被实现为以greenlet的<code>getcurrent()</code>为键，
在一个私有命名空间寻址的全局查找。</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent.local <span class="keyword">import</span> local

stash = local()

<span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span>
    stash.x = <span class="number">1</span>
    <span class="keyword">print</span>(stash.x)

<span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span>
    stash.y = <span class="number">2</span>
    <span class="keyword">print</span>(stash.y)

    <span class="keyword">try</span>:
        stash.x
    <span class="keyword">except</span> AttributeError:
        <span class="keyword">print</span>(<span class="string">"x is not local to f2"</span>)

g1 = gevent.spawn(f1)
g2 = gevent.spawn(f2)

gevent.joinall([g1, g2])
</code></pre><code class="python">

</code><p><code class="python"></code>
</p><pre><code class="python" data-result="[object Object]">
<span class="number">1</span>
<span class="number">2</span>
x <span class="keyword">is</span> <span class="keyword">not</span> local to f2
</code></pre><p></p>
<p>很多集成了gevent的web框架将HTTP会话对象以线程局部变量的方式存储在gevent内。
例如使用Werkzeug实用库和它的proxy对象，我们可以创建Flask风格的请求对象。</p>
<pre><code class="python" data-result="[object Object]"><span class="keyword">from</span> gevent.local <span class="keyword">import</span> local
<span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalProxy
<span class="keyword">from</span> werkzeug.wrappers <span class="keyword">import</span> Request
<span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager

<span class="keyword">from</span> gevent.wsgi <span class="keyword">import</span> WSGIServer

_requests = local()
request = LocalProxy(<span class="keyword">lambda</span>: _requests.request)

<span class="decorator">@contextmanager</span>
<span class="function"><span class="keyword">def</span> <span class="title">sessionmanager</span><span class="params">(environ)</span>:</span>
    _requests.request = Request(environ)
    <span class="keyword">yield</span>
    _requests.request = <span class="built_in">None</span>

<span class="function"><span class="keyword">def</span> <span class="title">logic</span><span class="params">()</span>:</span>
    <span class="keyword">return</span> <span class="string">"Hello "</span> + request.remote_addr

<span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span>
    status = <span class="string">'200 OK'</span>

    <span class="keyword">with</span> sessionmanager(environ):
        body = logic()

    headers = [
        (<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)
    ]

    start_response(status, headers)
    <span class="keyword">return</span> [body]

WSGIServer((<span class="string">''</span>, <span class="number">8000</span>), application).serve_forever()

<code>
</code></code></pre><code class="python"><code>

<p>Flask系统比这个例子复杂一点，然而使用线程局部变量作为局部的会话存储，
这个思想是相同的。</p>
<h2 id="_13">子进程</h2>
<p>自gevent 1.0起，<code>gevent.subprocess</code>，一个Python <code>subprocess</code>模块
的修补版本已经添加。它支持协作式的等待子进程。</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent.subprocess <span class="keyword">import</span> Popen, PIPE

<span class="function"><span class="keyword">def</span> <span class="title">cron</span><span class="params">()</span>:</span>
    <span class="keyword">while</span> <span class="built_in">True</span>:
        <span class="keyword">print</span>(<span class="string">"cron"</span>)
        gevent.sleep(<span class="number">0.2</span>)

g = gevent.spawn(cron)
sub = Popen([<span class="string">'sleep 1; uname'</span>], stdout=PIPE, shell=<span class="built_in">True</span>)
out, err = sub.communicate()
g.kill()
<span class="keyword">print</span>(out.rstrip())
</code></pre><code class="python">

<pre><code class="python" data-result="[object Object]">
cron
cron
cron
cron
cron
Linux
<code>
</code></code></pre><code class="python"><code>

<p>很多人也想将<code>gevent</code>和<code>multiprocessing</code>一起使用。最明显的挑战之一
就是<code>multiprocessing</code>提供的进程间通信默认不是协作式的。由于基于
<code>multiprocessing.Connection</code>的对象(例如<code>Pipe</code>)暴露了它们下面的
文件描述符(file descriptor)，<code>gevent.socket.wait_read</code>和<code>wait_write</code>
可以用来在直接读写之前协作式的等待ready-to-read/ready-to-write事件。</p>
<pre><code class="python" data-result="[object Object]">
<span class="keyword">import</span> gevent
<span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe
<span class="keyword">from</span> gevent.socket <span class="keyword">import</span> wait_read, wait_write

<span class="comment"># To Process</span>
a, b = Pipe()

<span class="comment"># From Process</span>
c, d = Pipe()

<span class="function"><span class="keyword">def</span> <span class="title">relay</span><span class="params">()</span>:</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):
        msg = b.recv()
        c.send(msg + <span class="string">" in "</span> + str(i))

<span class="function"><span class="keyword">def</span> <span class="title">put_msg</span><span class="params">()</span>:</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):
        wait_write(a.fileno())
        a.send(<span class="string">'hi'</span>)

<span class="function"><span class="keyword">def</span> <span class="title">get_msg</span><span class="params">()</span>:</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):
        wait_read(d.fileno())
        <span class="keyword">print</span>(d.recv())

<span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:
    proc = Process(target=relay)
    proc.start()

    g1 = gevent.spawn(get_msg)
    g2 = gevent.spawn(put_msg)
    gevent.joinall([g1, g2], timeout=<span class="number">1</span>)
</code>
</pre>

<p>然而要注意，组合<code>multiprocessing</code>和gevent必定带来
依赖于操作系统(os-dependent)的缺陷，其中有：</p>
<ul>
<li>
<p>在兼容POSIX的系统<a href="http://linux.die.net/man/2/fork">创建子进程(forking)</a>之后，
在子进程的gevent的状态是不适定的(ill-posed)。一个副作用就是，
<code>multiprocessing.Process</code>创建之前的greenlet创建动作，会在父进程和子进程两
方都运行。</p>
</li>
<li>
<p>上例的<code>put_msg()</code>中的<code>a.send()</code>可能依然非协作式地阻塞调用的线程：一个
ready-to-write事件只保证写了一个byte。在尝试写完成之前底下的buffer可能是满的。</p>
</li>
<li>
<p>上面表示的基于<code>wait_write()</code>/<code>wait_read()</code>的方法在Windows上不工作
(<code>IOError: 3 is not a socket (files are not supported)</code>)，因为Windows不能监视
pipe事件。</p>
</li>
</ul>
<p>Python包<a href="http://pypi.python.org/pypi/gipc">gipc</a>以大体上透明的方式在
兼容POSIX系统和Windows上克服了这些挑战。它提供了gevent感知的基于
<code>multiprocessing.Process</code>的子进程和gevent基于pipe的协作式进程间通信。</p>
<h2 id="actors">Actors</h2>
<p>actor模型是一个由于Erlang变得普及的更高层的并发模型。
简单的说它的主要思想就是许多个独立的Actor，每个Actor有一个可以从
其它Actor接收消息的收件箱。Actor内部的主循环遍历它收到的消息，并
根据它期望的行为来采取行动。</p>
<p>Gevent没有原生的Actor类型，但在一个子类化的Greenlet内使用队列，
我们可以定义一个非常简单的。</p>
<pre><code class="python" data-result="[object Object]"><span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue

<span class="class"><span class="keyword">class</span> <span class="title">Actor</span><span class="params">(gevent.Greenlet)</span>:</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>
        self.inbox = Queue()
        Greenlet.__init__(self)

    <span class="function"><span class="keyword">def</span> <span class="title">receive</span><span class="params">(self, message)</span>:</span>
        <span class="string">"""
        Define in your subclass.
        """</span>
        <span class="keyword">raise</span> <span class="built_in">NotImplemented</span>()

    <span class="function"><span class="keyword">def</span> <span class="title">_run</span><span class="params">(self)</span>:</span>
        self.running = <span class="built_in">True</span>

        <span class="keyword">while</span> self.running:
            message = self.inbox.get()
            self.receive(message)

</code>
</pre>

<p>下面是一个使用的例子：</p>
<pre><code class="python" data-result="[object Object]"><span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue
<span class="keyword">from</span> gevent <span class="keyword">import</span> Greenlet

<span class="class"><span class="keyword">class</span> <span class="title">Pinger</span><span class="params">(Actor)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">receive</span><span class="params">(self, message)</span>:</span>
        <span class="keyword">print</span>(message)
        pong.inbox.put(<span class="string">'ping'</span>)
        gevent.sleep(<span class="number">0</span>)

<span class="class"><span class="keyword">class</span> <span class="title">Ponger</span><span class="params">(Actor)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">receive</span><span class="params">(self, message)</span>:</span>
        <span class="keyword">print</span>(message)
        ping.inbox.put(<span class="string">'pong'</span>)
        gevent.sleep(<span class="number">0</span>)

ping = Pinger()
pong = Ponger()

ping.start()
pong.start()

ping.inbox.put(<span class="string">'start'</span>)
gevent.joinall([ping, pong])
</code>
</pre>

<h1 id="_14">真实世界的应用</h1>
<h2 id="gevent-zeromq">Gevent ZeroMQ</h2>
<p><a href="http://www.zeromq.org/">ZeroMQ</a> 被它的作者描述为
“一个表现得像一个并发框架的socket库”。
它是一个非常强大的，为构建并发和分布式应用的消息传递层。</p>
<p>ZeroMQ提供了各种各样的socket原语。最简单的是请求-应答socket对
(Request-Response socket pair)。一个socket有两个方法<code>send</code>和<code>recv</code>，
两者一般都是阻塞操作。但是<a href="https://github.com/traviscline">Travis Cline</a>
的一个杰出的库弥补了这一点，这个库使用gevent.socket来以非阻塞的方式
轮询ZereMQ socket。通过命令：</p>
<p><code>pip install gevent-zeromq</code></p>
<p>你可以从PyPi安装gevent-zeremq。</p>
<pre><code class="python" data-result="[object Object]">
<span class="comment"># Note: Remember to ``pip install pyzmq gevent_zeromq``</span>
<span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent_zeromq <span class="keyword">import</span> zmq

<span class="comment"># Global Context</span>
context = zmq.Context()

<span class="function"><span class="keyword">def</span> <span class="title">server</span><span class="params">()</span>:</span>
    server_socket = context.socket(zmq.REQ)
    server_socket.bind(<span class="string">"tcp://127.0.0.1:5000"</span>)

    <span class="keyword">for</span> request <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):
        server_socket.send(<span class="string">"Hello"</span>)
        <span class="keyword">print</span>(<span class="string">'Switched to Server for %s'</span> % request)
        <span class="comment"># Implicit context switch occurs here</span>
        server_socket.recv()

<span class="function"><span class="keyword">def</span> <span class="title">client</span><span class="params">()</span>:</span>
    client_socket = context.socket(zmq.REP)
    client_socket.connect(<span class="string">"tcp://127.0.0.1:5000"</span>)

    <span class="keyword">for</span> request <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):

        client_socket.recv()
        <span class="keyword">print</span>(<span class="string">'Switched to Client for %s'</span> % request)
        <span class="comment"># Implicit context switch occurs here</span>
        client_socket.send(<span class="string">"World"</span>)

publisher = gevent.spawn(server)
client    = gevent.spawn(client)

gevent.joinall([publisher, client])

</code></pre><code class="python">

</code><p><code class="python"></code>
</p><pre><code class="python" data-result="[object Object]">
Switched to Server <span class="keyword">for</span> <span class="number">1</span>
Switched to Client <span class="keyword">for</span> <span class="number">1</span>
Switched to Server <span class="keyword">for</span> <span class="number">2</span>
Switched to Client <span class="keyword">for</span> <span class="number">2</span>
Switched to Server <span class="keyword">for</span> <span class="number">3</span>
Switched to Client <span class="keyword">for</span> <span class="number">3</span>
Switched to Server <span class="keyword">for</span> <span class="number">4</span>
Switched to Client <span class="keyword">for</span> <span class="number">4</span>
Switched to Server <span class="keyword">for</span> <span class="number">5</span>
Switched to Client <span class="keyword">for</span> <span class="number">5</span>
Switched to Server <span class="keyword">for</span> <span class="number">6</span>
Switched to Client <span class="keyword">for</span> <span class="number">6</span>
Switched to Server <span class="keyword">for</span> <span class="number">7</span>
Switched to Client <span class="keyword">for</span> <span class="number">7</span>
Switched to Server <span class="keyword">for</span> <span class="number">8</span>
Switched to Client <span class="keyword">for</span> <span class="number">8</span>
Switched to Server <span class="keyword">for</span> <span class="number">9</span>
Switched to Client <span class="keyword">for</span> <span class="number">9</span>
</code></pre><p></p>
<h2 id="server">简单server</h2>
<pre><code class="python" data-result="[object Object]">
<span class="comment"># On Unix: Access with ``$ nc 127.0.0.1 5000``</span>
<span class="comment"># On Window: Access with ``$ telnet 127.0.0.1 5000``</span>

<span class="keyword">from</span> gevent.server <span class="keyword">import</span> StreamServer

<span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(socket, address)</span>:</span>
    socket.send(<span class="string">"Hello from a telnet!\n"</span>)
    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):
        socket.send(str(i) + <span class="string">'\n'</span>)
    socket.close()

server = StreamServer((<span class="string">'127.0.0.1'</span>, <span class="number">5000</span>), handle)
server.serve_forever()
</code>
</pre>

<h2 id="wsgi-servers">WSGI Servers</h2>
<p>Gevent为HTTP内容服务提供了两种WSGI server。从今以后就称为
<code>wsgi</code>和<code>pywsgi</code>：</p>
<ul>
<li>gevent.wsgi.WSGIServer</li>
<li>gevent.pywsgi.WSGIServer</li>
</ul>
<p>在1.0.x之前更早期的版本里，gevent使用libevent而不是libev。
Libevent包含了一个快速HTTP server，它被用在gevent的<code>wsgi</code> server。</p>
<p>在gevent 1.0.x版本，没有包括http server了。作为替代，<code>gevent.wsgi</code>
现在是纯Python server <code>gevent.pywsgi</code>的一个别名。</p>
<h2 id="server_1">流式server</h2>
<p><strong>这个章节不适用于gevent 1.0.x版本</strong></p>
<p>熟悉流式HTTP服务(streaming HTTP service)的人知道，它的核心思想
就是在头部(header)不指定内容的长度。反而，我们让连接保持打开，
在每块数据前加一个16进制字节来指示数据块的长度，并将数据刷入pipe中。
当发出一个0长度数据块时，流会被关闭。</p>
<pre><code class="xml" data-result="[object Object]">HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

8
<span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello

9
World<span class="tag">&lt;/<span class="title">p</span>&gt;</span>

0
</code></pre>
<p>上述的HTTP连接不能在wsgi中创建，因为它不支持流式。
请求只有被缓冲(buffered)下来。</p>
<pre><code class="python" data-result="[object Object]"><span class="keyword">from</span> gevent.wsgi <span class="keyword">import</span> WSGIServer

<span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span>
    status = <span class="string">'200 OK'</span>
    body = <span class="string">'&lt;p&gt;Hello World&lt;/p&gt;'</span>

    headers = [
        (<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)
    ]

    start_response(status, headers)
    <span class="keyword">return</span> [body]

WSGIServer((<span class="string">''</span>, <span class="number">8000</span>), application).serve_forever()

</code>
</pre>

<p>然而使用pywsgi我们可以将handler写成generator，并以块的形式yield出结果。</p>
<pre><code class="python" data-result="[object Object]"><span class="keyword">from</span> gevent.pywsgi <span class="keyword">import</span> WSGIServer

<span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span>
    status = <span class="string">'200 OK'</span>

    headers = [
        (<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)
    ]

    start_response(status, headers)
    <span class="keyword">yield</span> <span class="string">"&lt;p&gt;Hello"</span>
    <span class="keyword">yield</span> <span class="string">"World&lt;/p&gt;"</span>

WSGIServer((<span class="string">''</span>, <span class="number">8000</span>), application).serve_forever()

</code>
</pre>

<p>但无论如何，与其它Python server相比gevent server性能是显胜的。
Libev是得到非常好审查的技术，由它写出的server在大规模上表现优异为人熟知。</p>
<p>为了测试基准，试用Apache Benchmark <code>ab</code>或浏览
<a href="http://nichol.as/benchmark-of-python-web-servers">Benchmark of Python WSGI Servers</a>
来与其它server作对比。</p>
<pre><code class="shell ruby" data-result="[object Object]" data-second_best="[object Object]"><span class="variable">$ </span><span class="identifier">ab</span> -<span class="identifier">n</span> <span class="number">10000</span> -<span class="identifier">c</span> <span class="number">100</span> <span class="identifier">http</span><span class="symbol">:</span>/<span class="regexp">/127.0.0.1:8000/</span>
</code>
</pre>

<h2 id="long-polling">Long Polling</h2>
<pre><code class="python" data-result="[object Object]"><span class="keyword">import</span> gevent
<span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue, Empty
<span class="keyword">from</span> gevent.pywsgi <span class="keyword">import</span> WSGIServer
<span class="keyword">import</span> simplejson <span class="keyword">as</span> json

data_source = Queue()

<span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span>
    <span class="keyword">while</span> <span class="built_in">True</span>:
        data_source.put_nowait(<span class="string">'Hello World'</span>)
        gevent.sleep(<span class="number">1</span>)

<span class="function"><span class="keyword">def</span> <span class="title">ajax_endpoint</span><span class="params">(environ, start_response)</span>:</span>
    status = <span class="string">'200 OK'</span>
    headers = [
        (<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>)
    ]

    start_response(status, headers)

    <span class="keyword">while</span> <span class="built_in">True</span>:
        <span class="keyword">try</span>:
            datum = data_source.get(timeout=<span class="number">5</span>)
            <span class="keyword">yield</span> json.dumps(datum) + <span class="string">'\n'</span>
        <span class="keyword">except</span> Empty:
            <span class="keyword">pass</span>

gevent.spawn(producer)

WSGIServer((<span class="string">''</span>, <span class="number">8000</span>), ajax_endpoint).serve_forever()

</code>
</pre>

<h2 id="websockets">Websockets</h2>
<p>运行Websocket的例子需要<a href="https://bitbucket.org/Jeffrey/gevent-websocket/src">gevent-websocket</a>包。</p>
<pre><code class="python" data-result="[object Object]"><span class="comment"># Simple gevent-websocket server</span>
<span class="keyword">import</span> json
<span class="keyword">import</span> random

<span class="keyword">from</span> gevent <span class="keyword">import</span> pywsgi, sleep
<span class="keyword">from</span> geventwebsocket.handler <span class="keyword">import</span> WebSocketHandler

<span class="class"><span class="keyword">class</span> <span class="title">WebSocketApp</span><span class="params">(object)</span>:</span>
    <span class="string">'''Send random data to the websocket'''</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span>
        ws = environ[<span class="string">'wsgi.websocket'</span>]
        x = <span class="number">0</span>
        <span class="keyword">while</span> <span class="built_in">True</span>:
            data = json.dumps({<span class="string">'x'</span>: x, <span class="string">'y'</span>: random.randint(<span class="number">1</span>, <span class="number">5</span>)})
            ws.send(data)
            x += <span class="number">1</span>
            sleep(<span class="number">0.5</span>)

server = pywsgi.WSGIServer((<span class="string">""</span>, <span class="number">10000</span>), WebSocketApp(),
    handler_class=WebSocketHandler)
server.serve_forever()
</code>
</pre>

<p>HTML Page:</p>
<pre><code class="xml" data-result="[object Object]" data-second_best="[object Object]"><span class="tag">&lt;<span class="title">html</span>&gt;</span>
    <span class="tag">&lt;<span class="title">head</span>&gt;</span>
        <span class="tag">&lt;<span class="title">title</span>&gt;</span>Minimal websocket application<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
        <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"jquery.min.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
        <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
        $(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="comment">// Open up a connection to our server</span>
            <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:10000/"</span>);

            <span class="comment">// What do we do when we get a message?</span>
            ws.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(evt)</span> {</span>
                $(<span class="string">"#placeholder"</span>).append(<span class="string">'&lt;p&gt;'</span> + evt.data + <span class="string">'&lt;/p&gt;'</span>)
            }
            <span class="comment">// Just update our conn_status field with the connection status</span>
            ws.onopen = <span class="function"><span class="keyword">function</span><span class="params">(evt)</span> {</span>
                $(<span class="string">'#conn_status'</span>).html(<span class="string">'&lt;b&gt;Connected&lt;/b&gt;'</span>);
            }
            ws.onerror = <span class="function"><span class="keyword">function</span><span class="params">(evt)</span> {</span>
                $(<span class="string">'#conn_status'</span>).html(<span class="string">'&lt;b&gt;Error&lt;/b&gt;'</span>);
            }
            ws.onclose = <span class="function"><span class="keyword">function</span><span class="params">(evt)</span> {</span>
                $(<span class="string">'#conn_status'</span>).html(<span class="string">'&lt;b&gt;Closed&lt;/b&gt;'</span>);
            }
        });
    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">body</span>&gt;</span>
        <span class="tag">&lt;<span class="title">h1</span>&gt;</span>WebSocket Example<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"conn_status"</span>&gt;</span>Not Connected<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"placeholder"</span> <span class="attribute">style</span>=<span class="value">"width:600px;height:300px;"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</code></pre>
<h2 id="server_2">聊天server</h2>
<p>最后一个生动的例子，实现一个实时聊天室。运行这个例子需要
<a href="http://flask.pocoo.org/">Flask</a>
(你可以使用Django, Pyramid等，但不是必须的)。
对应的Javascript和HTML文件可以在
<a href="https://github.com/sdiehl/minichat">这里</a>找到。</p>
<pre><code class="python" data-result="[object Object]"><span class="comment"># Micro gevent chatroom.</span>
<span class="comment"># ----------------------</span>

<span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request

<span class="keyword">from</span> gevent <span class="keyword">import</span> queue
<span class="keyword">from</span> gevent.pywsgi <span class="keyword">import</span> WSGIServer

<span class="keyword">import</span> simplejson <span class="keyword">as</span> json

app = Flask(__name__)
app.debug = <span class="built_in">True</span>

rooms = {
    <span class="string">'topic1'</span>: Room(),
    <span class="string">'topic2'</span>: Room(),
}

users = {}

<span class="class"><span class="keyword">class</span> <span class="title">Room</span><span class="params">(object)</span>:</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>
        self.users = set()
        self.messages = []

    <span class="function"><span class="keyword">def</span> <span class="title">backlog</span><span class="params">(self, size=25)</span>:</span>
        <span class="keyword">return</span> self.messages[-size:]

    <span class="function"><span class="keyword">def</span> <span class="title">subscribe</span><span class="params">(self, user)</span>:</span>
        self.users.add(user)

    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, message)</span>:</span>
        <span class="keyword">for</span> user <span class="keyword">in</span> self.users:
            <span class="keyword">print</span>(user)
            user.queue.put_nowait(message)
        self.messages.append(message)

<span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>
        self.queue = queue.Queue()

<span class="decorator">@app.route('/')</span>
<span class="function"><span class="keyword">def</span> <span class="title">choose_name</span><span class="params">()</span>:</span>
    <span class="keyword">return</span> render_template(<span class="string">'choose.html'</span>)

<span class="decorator">@app.route('/&lt;uid&gt;')</span>
<span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(uid)</span>:</span>
    <span class="keyword">return</span> render_template(<span class="string">'main.html'</span>,
        uid=uid,
        rooms=rooms.keys()
    )

<span class="decorator">@app.route('/&lt;room&gt;/&lt;uid&gt;')</span>
<span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(room, uid)</span>:</span>
    user = users.get(uid, <span class="built_in">None</span>)

    <span class="keyword">if</span> <span class="keyword">not</span> user:
        users[uid] = user = User()

    active_room = rooms[room]
    active_room.subscribe(user)
    <span class="keyword">print</span>(<span class="string">'subscribe %s %s'</span> % (active_room, user))

    messages = active_room.backlog()

    <span class="keyword">return</span> render_template(<span class="string">'room.html'</span>,
        room=room, uid=uid, messages=messages)

<span class="decorator">@app.route("/put/&lt;room&gt;/&lt;uid&gt;", methods=["POST"])</span>
<span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(room, uid)</span>:</span>
    user = users[uid]
    room = rooms[room]

    message = request.form[<span class="string">'message'</span>]
    room.add(<span class="string">':'</span>.join([uid, message]))

    <span class="keyword">return</span> <span class="string">''</span>

<span class="decorator">@app.route("/poll/&lt;uid&gt;", methods=["POST"])</span>
<span class="function"><span class="keyword">def</span> <span class="title">poll</span><span class="params">(uid)</span>:</span>
    <span class="keyword">try</span>:
        msg = users[uid].queue.get(timeout=<span class="number">10</span>)
    <span class="keyword">except</span> queue.Empty:
        msg = []
    <span class="keyword">return</span> json.dumps(msg)

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    http = WSGIServer((<span class="string">''</span>, <span class="number">5000</span>), app)
    http.serve_forever()
</code>
</pre>
</code></code></code></code></code></div><code><code class="python"><code class="python"><code>


</code></code></code></code></div><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0"></body></html>

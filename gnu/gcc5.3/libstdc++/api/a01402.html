<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>libstdc++: Non-Mutating</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a01402.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Non-Mutating<div class="ingroups"><a class="el" href="a01400.html">Algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Non-Mutating:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="a01402.svg" width="235" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga094e6f312833388e6a97159b5d2c4177"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:ga094e6f312833388e6a97159b5d2c4177"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#ga094e6f312833388e6a97159b5d2c4177">std::adjacent_find</a> (_ForwardIterator __first, _ForwardIterator __last)</td></tr>
<tr class="separator:ga094e6f312833388e6a97159b5d2c4177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29b281099618951de1ab1315ac9e7737"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga29b281099618951de1ab1315ac9e7737"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#ga29b281099618951de1ab1315ac9e7737">std::adjacent_find</a> (_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)</td></tr>
<tr class="separator:ga29b281099618951de1ab1315ac9e7737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaef2d0f2f0d6942636f6f42eb940b850"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Predicate &gt; </td></tr>
<tr class="memitem:gaaef2d0f2f0d6942636f6f42eb940b850"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#gaaef2d0f2f0d6942636f6f42eb940b850">std::all_of</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)</td></tr>
<tr class="separator:gaaef2d0f2f0d6942636f6f42eb940b850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8fada47994395ec51bb54536d6a87f9"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Predicate &gt; </td></tr>
<tr class="memitem:gaa8fada47994395ec51bb54536d6a87f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#gaa8fada47994395ec51bb54536d6a87f9">std::any_of</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)</td></tr>
<tr class="separator:gaa8fada47994395ec51bb54536d6a87f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f89a1340c43c8451e522d045aaa1b6"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Tp &gt; </td></tr>
<tr class="memitem:gad2f89a1340c43c8451e522d045aaa1b6"><td class="memTemplItemLeft" align="right" valign="top">iterator_traits&lt; _InputIterator &gt;::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#gad2f89a1340c43c8451e522d045aaa1b6">std::count</a> (_InputIterator __first, _InputIterator __last, const _Tp &amp;__value)</td></tr>
<tr class="separator:gad2f89a1340c43c8451e522d045aaa1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab17add9e8922a4e8a9893d0d094f5e4e"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Predicate &gt; </td></tr>
<tr class="memitem:gab17add9e8922a4e8a9893d0d094f5e4e"><td class="memTemplItemLeft" align="right" valign="top">iterator_traits&lt; _InputIterator &gt;::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#gab17add9e8922a4e8a9893d0d094f5e4e">std::count_if</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)</td></tr>
<tr class="separator:gab17add9e8922a4e8a9893d0d094f5e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga444f163947d0a55953d1c317b31aee89"><td class="memTemplParams" colspan="2">template&lt;typename _IIter1 , typename _IIter2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga444f163947d0a55953d1c317b31aee89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#ga444f163947d0a55953d1c317b31aee89">std::equal</a> (_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred)</td></tr>
<tr class="separator:ga444f163947d0a55953d1c317b31aee89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9f16258cd8b86bb63165c004cf660d5"><td class="memTemplParams" colspan="2">template&lt;typename _II1 , typename _II2 &gt; </td></tr>
<tr class="memitem:gad9f16258cd8b86bb63165c004cf660d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#gad9f16258cd8b86bb63165c004cf660d5">std::equal</a> (_II1 __first1, _II1 __last1, _II2 __first2)</td></tr>
<tr class="separator:gad9f16258cd8b86bb63165c004cf660d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga346cc7c0b794d9a487a11b44b6b238ab"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Tp &gt; </td></tr>
<tr class="memitem:ga346cc7c0b794d9a487a11b44b6b238ab"><td class="memTemplItemLeft" align="right" valign="top">_InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#ga346cc7c0b794d9a487a11b44b6b238ab">std::find</a> (_InputIterator __first, _InputIterator __last, const _Tp &amp;__val)</td></tr>
<tr class="separator:ga346cc7c0b794d9a487a11b44b6b238ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf97d3d3c35f24541246e9d222fd45d44"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </td></tr>
<tr class="memitem:gaf97d3d3c35f24541246e9d222fd45d44"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#gaf97d3d3c35f24541246e9d222fd45d44">std::find_end</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)</td></tr>
<tr class="separator:gaf97d3d3c35f24541246e9d222fd45d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac12e9d93b9b26024222cc645d2a4a8d5"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:gac12e9d93b9b26024222cc645d2a4a8d5"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#gac12e9d93b9b26024222cc645d2a4a8d5">std::find_end</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __comp)</td></tr>
<tr class="separator:gac12e9d93b9b26024222cc645d2a4a8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f2c547c925b080c25f17765a755a0cb"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:ga5f2c547c925b080c25f17765a755a0cb"><td class="memTemplItemLeft" align="right" valign="top">_InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#ga5f2c547c925b080c25f17765a755a0cb">std::find_first_of</a> (_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2)</td></tr>
<tr class="separator:ga5f2c547c925b080c25f17765a755a0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f6564022032cfc6ea5c24b6dce5b4a7"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _ForwardIterator , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga4f6564022032cfc6ea5c24b6dce5b4a7"><td class="memTemplItemLeft" align="right" valign="top">_InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#ga4f6564022032cfc6ea5c24b6dce5b4a7">std::find_first_of</a> (_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, _BinaryPredicate __comp)</td></tr>
<tr class="separator:ga4f6564022032cfc6ea5c24b6dce5b4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf6e9995ebbd27994d7c73b375f86088"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Predicate &gt; </td></tr>
<tr class="memitem:gaaf6e9995ebbd27994d7c73b375f86088"><td class="memTemplItemLeft" align="right" valign="top">_InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#gaaf6e9995ebbd27994d7c73b375f86088">std::find_if</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)</td></tr>
<tr class="separator:gaaf6e9995ebbd27994d7c73b375f86088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0bfffb70439c7d2cab9e917e8d604a6"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Predicate &gt; </td></tr>
<tr class="memitem:gaa0bfffb70439c7d2cab9e917e8d604a6"><td class="memTemplItemLeft" align="right" valign="top">_InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#gaa0bfffb70439c7d2cab9e917e8d604a6">std::find_if_not</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)</td></tr>
<tr class="separator:gaa0bfffb70439c7d2cab9e917e8d604a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d3b88a382b4ad3bf55aff3f597522d"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Function &gt; </td></tr>
<tr class="memitem:ga36d3b88a382b4ad3bf55aff3f597522d"><td class="memTemplItemLeft" align="right" valign="top">_Function&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#ga36d3b88a382b4ad3bf55aff3f597522d">std::for_each</a> (_InputIterator __first, _InputIterator __last, _Function __f)</td></tr>
<tr class="separator:ga36d3b88a382b4ad3bf55aff3f597522d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc446c7587539490a05da590d6c51a58"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </td></tr>
<tr class="memitem:gadc446c7587539490a05da590d6c51a58"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#gadc446c7587539490a05da590d6c51a58">std::is_permutation</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)</td></tr>
<tr class="separator:gadc446c7587539490a05da590d6c51a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga714d45aee3d18a5e281557b48d092b8e"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga714d45aee3d18a5e281557b48d092b8e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#ga714d45aee3d18a5e281557b48d092b8e">std::is_permutation</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _BinaryPredicate __pred)</td></tr>
<tr class="separator:ga714d45aee3d18a5e281557b48d092b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44ee120346d18fb398be3891eb4a8c0c"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 &gt; </td></tr>
<tr class="memitem:ga44ee120346d18fb398be3891eb4a8c0c"><td class="memTemplItemLeft" align="right" valign="top">pair&lt; _InputIterator1, _InputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#ga44ee120346d18fb398be3891eb4a8c0c">std::mismatch</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)</td></tr>
<tr class="separator:ga44ee120346d18fb398be3891eb4a8c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3cb7460f4803c1073882c89456bb75c"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:gad3cb7460f4803c1073882c89456bb75c"><td class="memTemplItemLeft" align="right" valign="top">pair&lt; _InputIterator1, _InputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#gad3cb7460f4803c1073882c89456bb75c">std::mismatch</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)</td></tr>
<tr class="separator:gad3cb7460f4803c1073882c89456bb75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga245f9003d26e4ca6c9b304c4cca2c77f"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename _Predicate &gt; </td></tr>
<tr class="memitem:ga245f9003d26e4ca6c9b304c4cca2c77f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#ga245f9003d26e4ca6c9b304c4cca2c77f">std::none_of</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)</td></tr>
<tr class="separator:ga245f9003d26e4ca6c9b304c4cca2c77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37e40c12374da3b76f2af5d2025b3018"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </td></tr>
<tr class="memitem:ga37e40c12374da3b76f2af5d2025b3018"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#ga37e40c12374da3b76f2af5d2025b3018">std::search</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)</td></tr>
<tr class="separator:ga37e40c12374da3b76f2af5d2025b3018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab76055789d1a598394f609cf19724220"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:gab76055789d1a598394f609cf19724220"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIterator1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#gab76055789d1a598394f609cf19724220">std::search</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __predicate)</td></tr>
<tr class="separator:gab76055789d1a598394f609cf19724220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98baadb721fcb143396118e3a678cd0e"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator , typename _Integer , typename _Tp &gt; </td></tr>
<tr class="memitem:ga98baadb721fcb143396118e3a678cd0e"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#ga98baadb721fcb143396118e3a678cd0e">std::search_n</a> (_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &amp;__val)</td></tr>
<tr class="separator:ga98baadb721fcb143396118e3a678cd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fd2241c480f56cb4fef2ae7da4d36b0"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator , typename _Integer , typename _Tp , typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga4fd2241c480f56cb4fef2ae7da4d36b0"><td class="memTemplItemLeft" align="right" valign="top">_ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01402.html#ga4fd2241c480f56cb4fef2ae7da4d36b0">std::search_n</a> (_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &amp;__val, _BinaryPredicate __binary_pred)</td></tr>
<tr class="separator:ga4fd2241c480f56cb4fef2ae7da4d36b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga094e6f312833388e6a97159b5d2c4177"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find two adjacent values in a sequence that are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> such that <code>i</code> and <code>i+1</code> are both valid iterators in <code></code>[__first,__last) and such that <code>*i</code> == <code>*</code>(i+1), or <code>__last</code> if no such iterator exists. </dd></dl>

<p>Definition at line <a class="el" href="a01262_source.html#l03909">3909</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga29b281099618951de1ab1315ac9e7737"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find two adjacent values in a sequence using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> such that <code>i</code> and <code>i+1</code> are both valid iterators in <code></code>[__first,__last) and such that <code>__binary_pred</code>(*i,*(i+1)) is true, or <code>__last</code> if no such iterator exists. </dd></dl>

<p>Definition at line <a class="el" href="a01262_source.html#l03934">3934</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaaef2d0f2f0d6942636f6f42eb940b850"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool std::all_of </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that a predicate is true for all the elements of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the check is true, false otherwise.</dd></dl>
<p>Returns true if <code>__pred</code> is true for each element in the range <code></code>[__first,__last), and false otherwise. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l00508">508</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01262_source.html#l00558">std::find_if_not()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa8fada47994395ec51bb54536d6a87f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool std::any_of </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that a predicate is false for at least an element of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the check is true, false otherwise.</dd></dl>
<p>Returns true if an element exists in the range <code></code>[__first,__last) such that <code>__pred</code> is true, and false otherwise. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l00543">543</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01262_source.html#l00525">std::none_of()</a>.</p>

</div>
</div>
<a class="anchor" id="gad2f89a1340c43c8451e522d045aaa1b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator_traits&lt;_InputIterator&gt;::difference_type std::count </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of copies of a value in a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>The value to be counted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of iterators <code>i</code> in the range <code></code>[__first,__last) for which <code>*i</code> == <code>__value</code> </dd></dl>

<p>Definition at line <a class="el" href="a01262_source.html#l03959">3959</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab17add9e8922a4e8a9893d0d094f5e4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator_traits&lt;_InputIterator&gt;::difference_type std::count_if </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the elements of a sequence for which a predicate is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of iterators <code>i</code> in the range <code></code>[__first,__last) for which <code>__pred(*i)</code> is true. </dd></dl>

<p>Definition at line <a class="el" href="a01262_source.html#l03982">3982</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga444f163947d0a55953d1c317b31aee89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _IIter1 , typename _IIter2 , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool std::equal </td>
          <td>(</td>
          <td class="paramtype">_IIter1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_IIter1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_IIter2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests a range for element-wise equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate <a class="el" href="a01414.html">functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p>This compares the elements of two ranges using the binary_pred parameter, and returns true or false depending on whether all of the corresponding elements of the ranges are equal. </p>

<p>Definition at line <a class="el" href="a01263_source.html#l01085">1085</a> of file <a class="el" href="a01263_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad9f16258cd8b86bb63165c004cf660d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _II1 , typename _II2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool std::equal </td>
          <td>(</td>
          <td class="paramtype">_II1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II2&#160;</td>
          <td class="paramname"><em>__first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests a range for element-wise equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p>This compares the elements of two ranges using <code>==</code> and returns true or false depending on whether all of the corresponding elements of the ranges are equal. </p>

<p>Definition at line <a class="el" href="a01263_source.html#l01053">1053</a> of file <a class="el" href="a01263_source.html">stl_algobase.h</a>.</p>

<p>Referenced by <a class="el" href="a01178_source.html#l01914">std::operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="ga346cc7c0b794d9a487a11b44b6b238ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_InputIterator std::find </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first occurrence of a value in a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last) such that <code>*i</code> == <code>__val</code>, or <code>__last</code> if no such iterator exists. </dd></dl>

<p>Definition at line <a class="el" href="a01262_source.html#l03782">3782</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01262_source.html#l00101">std::__find_if()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf97d3d3c35f24541246e9d222fd45d44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator1 std::find_end </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find last matching subsequence in a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence to match. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>*</code>(i+N) == <code>*</code>(__first2+N) for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2) and returns an iterator to the __first element of the sub-sequence, or <code>__last1</code> if the sub-sequence is not found. The sub-sequence will be the last such subsequence contained in [__first1,__last1).</p>
<p>Because the sub-sequence must lie completely within the range <code></code>[__first1,__last1) it must start at a position less than <code>__last1-</code>(__last2-__first2) where <code>__last2-__first2</code> is the length of the sub-sequence. This means that the returned iterator <code>i</code> will be in the range <code></code>[__first1,__last1-(__last2-__first2)) </p>

<p>Definition at line <a class="el" href="a01262_source.html#l00425">425</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01271_source.html#l00204">std::__iterator_category()</a>.</p>

</div>
</div>
<a class="anchor" id="gac12e9d93b9b26024222cc645d2a4a8d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator1 std::find_end </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find last matching subsequence in a sequence using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence to match. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence to match. </td></tr>
    <tr><td class="paramname">__comp</td><td>The predicate to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>predicate</code>(*(i+N), <code></code>(__first2+N)) is true for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2) using comp as a predicate and returns an iterator to the first element of the sub-sequence, or <code>__last1</code> if the sub-sequence is not found. The sub-sequence will be the last such subsequence contained in [__first,__last1).</p>
<p>Because the sub-sequence must lie completely within the range <code></code>[__first1,__last1) it must start at a position less than <code>__last1-</code>(__last2-__first2) where <code>__last2-__first2</code> is the length of the sub-sequence. This means that the returned iterator <code>i</code> will be in the range <code></code>[__first1,__last1-(__last2-__first2)) </p>

<p>Definition at line <a class="el" href="a01262_source.html#l00474">474</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01271_source.html#l00204">std::__iterator_category()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5f2c547c925b080c25f17765a755a0cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_InputIterator std::find_first_of </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find element from a set in a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of match candidates. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of match candidates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1) such that <code>*i</code> == <code>*</code>(i2) such that i2 is an iterator in [__first2,__last2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for an element that is equal to some element in the range [__first2,__last2). If found, returns an iterator in the range [__first1,__last1), otherwise returns <code>__last1</code>. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l03837">3837</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4f6564022032cfc6ea5c24b6dce5b4a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _ForwardIterator , typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_InputIterator std::find_first_of </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find element from a set in a sequence using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of match candidates. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of match candidates. </td></tr>
    <tr><td class="paramname">__comp</td><td>Predicate to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1) such that <code>comp</code>(*i, <code>*</code>(i2)) is true and i2 is an iterator in [__first2,__last2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for an element that is equal to some element in the range [__first2,__last2). If found, returns an iterator in the range [__first1,__last1), otherwise returns <code>__last1</code>. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l03878">3878</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaaf6e9995ebbd27994d7c73b375f86088"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_InputIterator std::find_if </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first element in a sequence for which a predicate is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last) such that <code>__pred(*i)</code> is true, or <code>__last</code> if no such iterator exists. </dd></dl>

<p>Definition at line <a class="el" href="a01262_source.html#l03806">3806</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01262_source.html#l00101">std::__find_if()</a>.</p>

<p>Referenced by <a class="el" href="a01262_source.html#l00525">std::none_of()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa0bfffb70439c7d2cab9e917e8d604a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_InputIterator std::find_if_not </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first element in a sequence for which a predicate is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last) such that <code>__pred(*i)</code> is false, or <code>__last</code> if no such iterator exists. </dd></dl>

<p>Definition at line <a class="el" href="a01262_source.html#l00558">558</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01262_source.html#l00168">std::__find_if_not()</a>.</p>

<p>Referenced by <a class="el" href="a01262_source.html#l00508">std::all_of()</a>, and <a class="el" href="a01262_source.html#l00582">std::is_partitioned()</a>.</p>

</div>
</div>
<a class="anchor" id="ga36d3b88a382b4ad3bf55aff3f597522d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Function std::for_each </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Function&#160;</td>
          <td class="paramname"><em>__f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a function to every element of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__f</td><td>A unary function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>__f</code> (std::move(<code>__f</code>) in C++0x).</dd></dl>
<p>Applies the function object <code>__f</code> to each element in the range <code></code>[first,last). <code>__f</code> must not modify the order of the sequence. If <code>__f</code> has a return value it is ignored. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l03761">3761</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gadc446c7587539490a05da590d6c51a58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool std::is_permutation </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a permutation of the second sequence is equal to the first sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there exists a permutation of the elements in the range [__first2, __first2 + (__last1 - __first1)), beginning with ForwardIterator2 begin, such that equal(__first1, __last1, begin) returns true; otherwise, returns false. </dd></dl>

<p>Definition at line <a class="el" href="a01262_source.html#l03537">3537</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga714d45aee3d18a5e281557b48d092b8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool std::is_permutation </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a permutation of the second sequence is equal to the first sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there exists a permutation of the elements in the range [__first2, __first2 + (__last1 - __first1)), beginning with ForwardIterator2 begin, such that equal(__first1, __last1, __begin, __pred) returns true; otherwise, returns false. </dd></dl>

<p>Definition at line <a class="el" href="a01262_source.html#l03569">3569</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga44ee120346d18fb398be3891eb4a8c0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;_InputIterator1, _InputIterator2&gt; std::mismatch </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the places in ranges which don't match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of iterators pointing to the first mismatch.</dd></dl>
<p>This compares the elements of two ranges using <code>==</code> and returns a pair of iterators. The first iterator points into the first range, the second iterator points into the second range, and the elements pointed to by the iterators are not equal. </p>

<p>Definition at line <a class="el" href="a01263_source.html#l01292">1292</a> of file <a class="el" href="a01263_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad3cb7460f4803c1073882c89456bb75c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;_InputIterator1, _InputIterator2&gt; std::mismatch </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the places in ranges which don't match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate <a class="el" href="a01414.html">functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of iterators pointing to the first mismatch.</dd></dl>
<p>This compares the elements of two ranges using the binary_pred parameter, and returns a pair of iterators. The first iterator points into the first range, the second iterator points into the second range, and the elements pointed to by the iterators are not equal. </p>

<p>Definition at line <a class="el" href="a01263_source.html#l01326">1326</a> of file <a class="el" href="a01263_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga245f9003d26e4ca6c9b304c4cca2c77f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool std::none_of </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that a predicate is false for all the elements of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the check is true, false otherwise.</dd></dl>
<p>Returns true if <code>__pred</code> is false for each element in the range <code></code>[__first,__last), and false otherwise. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l00525">525</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01262_source.html#l03806">std::find_if()</a>.</p>

<p>Referenced by <a class="el" href="a01262_source.html#l00543">std::any_of()</a>, and <a class="el" href="a01262_source.html#l00582">std::is_partitioned()</a>.</p>

</div>
</div>
<a class="anchor" id="ga37e40c12374da3b76f2af5d2025b3018"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator1 std::search </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a sequence for a matching sub-sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>*</code>(i+N) == <code>*</code>(__first2+N) for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2) and returns an iterator to the first element of the sub-sequence, or <code>__last1</code> if the sub-sequence is not found.</p>
<p>Because the sub-sequence must lie completely within the range <code></code>[__first1,__last1) it must start at a position less than <code>__last1-</code>(__last2-__first2) where <code>__last2-__first2</code> is the length of the sub-sequence.</p>
<p>This means that the returned iterator <code>i</code> will be in the range <code></code>[__first1,__last1-(__last2-__first2)) </p>

<p>Definition at line <a class="el" href="a01262_source.html#l04022">4022</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab76055789d1a598394f609cf19724220"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator1 std::search </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a sequence for a matching sub-sequence using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__predicate</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>__predicate</code>(*(i+N),*(__first2+N)) is true for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2), using <code>__predicate</code> to determine equality, and returns an iterator to the first element of the sub-sequence, or <code>__last1</code> if no such iterator exists.</p>
<dl class="section see"><dt>See also</dt><dd>search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2) </dd></dl>

<p>Definition at line <a class="el" href="a01262_source.html#l04062">4062</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga98baadb721fcb143396118e3a678cd0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Integer , typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::search_n </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Integer&#160;</td>
          <td class="paramname"><em>__count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a sequence for a number of consecutive values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__count</td><td>The number of consecutive values. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last-__count) such that <code>*</code>(i+N) == <code>__val</code> for each <code>N</code> in the range <code></code>[0,__count), or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first,__last) for <code>count</code> consecutive elements equal to <code>__val</code>. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l04096">4096</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4fd2241c480f56cb4fef2ae7da4d36b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Integer , typename _Tp , typename _BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::search_n </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Integer&#160;</td>
          <td class="paramname"><em>__count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a sequence for a number of consecutive values using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__count</td><td>The number of consecutive values. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last-__count) such that <code>__binary_pred</code>(*(i+N),__val) is true for each <code>N</code> in the range <code></code>[0,__count), or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first,__last) for <code>__count</code> consecutive elements for which the predicate returns true. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l04130">4130</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>

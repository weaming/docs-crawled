<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>libstdc++: std::list&lt; _Tp, _Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00429.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="a02304.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">std::list&lt; _Tp, _Alloc &gt; Class Template Reference<div class="ingroups"><a class="el" href="a01394.html">Containers</a> &raquo; <a class="el" href="a01395.html">Sequences</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for std::list&lt; _Tp, _Alloc &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a02305.svg" width="151" height="123"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad67bacd1be3bb3a67e85f582efcf2e4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad67bacd1be3bb3a67e85f582efcf2e4a"></a>
typedef _Alloc&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:ad67bacd1be3bb3a67e85f582efcf2e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d9c9d8c5155e7dcf05a7d6f4279368"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19d9c9d8c5155e7dcf05a7d6f4279368"></a>
typedef <a class="el" href="a00500.html">_List_const_iterator</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a19d9c9d8c5155e7dcf05a7d6f4279368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cbecd367e1a726445ada9ce02f12df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4cbecd367e1a726445ada9ce02f12df"></a>
typedef _Tp_alloc_type::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:ab4cbecd367e1a726445ada9ce02f12df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17c628774327983a24611083e7f5cc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac17c628774327983a24611083e7f5cc7"></a>
typedef _Tp_alloc_type::const_reference&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:ac17c628774327983a24611083e7f5cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704c8179c60596d31f264f5bbcacaa16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a704c8179c60596d31f264f5bbcacaa16"></a>
typedef <a class="el" href="a00688.html">std::reverse_iterator</a>&lt; <a class="el" href="a00500.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:a704c8179c60596d31f264f5bbcacaa16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ccbe70441b5b3b8c98d6f24f9a4f14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2ccbe70441b5b3b8c98d6f24f9a4f14"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:af2ccbe70441b5b3b8c98d6f24f9a4f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf585c4c41f2b122dc943a26e91ae57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbf585c4c41f2b122dc943a26e91ae57"></a>
typedef <a class="el" href="a00501.html">_List_iterator</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:afbf585c4c41f2b122dc943a26e91ae57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e78cd7fad5c7c2ee0814fcdd40d31d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e78cd7fad5c7c2ee0814fcdd40d31d1"></a>
typedef _Tp_alloc_type::pointer&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a3e78cd7fad5c7c2ee0814fcdd40d31d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e8739e32164fa22ba9dd85b4a02e50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88e8739e32164fa22ba9dd85b4a02e50"></a>
typedef _Tp_alloc_type::reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a88e8739e32164fa22ba9dd85b4a02e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d6ca4e318829934bd93edcb5a7e408"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21d6ca4e318829934bd93edcb5a7e408"></a>
typedef <a class="el" href="a00688.html">std::reverse_iterator</a>&lt; <a class="el" href="a00501.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a21d6ca4e318829934bd93edcb5a7e408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace80f20d536929e4383ee3e100206492"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace80f20d536929e4383ee3e100206492"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:ace80f20d536929e4383ee3e100206492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4021b03ec1e0f14d638f35122ac9542a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4021b03ec1e0f14d638f35122ac9542a"></a>
typedef _Tp&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a4021b03ec1e0f14d638f35122ac9542a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5cec77d4bb0c37d6cd49fc87f72012ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a5cec77d4bb0c37d6cd49fc87f72012ac">list</a> () noexcept(is_nothrow_default_constructible&lt; _Node_alloc_type &gt;::value)</td></tr>
<tr class="separator:a5cec77d4bb0c37d6cd49fc87f72012ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6d1424066dbfd18daebac90d143837"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a7b6d1424066dbfd18daebac90d143837">list</a> (const allocator_type &amp;__a) noexcept</td></tr>
<tr class="separator:a7b6d1424066dbfd18daebac90d143837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463d42bea0d5b735392fd9b51d81e309"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a463d42bea0d5b735392fd9b51d81e309">list</a> (size_type __n)</td></tr>
<tr class="separator:a463d42bea0d5b735392fd9b51d81e309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac739777416320440d35c6de1a42ba818"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#ac739777416320440d35c6de1a42ba818">list</a> (size_type __n, const value_type &amp;__value, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:ac739777416320440d35c6de1a42ba818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4657b924fb0c29b7d3e347a2da97f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#aec4657b924fb0c29b7d3e347a2da97f0">list</a> (const <a class="el" href="a00429.html">list</a> &amp;__x)</td></tr>
<tr class="separator:aec4657b924fb0c29b7d3e347a2da97f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6735f782a8c9a03d7bdd3ebf7f32da4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a6735f782a8c9a03d7bdd3ebf7f32da4e">list</a> (<a class="el" href="a00429.html">list</a> &amp;&amp;__x) noexcept</td></tr>
<tr class="separator:a6735f782a8c9a03d7bdd3ebf7f32da4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc914a91c0740ca3f52168d0b631dbf8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#abc914a91c0740ca3f52168d0b631dbf8">list</a> (initializer_list&lt; value_type &gt; __l, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:abc914a91c0740ca3f52168d0b631dbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad905b1f7f844c8715c654439611804a1"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </td></tr>
<tr class="memitem:ad905b1f7f844c8715c654439611804a1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00429.html#ad905b1f7f844c8715c654439611804a1">list</a> (_InputIterator __first, _InputIterator __last, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:ad905b1f7f844c8715c654439611804a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1a22c8bd2a8d5ecacab44644f513db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a9f1a22c8bd2a8d5ecacab44644f513db">assign</a> (size_type __n, const value_type &amp;__val)</td></tr>
<tr class="separator:a9f1a22c8bd2a8d5ecacab44644f513db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6527fbbec76ab1a8a4a80c04e6fcac70"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </td></tr>
<tr class="memitem:a6527fbbec76ab1a8a4a80c04e6fcac70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00429.html#a6527fbbec76ab1a8a4a80c04e6fcac70">assign</a> (_InputIterator __first, _InputIterator __last)</td></tr>
<tr class="separator:a6527fbbec76ab1a8a4a80c04e6fcac70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396193b1480defeaa5f3367ca15ec35e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a396193b1480defeaa5f3367ca15ec35e">assign</a> (initializer_list&lt; value_type &gt; __l)</td></tr>
<tr class="separator:a396193b1480defeaa5f3367ca15ec35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9567c3ee9243b0159cb036f17ea74b53"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a9567c3ee9243b0159cb036f17ea74b53">back</a> () noexcept</td></tr>
<tr class="separator:a9567c3ee9243b0159cb036f17ea74b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43aac14d7c69657442718428b082aaf"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#ac43aac14d7c69657442718428b082aaf">back</a> () const noexcept</td></tr>
<tr class="separator:ac43aac14d7c69657442718428b082aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0d75e77ac53db35e3cdf85ad6d3fa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00501.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a1a0d75e77ac53db35e3cdf85ad6d3fa3">begin</a> () noexcept</td></tr>
<tr class="separator:a1a0d75e77ac53db35e3cdf85ad6d3fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7d9dc641209c8e429d291db8f2de25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00500.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#acd7d9dc641209c8e429d291db8f2de25">begin</a> () const noexcept</td></tr>
<tr class="separator:acd7d9dc641209c8e429d291db8f2de25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9c52d90a45482d052dbb4b2040b6da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00500.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#aac9c52d90a45482d052dbb4b2040b6da">cbegin</a> () const noexcept</td></tr>
<tr class="separator:aac9c52d90a45482d052dbb4b2040b6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702400622789c3e0f1171369f803fcb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00500.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a702400622789c3e0f1171369f803fcb8">cend</a> () const noexcept</td></tr>
<tr class="separator:a702400622789c3e0f1171369f803fcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36feac84d9e8125b700ce5189ed9e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#ae36feac84d9e8125b700ce5189ed9e95">clear</a> () noexcept</td></tr>
<tr class="separator:ae36feac84d9e8125b700ce5189ed9e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c1a4886327c94160ec35419c516f64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00688.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#ab0c1a4886327c94160ec35419c516f64">crbegin</a> () const noexcept</td></tr>
<tr class="separator:ab0c1a4886327c94160ec35419c516f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bc7bbe49c3f41b0dfaa3acd5c89e12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00688.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#af9bc7bbe49c3f41b0dfaa3acd5c89e12">crend</a> () const noexcept</td></tr>
<tr class="separator:af9bc7bbe49c3f41b0dfaa3acd5c89e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c95c4bf43ce0e94205cfa07db4f39d6"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a3c95c4bf43ce0e94205cfa07db4f39d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00501.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00429.html#a3c95c4bf43ce0e94205cfa07db4f39d6">emplace</a> (<a class="el" href="a00500.html">const_iterator</a> __position, _Args &amp;&amp;...__args)</td></tr>
<tr class="separator:a3c95c4bf43ce0e94205cfa07db4f39d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d34a8a074d056c37daacb68f39ef25"><td class="memTemplParams" colspan="2"><a class="anchor" id="a40d34a8a074d056c37daacb68f39ef25"></a>
template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a40d34a8a074d056c37daacb68f39ef25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_back</b> (_Args &amp;&amp;...__args)</td></tr>
<tr class="separator:a40d34a8a074d056c37daacb68f39ef25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d038fc46af79ef338fe72be8ac151a2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d038fc46af79ef338fe72be8ac151a2"></a>
template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a6d038fc46af79ef338fe72be8ac151a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_front</b> (_Args &amp;&amp;...__args)</td></tr>
<tr class="separator:a6d038fc46af79ef338fe72be8ac151a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af558a1b206e6fdf40921aeaba0383dbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#af558a1b206e6fdf40921aeaba0383dbe">empty</a> () const noexcept</td></tr>
<tr class="separator:af558a1b206e6fdf40921aeaba0383dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba82f0b94c1ed15ccacea0e98aa6cff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00501.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#aba82f0b94c1ed15ccacea0e98aa6cff6">end</a> () noexcept</td></tr>
<tr class="separator:aba82f0b94c1ed15ccacea0e98aa6cff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a7a20ed70dd4018608a3522d83124d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00500.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a39a7a20ed70dd4018608a3522d83124d">end</a> () const noexcept</td></tr>
<tr class="separator:a39a7a20ed70dd4018608a3522d83124d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8be2fa84dabd368f22663afad64bc04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00501.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#ad8be2fa84dabd368f22663afad64bc04">erase</a> (<a class="el" href="a00500.html">const_iterator</a> __position) noexcept</td></tr>
<tr class="separator:ad8be2fa84dabd368f22663afad64bc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927ad4d7e4673d4b2b33a16de379671b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00501.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a927ad4d7e4673d4b2b33a16de379671b">erase</a> (<a class="el" href="a00500.html">const_iterator</a> __first, <a class="el" href="a00500.html">const_iterator</a> __last) noexcept</td></tr>
<tr class="separator:a927ad4d7e4673d4b2b33a16de379671b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4367625f1676f2fc0d56b891db683fe"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#ad4367625f1676f2fc0d56b891db683fe">front</a> () noexcept</td></tr>
<tr class="separator:ad4367625f1676f2fc0d56b891db683fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5393c199d92f965d065b677f2230e51e"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a5393c199d92f965d065b677f2230e51e">front</a> () const noexcept</td></tr>
<tr class="separator:a5393c199d92f965d065b677f2230e51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f6032941520f4d9187fdf8284ae914"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a31f6032941520f4d9187fdf8284ae914">get_allocator</a> () const noexcept</td></tr>
<tr class="separator:a31f6032941520f4d9187fdf8284ae914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b983ae6b7e1bc04c8adce4691e4c6a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00501.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a3b983ae6b7e1bc04c8adce4691e4c6a4">insert</a> (<a class="el" href="a00500.html">const_iterator</a> __position, const value_type &amp;__x)</td></tr>
<tr class="separator:a3b983ae6b7e1bc04c8adce4691e4c6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b70528dcf0f77ddb45429d463de07e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00501.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a2b70528dcf0f77ddb45429d463de07e4">insert</a> (<a class="el" href="a00500.html">const_iterator</a> __position, value_type &amp;&amp;__x)</td></tr>
<tr class="separator:a2b70528dcf0f77ddb45429d463de07e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9214e29cd05b8446678285415fb6f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00501.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#af9214e29cd05b8446678285415fb6f1e">insert</a> (<a class="el" href="a00500.html">const_iterator</a> __p, initializer_list&lt; value_type &gt; __l)</td></tr>
<tr class="separator:af9214e29cd05b8446678285415fb6f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8120aa63e348306b85d08b12e0c10b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00501.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#afe8120aa63e348306b85d08b12e0c10b">insert</a> (<a class="el" href="a00500.html">const_iterator</a> __position, size_type __n, const value_type &amp;__x)</td></tr>
<tr class="separator:afe8120aa63e348306b85d08b12e0c10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070d9690cb94c94c978c3c429a432315"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </td></tr>
<tr class="memitem:a070d9690cb94c94c978c3c429a432315"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00501.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00429.html#a070d9690cb94c94c978c3c429a432315">insert</a> (<a class="el" href="a00500.html">const_iterator</a> __position, _InputIterator __first, _InputIterator __last)</td></tr>
<tr class="separator:a070d9690cb94c94c978c3c429a432315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0642b1d26b07dcf28d5fd72bfbdd6d1"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#ac0642b1d26b07dcf28d5fd72bfbdd6d1">max_size</a> () const noexcept</td></tr>
<tr class="separator:ac0642b1d26b07dcf28d5fd72bfbdd6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab57cf2c464c35225b087e94fd82d50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a4ab57cf2c464c35225b087e94fd82d50">merge</a> (<a class="el" href="a00429.html">list</a> &amp;&amp;__x)</td></tr>
<tr class="separator:a4ab57cf2c464c35225b087e94fd82d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fef823ab0946e8335c8bb6d5722ef1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88fef823ab0946e8335c8bb6d5722ef1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>merge</b> (<a class="el" href="a00429.html">list</a> &amp;__x)</td></tr>
<tr class="separator:a88fef823ab0946e8335c8bb6d5722ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e45d151199c59708d5dcc17d282ffc"><td class="memTemplParams" colspan="2">template&lt;typename _StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:a23e45d151199c59708d5dcc17d282ffc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00429.html#a23e45d151199c59708d5dcc17d282ffc">merge</a> (<a class="el" href="a00429.html">list</a> &amp;&amp;__x, _StrictWeakOrdering __comp)</td></tr>
<tr class="separator:a23e45d151199c59708d5dcc17d282ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bcae0211248b423b1f0f077226f8e3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a08bcae0211248b423b1f0f077226f8e3"></a>
template&lt;typename _StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:a08bcae0211248b423b1f0f077226f8e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>merge</b> (<a class="el" href="a00429.html">list</a> &amp;__x, _StrictWeakOrdering __comp)</td></tr>
<tr class="separator:a08bcae0211248b423b1f0f077226f8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3743566062b79f3554ac94bbfd19c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00429.html">list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a8c3743566062b79f3554ac94bbfd19c3">operator=</a> (const <a class="el" href="a00429.html">list</a> &amp;__x)</td></tr>
<tr class="separator:a8c3743566062b79f3554ac94bbfd19c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c47aa2a28343d487b4d7ec001de6d38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00429.html">list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a8c47aa2a28343d487b4d7ec001de6d38">operator=</a> (<a class="el" href="a00429.html">list</a> &amp;&amp;__x)</td></tr>
<tr class="separator:a8c47aa2a28343d487b4d7ec001de6d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b554a6eab6e57e565eedb7da72a83c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00429.html">list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a7b554a6eab6e57e565eedb7da72a83c5">operator=</a> (initializer_list&lt; value_type &gt; __l)</td></tr>
<tr class="separator:a7b554a6eab6e57e565eedb7da72a83c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437f35446fc4e342d4df581335191a69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a437f35446fc4e342d4df581335191a69">pop_back</a> () noexcept</td></tr>
<tr class="separator:a437f35446fc4e342d4df581335191a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad744f7f3b84fc57c973ed2d3bb25a33e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#ad744f7f3b84fc57c973ed2d3bb25a33e">pop_front</a> () noexcept</td></tr>
<tr class="separator:ad744f7f3b84fc57c973ed2d3bb25a33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164bc4a9a0f40d98579507cfa9bb0313"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a164bc4a9a0f40d98579507cfa9bb0313">push_back</a> (const value_type &amp;__x)</td></tr>
<tr class="separator:a164bc4a9a0f40d98579507cfa9bb0313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ada838020423dbbe528a87fc8c2737a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ada838020423dbbe528a87fc8c2737a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (value_type &amp;&amp;__x)</td></tr>
<tr class="separator:a4ada838020423dbbe528a87fc8c2737a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ce26ebd4c6a1789692b7d377f332f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a43ce26ebd4c6a1789692b7d377f332f3">push_front</a> (const value_type &amp;__x)</td></tr>
<tr class="separator:a43ce26ebd4c6a1789692b7d377f332f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c103b131bdd1a7df4648ba3b480be50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c103b131bdd1a7df4648ba3b480be50"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_front</b> (value_type &amp;&amp;__x)</td></tr>
<tr class="separator:a7c103b131bdd1a7df4648ba3b480be50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4cacefc7a58e913f2e9876df0d59de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00688.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a8a4cacefc7a58e913f2e9876df0d59de">rbegin</a> () noexcept</td></tr>
<tr class="separator:a8a4cacefc7a58e913f2e9876df0d59de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba0b1fa92ccc5268e64c0023632aee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00688.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a3ba0b1fa92ccc5268e64c0023632aee7">rbegin</a> () const noexcept</td></tr>
<tr class="separator:a3ba0b1fa92ccc5268e64c0023632aee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9669f55bfe90a9a9d217bb95d2191356"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a9669f55bfe90a9a9d217bb95d2191356">remove</a> (const _Tp &amp;__value)</td></tr>
<tr class="separator:a9669f55bfe90a9a9d217bb95d2191356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166140876ba96cfb1bc8c16825ceaf76"><td class="memTemplParams" colspan="2">template&lt;typename _Predicate &gt; </td></tr>
<tr class="memitem:a166140876ba96cfb1bc8c16825ceaf76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00429.html#a166140876ba96cfb1bc8c16825ceaf76">remove_if</a> (_Predicate)</td></tr>
<tr class="separator:a166140876ba96cfb1bc8c16825ceaf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4018c8137dc053cfd04641f1ab4b070e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00688.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a4018c8137dc053cfd04641f1ab4b070e">rend</a> () noexcept</td></tr>
<tr class="separator:a4018c8137dc053cfd04641f1ab4b070e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af134c3c02479d6b40c4b6dd9784ff9b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00688.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#af134c3c02479d6b40c4b6dd9784ff9b2">rend</a> () const noexcept</td></tr>
<tr class="separator:af134c3c02479d6b40c4b6dd9784ff9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe59a58ea5f8a9afcf818af671cb3d9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#afe59a58ea5f8a9afcf818af671cb3d9e">resize</a> (size_type __new_size)</td></tr>
<tr class="separator:afe59a58ea5f8a9afcf818af671cb3d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bfd70c04ab4c10ac198e65e41d5f9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#ab9bfd70c04ab4c10ac198e65e41d5f9a">resize</a> (size_type __new_size, const value_type &amp;__x)</td></tr>
<tr class="separator:ab9bfd70c04ab4c10ac198e65e41d5f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d420a62c310cd992f52c016293f969a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a7d420a62c310cd992f52c016293f969a">reverse</a> () noexcept</td></tr>
<tr class="separator:a7d420a62c310cd992f52c016293f969a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6c305dd92e3c76213778feba213da2"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a4b6c305dd92e3c76213778feba213da2">size</a> () const noexcept</td></tr>
<tr class="separator:a4b6c305dd92e3c76213778feba213da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0093b7fd0e7113b5e4759fe4b7dba6bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a0093b7fd0e7113b5e4759fe4b7dba6bd">sort</a> ()</td></tr>
<tr class="separator:a0093b7fd0e7113b5e4759fe4b7dba6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993a2dd135bf122f532b43a4bb7652f2"><td class="memTemplParams" colspan="2">template&lt;typename _StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:a993a2dd135bf122f532b43a4bb7652f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00429.html#a993a2dd135bf122f532b43a4bb7652f2">sort</a> (_StrictWeakOrdering)</td></tr>
<tr class="separator:a993a2dd135bf122f532b43a4bb7652f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27f8110bc96c70775f1654e978b4c5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#ae27f8110bc96c70775f1654e978b4c5f">splice</a> (<a class="el" href="a00500.html">const_iterator</a> __position, <a class="el" href="a00429.html">list</a> &amp;&amp;__x) noexcept</td></tr>
<tr class="separator:ae27f8110bc96c70775f1654e978b4c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42f3a62becb6253e59e99d95da300cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa42f3a62becb6253e59e99d95da300cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>splice</b> (<a class="el" href="a00500.html">const_iterator</a> __position, <a class="el" href="a00429.html">list</a> &amp;__x) noexcept</td></tr>
<tr class="separator:aa42f3a62becb6253e59e99d95da300cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11428bfeda40f933f26428bf432907db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a11428bfeda40f933f26428bf432907db">splice</a> (<a class="el" href="a00500.html">const_iterator</a> __position, <a class="el" href="a00429.html">list</a> &amp;&amp;__x, <a class="el" href="a00500.html">const_iterator</a> __i) noexcept</td></tr>
<tr class="separator:a11428bfeda40f933f26428bf432907db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9275ed20653d145bd3c324e0b0422c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#aa9275ed20653d145bd3c324e0b0422c3">splice</a> (<a class="el" href="a00500.html">const_iterator</a> __position, <a class="el" href="a00429.html">list</a> &amp;__x, <a class="el" href="a00500.html">const_iterator</a> __i) noexcept</td></tr>
<tr class="separator:aa9275ed20653d145bd3c324e0b0422c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a9d0e45f35bc5c51ee5b1646304bb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#aa4a9d0e45f35bc5c51ee5b1646304bb6">splice</a> (<a class="el" href="a00500.html">const_iterator</a> __position, <a class="el" href="a00429.html">list</a> &amp;&amp;__x, <a class="el" href="a00500.html">const_iterator</a> __first, <a class="el" href="a00500.html">const_iterator</a> __last) noexcept</td></tr>
<tr class="separator:aa4a9d0e45f35bc5c51ee5b1646304bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2e8e3c78743063a5223b09a7f7abf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a5e2e8e3c78743063a5223b09a7f7abf6">splice</a> (<a class="el" href="a00500.html">const_iterator</a> __position, <a class="el" href="a00429.html">list</a> &amp;__x, <a class="el" href="a00500.html">const_iterator</a> __first, <a class="el" href="a00500.html">const_iterator</a> __last) noexcept</td></tr>
<tr class="separator:a5e2e8e3c78743063a5223b09a7f7abf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695032584292f0cc36325aa8016f723b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#a695032584292f0cc36325aa8016f723b">swap</a> (<a class="el" href="a00429.html">list</a> &amp;__x)</td></tr>
<tr class="separator:a695032584292f0cc36325aa8016f723b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2439ba07cb10d92d48abd7541dab5f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00429.html#ad2439ba07cb10d92d48abd7541dab5f1">unique</a> ()</td></tr>
<tr class="separator:ad2439ba07cb10d92d48abd7541dab5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68b42ddc8f2a2994891cc928955e780"><td class="memTemplParams" colspan="2">template&lt;typename _BinaryPredicate &gt; </td></tr>
<tr class="memitem:aa68b42ddc8f2a2994891cc928955e780"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00429.html#aa68b42ddc8f2a2994891cc928955e780">unique</a> (_BinaryPredicate)</td></tr>
<tr class="separator:aa68b42ddc8f2a2994891cc928955e780"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a2055df77ce05a254ff1f9aa88bbaef45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2055df77ce05a254ff1f9aa88bbaef45"></a>
typedef <a class="el" href="a00502.html">_List_node</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_Node</b></td></tr>
<tr class="separator:a2055df77ce05a254ff1f9aa88bbaef45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2491a2c47454a8320b0699dfcf4f3bb0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2491a2c47454a8320b0699dfcf4f3bb0"></a>
template&lt;typename _Integer &gt; </td></tr>
<tr class="memitem:a2491a2c47454a8320b0699dfcf4f3bb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_assign_dispatch</b> (_Integer __n, _Integer __val, __true_type)</td></tr>
<tr class="separator:a2491a2c47454a8320b0699dfcf4f3bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911040d424a8156448e7e741418c0e29"><td class="memTemplParams" colspan="2"><a class="anchor" id="a911040d424a8156448e7e741418c0e29"></a>
template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a911040d424a8156448e7e741418c0e29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_assign_dispatch</b> (_InputIterator __first, _InputIterator __last, __false_type)</td></tr>
<tr class="separator:a911040d424a8156448e7e741418c0e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f06d66d4c34fad49d433a531795e025"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f06d66d4c34fad49d433a531795e025"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_check_equal_allocators</b> (<a class="el" href="a00429.html">list</a> &amp;__x) noexcept</td></tr>
<tr class="separator:a3f06d66d4c34fad49d433a531795e025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d6ecc880d686ffd7ac6d9e66f982c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73d6ecc880d686ffd7ac6d9e66f982c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_clear</b> () noexcept</td></tr>
<tr class="separator:a73d6ecc880d686ffd7ac6d9e66f982c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e916ab6ecbc0fc92883eef796154a3"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a27e916ab6ecbc0fc92883eef796154a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00502.html">_Node</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00429.html#a27e916ab6ecbc0fc92883eef796154a3">_M_create_node</a> (_Args &amp;&amp;...__args)</td></tr>
<tr class="separator:a27e916ab6ecbc0fc92883eef796154a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad361566a31dcc1de936d347f3b5f1af9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad361566a31dcc1de936d347f3b5f1af9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_dec_size</b> (size_t)</td></tr>
<tr class="separator:ad361566a31dcc1de936d347f3b5f1af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a9f28cc9b774226f94cceafb9b9b4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04a9f28cc9b774226f94cceafb9b9b4d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_default_append</b> (size_type __n)</td></tr>
<tr class="separator:a04a9f28cc9b774226f94cceafb9b9b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d86a5d5f4ea440fc1603dfc674988b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d86a5d5f4ea440fc1603dfc674988b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_default_initialize</b> (size_type __n)</td></tr>
<tr class="separator:a8d86a5d5f4ea440fc1603dfc674988b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e1ac5aa6f0004a27808979d88eb194"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6e1ac5aa6f0004a27808979d88eb194"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_M_distance</b> (const void *, const void *) const </td></tr>
<tr class="separator:aa6e1ac5aa6f0004a27808979d88eb194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e3643274f247e40e217bea86244392"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42e3643274f247e40e217bea86244392"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_erase</b> (<a class="el" href="a00501.html">iterator</a> __position) noexcept</td></tr>
<tr class="separator:a42e3643274f247e40e217bea86244392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006911b8c79d62771be4143cde0c0baa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a006911b8c79d62771be4143cde0c0baa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_fill_assign</b> (size_type __n, const value_type &amp;__val)</td></tr>
<tr class="separator:a006911b8c79d62771be4143cde0c0baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0941ba190c165903066bab4392248881"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0941ba190c165903066bab4392248881"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_fill_initialize</b> (size_type __n, const value_type &amp;__x)</td></tr>
<tr class="separator:a0941ba190c165903066bab4392248881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca7fcacce21daf10314e650f19e95dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ca7fcacce21daf10314e650f19e95dd"></a>
<a class="el" href="a00502.html">_List_node</a>&lt; _Tp &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>_M_get_node</b> ()</td></tr>
<tr class="separator:a1ca7fcacce21daf10314e650f19e95dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4c256c21faaf07a7db4c4e103e9149"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d4c256c21faaf07a7db4c4e103e9149"></a>
_Node_alloc_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_M_get_Node_allocator</b> () noexcept</td></tr>
<tr class="separator:a9d4c256c21faaf07a7db4c4e103e9149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26cbb212a32aae5703787176d9cb252"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af26cbb212a32aae5703787176d9cb252"></a>
const _Node_alloc_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_M_get_Node_allocator</b> () const noexcept</td></tr>
<tr class="separator:af26cbb212a32aae5703787176d9cb252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58aea1b61887ab99f14837b036cd500"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad58aea1b61887ab99f14837b036cd500"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_M_get_size</b> () const </td></tr>
<tr class="separator:ad58aea1b61887ab99f14837b036cd500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76357c1c7e30753801664723c677e5cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76357c1c7e30753801664723c677e5cd"></a>
_Tp_alloc_type&#160;</td><td class="memItemRight" valign="bottom"><b>_M_get_Tp_allocator</b> () const noexcept</td></tr>
<tr class="separator:a76357c1c7e30753801664723c677e5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdcc101f658bb341d15aab0dc2292c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fdcc101f658bb341d15aab0dc2292c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_inc_size</b> (size_t)</td></tr>
<tr class="separator:a0fdcc101f658bb341d15aab0dc2292c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f2eea752c475c0d9b8f90a8a4fa5f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0f2eea752c475c0d9b8f90a8a4fa5f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_init</b> () noexcept</td></tr>
<tr class="separator:af0f2eea752c475c0d9b8f90a8a4fa5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0ff0405a043c97ad856d634a23fa02"><td class="memTemplParams" colspan="2"><a class="anchor" id="aad0ff0405a043c97ad856d634a23fa02"></a>
template&lt;typename _Integer &gt; </td></tr>
<tr class="memitem:aad0ff0405a043c97ad856d634a23fa02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_initialize_dispatch</b> (_Integer __n, _Integer __x, __true_type)</td></tr>
<tr class="separator:aad0ff0405a043c97ad856d634a23fa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523eadd75ce0db6141fb31bbfd4d5192"><td class="memTemplParams" colspan="2"><a class="anchor" id="a523eadd75ce0db6141fb31bbfd4d5192"></a>
template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a523eadd75ce0db6141fb31bbfd4d5192"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_initialize_dispatch</b> (_InputIterator __first, _InputIterator __last, __false_type)</td></tr>
<tr class="separator:a523eadd75ce0db6141fb31bbfd4d5192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b7ee3f619ae03dc2a1911e564be3c0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad6b7ee3f619ae03dc2a1911e564be3c0"></a>
template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:ad6b7ee3f619ae03dc2a1911e564be3c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_insert</b> (<a class="el" href="a00501.html">iterator</a> __position, _Args &amp;&amp;...__args)</td></tr>
<tr class="separator:ad6b7ee3f619ae03dc2a1911e564be3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbe4cce4273c3d7ca9d84e4db254b44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fbe4cce4273c3d7ca9d84e4db254b44"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_M_node_count</b> () const </td></tr>
<tr class="separator:a4fbe4cce4273c3d7ca9d84e4db254b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa49c3c04a6ed70bbc472d57a433ac3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaa49c3c04a6ed70bbc472d57a433ac3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_put_node</b> (<a class="el" href="a00502.html">_List_node</a>&lt; _Tp &gt; *__p) noexcept</td></tr>
<tr class="separator:acaa49c3c04a6ed70bbc472d57a433ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6946cc2765e971a83992163f4cb1dbc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6946cc2765e971a83992163f4cb1dbc4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_set_size</b> (size_t)</td></tr>
<tr class="separator:a6946cc2765e971a83992163f4cb1dbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8861d241a35bbc8bbe6c3f009afa3ed2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8861d241a35bbc8bbe6c3f009afa3ed2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_transfer</b> (<a class="el" href="a00501.html">iterator</a> __position, <a class="el" href="a00501.html">iterator</a> __first, <a class="el" href="a00501.html">iterator</a> __last)</td></tr>
<tr class="separator:a8861d241a35bbc8bbe6c3f009afa3ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a730d6d81e7678c3af33a52a9b64d7a55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a730d6d81e7678c3af33a52a9b64d7a55"></a>
static size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_S_distance</b> (const <a class="el" href="a00472.html">__detail::_List_node_base</a> *__first, const <a class="el" href="a00472.html">__detail::_List_node_base</a> *__last)</td></tr>
<tr class="separator:a730d6d81e7678c3af33a52a9b64d7a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a45d8f4028ca2ab10185bbf5da58c8c10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45d8f4028ca2ab10185bbf5da58c8c10"></a>
_List_impl&#160;</td><td class="memItemRight" valign="bottom"><b>_M_impl</b></td></tr>
<tr class="separator:a45d8f4028ca2ab10185bbf5da58c8c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;<br />
class std::list&lt; _Tp, _Alloc &gt;</h3>

<p>A standard container with linear time access to elements, and fixed time insertion/deletion at any point in the sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Type of element. </td></tr>
    <tr><td class="paramname">_Alloc</td><td>Allocator type, defaults to allocator&lt;_Tp&gt;.</td></tr>
  </table>
  </dd>
</dl>
<p>Meets the requirements of a <a href="tables.html#65">container</a>, a <a href="tables.html#66">reversible container</a>, and a <a href="tables.html#67">sequence</a>, including the <a href="tables.html#68">optional sequence requirements</a> with the exception of <code>at</code> and <code>operator</code>[].</p>
<p>This is a <em>doubly</em> <em>linked</em> list. Traversal up and down the list requires linear time, but adding and removing elements (or <em>nodes</em>) is done in constant time, regardless of where the change takes place. Unlike std::vector and std::deque, random-access iterators are not provided, so subscripting ( <code></code>[] ) access is not allowed. For algorithms which only need sequential access, this lack makes no difference.</p>
<p>Also unlike the other standard containers, std::list provides specialized algorithms unique to linked lists, such as splicing, sorting, and in-place reversal.</p>
<p>A couple points on memory allocation for list&lt;Tp&gt;:</p>
<p>First, we never actually allocate a Tp, we allocate List_node&lt;Tp&gt;'s and trust [20.1.5]/4 to DTRT. This is to ensure that after elements from list&lt;X,Alloc1&gt; are spliced into list&lt;X,Alloc2&gt;, destroying the memory of the second list is a valid operation, i.e., Alloc1 giveth and Alloc2 taketh away.</p>
<p>Second, a list conceptually represented as </p><div class="fragment"><div class="line">A &lt;---&gt; B &lt;---&gt; C &lt;---&gt; D</div>
</div><!-- fragment --><p> is actually circular; a link exists between A and D. The list class holds (as its only data member) a private list::iterator pointing to <em>D</em>, not to <em>A!</em> To get to the head of the list, we start at the tail and move forward by one. When this member iterator's next/previous pointers refer to itself, the list is empty. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00507">507</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5cec77d4bb0c37d6cd49fc87f72012ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00429.html">list</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a list with no elements. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00593">593</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7b6d1424066dbfd18daebac90d143837"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00429.html">list</a> </td>
          <td>(</td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a list with no elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>An allocator object. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a01272_source.html#l00604">604</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a463d42bea0d5b735392fd9b51d81e309"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00429.html">list</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a list with default constructed elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The number of elements to initially create.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor fills the list with <em>__n</em> default constructed elements. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00616">616</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac739777416320440d35c6de1a42ba818"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00429.html">list</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a list with copies of an exemplar element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The number of elements to initially create. </td></tr>
    <tr><td class="paramname">__value</td><td>An element to copy. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor fills the list with <em>__n</em> copies of <em>__value</em>. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00628">628</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="aec4657b924fb0c29b7d3e347a2da97f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00429.html">list</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00429.html">list</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A list of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>The newly-created list uses a copy of the allocation object used by <em>__x</em>. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00655">655</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6735f782a8c9a03d7bdd3ebf7f32da4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00429.html">list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00429.html">list</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A list of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>The newly-created list contains the exact contents of <em>__x</em>. The contents of <em>__x</em> are a valid, but unspecified list. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00667">667</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="abc914a91c0740ca3f52168d0b631dbf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00429.html">list</a> </td>
          <td>(</td>
          <td class="paramtype">initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>__l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a list from an initializer_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list of value_type. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a list consisting of copies of the elements in the initializer_list <em>__l</em>. This is linear in __l.size(). </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00678">678</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad905b1f7f844c8715c654439611804a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00429.html">list</a> </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a list from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a list consisting of copies of the elements from [<em>__first</em>,<em>__last</em>). This is linear in N (where N is distance(<em>__first</em>,<em>__last</em>)). </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00697">697</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a27e916ab6ecbc0fc92883eef796154a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00502.html">_Node</a>* <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::_M_create_node </td>
          <td>(</td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__args</td><td>An instance of user data.</td></tr>
  </table>
  </dd>
</dl>
<p>Allocates space for a new node and constructs a copy of <em>__args</em> in it. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00569">569</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9f1a22c8bd2a8d5ecacab44644f513db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a given value to a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>Number of elements to be assigned. </td></tr>
    <tr><td class="paramname">__val</td><td>Value to be assigned.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills a list with <em>__n</em> copies of the given value. Note that the assignment completely changes the list and that the resulting list's size is the same as the number of elements assigned. Old data may be lost. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00775">775</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

<p>Referenced by <a class="el" href="a01272_source.html#l00816">std::list&lt; __inp, __rebind_inp &gt;::assign()</a>, and <a class="el" href="a01272_source.html#l00757">std::list&lt; __inp, __rebind_inp &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a6527fbbec76ab1a8a4a80c04e6fcac70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a range to a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills a list with copies of the elements in the range [<em>__first</em>,<em>__last</em>).</p>
<p>Note that the assignment completely changes the list and that the resulting list's size is the same as the number of elements assigned. Old data may be lost. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00794">794</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a396193b1480defeaa5f3367ca15ec35e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an initializer_list to a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list of value_type.</td></tr>
  </table>
  </dd>
</dl>
<p>Replace the contents of the list with copies of the elements in the initializer_list <em>__l</em>. This is linear in __l.size(). </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00816">816</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9567c3ee9243b0159cb036f17ea74b53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reference to the data at the last element of the list. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01016">1016</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac43aac14d7c69657442718428b082aaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reference to the data at the last element of the list. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01028">1028</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1a0d75e77ac53db35e3cdf85ad6d3fa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00501.html">iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points to the first element in the list. Iteration is done in ordinary element order. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00831">831</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

<p>Referenced by <a class="el" href="a01272_source.html#l00931">std::list&lt; __inp, __rebind_inp &gt;::crend()</a>, <a class="el" href="a01272_source.html#l01000">std::list&lt; __inp, __rebind_inp &gt;::front()</a>, <a class="el" href="a01272_source.html#l00655">std::list&lt; __inp, __rebind_inp &gt;::list()</a>, <a class="el" href="a01272_source.html#l01807">std::operator==()</a>, <a class="el" href="a01272_source.html#l01074">std::list&lt; __inp, __rebind_inp &gt;::pop_front()</a>, <a class="el" href="a01272_source.html#l01047">std::list&lt; __inp, __rebind_inp &gt;::push_front()</a>, <a class="el" href="a01272_source.html#l00885">std::list&lt; __inp, __rebind_inp &gt;::rend()</a>, and <a class="el" href="a01272_source.html#l01386">std::list&lt; __inp, __rebind_inp &gt;::splice()</a>.</p>

</div>
</div>
<a class="anchor" id="acd7d9dc641209c8e429d291db8f2de25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00500.html">const_iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the list. Iteration is done in ordinary element order. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00840">840</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="aac9c52d90a45482d052dbb4b2040b6da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00500.html">const_iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the list. Iteration is done in ordinary element order. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00904">904</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a702400622789c3e0f1171369f803fcb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00500.html">const_iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the list. Iteration is done in ordinary element order. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00913">913</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae36feac84d9e8125b700ce5189ed9e95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases all the elements. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01366">1366</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

<p>Referenced by <a class="el" href="a01272_source.html#l00740">std::list&lt; __inp, __rebind_inp &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="ab0c1a4886327c94160ec35419c516f64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00688.html">const_reverse_iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to the last element in the list. Iteration is done in reverse element order. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00922">922</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="af9bc7bbe49c3f41b0dfaa3acd5c89e12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00688.html">const_reverse_iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to one before the first element in the list. Iteration is done in reverse element order. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00931">931</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3c95c4bf43ce0e94205cfa07db4f39d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00501.html">iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs object in list before specified iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the list. </td></tr>
    <tr><td class="paramname">__args</td><td>Arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert an object of type T constructed with T(std::forward&lt;Args&gt;(args)...) before the specified location. Due to the nature of a list this operation can be done in constant time, and does not invalidate iterators and references. </p>

<p>Referenced by <a class="el" href="a01272_source.html#l01176">std::list&lt; __inp, __rebind_inp &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="af558a1b206e6fdf40921aeaba0383dbe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the list is empty. (Thus begin() would equal end().) </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00941">941</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

<p>Referenced by <a class="el" href="a01272_source.html#l01386">std::list&lt; __inp, __rebind_inp &gt;::splice()</a>.</p>

</div>
</div>
<a class="anchor" id="aba82f0b94c1ed15ccacea0e98aa6cff6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00501.html">iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points one past the last element in the list. Iteration is done in ordinary element order. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00849">849</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

<p>Referenced by <a class="el" href="a01272_source.html#l01016">std::list&lt; __inp, __rebind_inp &gt;::back()</a>, <a class="el" href="a01272_source.html#l00922">std::list&lt; __inp, __rebind_inp &gt;::crbegin()</a>, <a class="el" href="a01272_source.html#l00655">std::list&lt; __inp, __rebind_inp &gt;::list()</a>, <a class="el" href="a01272_source.html#l01807">std::operator==()</a>, <a class="el" href="a01272_source.html#l01088">std::list&lt; __inp, __rebind_inp &gt;::push_back()</a>, <a class="el" href="a01272_source.html#l00867">std::list&lt; __inp, __rebind_inp &gt;::rbegin()</a>, and <a class="el" href="a01272_source.html#l01386">std::list&lt; __inp, __rebind_inp &gt;::splice()</a>.</p>

</div>
</div>
<a class="anchor" id="a39a7a20ed70dd4018608a3522d83124d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00500.html">const_iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the list. Iteration is done in ordinary element order. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00858">858</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad8be2fa84dabd368f22663afad64bc04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00501.html">iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove element at given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>Iterator pointing to element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the next element (or end()).</dd></dl>
<p>This function will erase the element at the given position and thus shorten the list by one.</p>
<p>Due to the nature of a list this operation can be done in constant time, and only invalidates iterators/references to the element being removed. The user is also cautioned that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p>Referenced by <a class="el" href="a01272_source.html#l01324">std::list&lt; __inp, __rebind_inp &gt;::erase()</a>.</p>

</div>
</div>
<a class="anchor" id="a927ad4d7e4673d4b2b33a16de379671b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00501.html">iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a range of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Iterator pointing to the first element to be erased. </td></tr>
    <tr><td class="paramname">__last</td><td>Iterator pointing to one past the last element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element pointed to by <em>last</em> prior to erasing (or end()).</dd></dl>
<p>This function will erase the elements in the range <em></em>[first,last) and shorten the list accordingly.</p>
<p>This operation is linear time in the size of the range and only invalidates iterators/references to the element being removed. The user is also cautioned that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01324">1324</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad4367625f1676f2fc0d56b891db683fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reference to the data at the first element of the list. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01000">1000</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5393c199d92f965d065b677f2230e51e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reference to the data at the first element of the list. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01008">1008</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a31f6032941520f4d9187fdf8284ae914"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the memory allocation object. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00822">822</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3b983ae6b7e1bc04c8adce4691e4c6a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00501.html">iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts given value into list before specified iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the list. </td></tr>
    <tr><td class="paramname">__x</td><td>Data to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert a copy of the given value before the specified location. Due to the nature of a list this operation can be done in constant time, and does not invalidate iterators and references. </p>

<p>Referenced by <a class="el" href="a01272_source.html#l01195">std::list&lt; __inp, __rebind_inp &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b70528dcf0f77ddb45429d463de07e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00501.html">iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts given rvalue into list before specified iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the list. </td></tr>
    <tr><td class="paramname">__x</td><td>Data to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert a copy of the given rvalue before the specified location. Due to the nature of a list this operation can be done in constant time, and does not invalidate iterators and references. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01176">1176</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="af9214e29cd05b8446678285415fb6f1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00501.html">iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>__l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the contents of an initializer_list into list before specified const_iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__p</td><td>A const_iterator into the list. </td></tr>
    <tr><td class="paramname">__l</td><td>An initializer_list of value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element inserted (or __position).</dd></dl>
<p>This function will insert copies of the data in the initializer_list <em>l</em> into the list before the location specified by <em>p</em>.</p>
<p>This operation is linear in the number of elements inserted and does not invalidate iterators and references. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01195">1195</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="afe8120aa63e348306b85d08b12e0c10b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00501.html">iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a number of copies of given data into the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the list. </td></tr>
    <tr><td class="paramname">__n</td><td>Number of elements to be inserted. </td></tr>
    <tr><td class="paramname">__x</td><td>Data to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element inserted (or __position).</dd></dl>
<p>This function will insert a specified number of copies of the given data before the location specified by <em>position</em>.</p>
<p>This operation is linear in the number of elements inserted and does not invalidate iterators and references. </p>

</div>
</div>
<a class="anchor" id="a070d9690cb94c94c978c3c429a432315"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00501.html">iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a range into the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the list. </td></tr>
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element inserted (or __position).</dd></dl>
<p>This function will insert copies of the data in the range [<em>first</em>,<em>last</em>) into the list before the location specified by <em>position</em>.</p>
<p>This operation is linear in the number of elements inserted and does not invalidate iterators and references. </p>

</div>
</div>
<a class="anchor" id="ac0642b1d26b07dcf28d5fd72bfbdd6d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size() of the largest possible list. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00951">951</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4ab57cf2c464c35225b087e94fd82d50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00429.html">list</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge sorted lists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Sorted list to merge.</td></tr>
  </table>
  </dd>
</dl>
<p>Assumes that both <em>__x</em> and this list are sorted according to operator&lt;(). Merges elements of <em>__x</em> into this list in sorted order, leaving <em>__x</em> empty when complete. Elements in this list precede elements in <em>__x</em> that are equal. </p>

</div>
</div>
<a class="anchor" id="a23e45d151199c59708d5dcc17d282ffc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _StrictWeakOrdering &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00429.html">list</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_StrictWeakOrdering&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge sorted lists according to comparison function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_StrictWeakOrdering</td><td>Comparison function defining sort order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Sorted list to merge. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison functor.</td></tr>
  </table>
  </dd>
</dl>
<p>Assumes that both <em>__x</em> and this list are sorted according to StrictWeakOrdering. Merges elements of <em>__x</em> into this list in sorted order, leaving <em>__x</em> empty when complete. Elements in this list precede elements in <em>__x</em> that are equivalent according to StrictWeakOrdering(). </p>

</div>
</div>
<a class="anchor" id="a8c3743566062b79f3554ac94bbfd19c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00429.html">list</a>&amp; <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00429.html">list</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List assignment operator. </p>
<p>No explicit dtor needed as the _Base dtor takes care of things. The _Base dtor only erases the elements, and note that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A list of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>All the elements of <em>__x</em> are copied, but unlike the copy constructor, the allocator object is not copied. </p>

</div>
</div>
<a class="anchor" id="a8c47aa2a28343d487b4d7ec001de6d38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00429.html">list</a>&amp; <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00429.html">list</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A list of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>The contents of <em>__x</em> are moved into this list (without copying). <em>__x</em> is a valid, but unspecified list </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00740">740</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7b554a6eab6e57e565eedb7da72a83c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00429.html">list</a>&amp; <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List initializer list assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list of value_type.</td></tr>
  </table>
  </dd>
</dl>
<p>Replace the contents of the list with copies of the elements in the initializer_list <em>__l</em>. This is linear in l.size(). </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00757">757</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a437f35446fc4e342d4df581335191a69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes last element. </p>
<p>This is a typical stack operation. It shrinks the list by one. Due to the nature of a list this operation can be done in constant time, and only invalidates iterators/references to the element being removed.</p>
<p>Note that no data is returned, and if the last element's data is needed, it should be retrieved before pop_back() is called. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01114">1114</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad744f7f3b84fc57c973ed2d3bb25a33e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes first element. </p>
<p>This is a typical stack operation. It shrinks the list by one. Due to the nature of a list this operation can be done in constant time, and only invalidates iterators/references to the element being removed.</p>
<p>Note that no data is returned, and if the first element's data is needed, it should be retrieved before pop_front() is called. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01074">1074</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a164bc4a9a0f40d98579507cfa9bb0313"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add data to the end of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Data to be added.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a typical stack operation. The function creates an element at the end of the list and assigns the given data to it. Due to the nature of a list this operation can be done in constant time, and does not invalidate iterators and references. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01088">1088</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a43ce26ebd4c6a1789692b7d377f332f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add data to the front of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Data to be added.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a typical stack operation. The function creates an element at the front of the list and assigns the given data to it. Due to the nature of a list this operation can be done in constant time, and does not invalidate iterators and references. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01047">1047</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8a4cacefc7a58e913f2e9876df0d59de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00688.html">reverse_iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reverse iterator that points to the last element in the list. Iteration is done in reverse element order. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00867">867</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ba0b1fa92ccc5268e64c0023632aee7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00688.html">const_reverse_iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to the last element in the list. Iteration is done in reverse element order. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00876">876</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9669f55bfe90a9a9d217bb95d2191356"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements equal to value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__value</td><td>The value to remove.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes every element in the list equal to <em>value</em>. Remaining elements stay in list order. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

</div>
</div>
<a class="anchor" id="a166140876ba96cfb1bc8c16825ceaf76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::remove_if </td>
          <td>(</td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements satisfying a predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Predicate</td><td>Unary predicate function or object.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes every element in the list for which the predicate returns true. Remaining elements stay in list order. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

</div>
</div>
<a class="anchor" id="a4018c8137dc053cfd04641f1ab4b070e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00688.html">reverse_iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reverse iterator that points to one before the first element in the list. Iteration is done in reverse element order. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00885">885</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="af134c3c02479d6b40c4b6dd9784ff9b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00688.html">const_reverse_iterator</a> <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to one before the first element in the list. Iteration is done in reverse element order. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00894">894</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="afe59a58ea5f8a9afcf818af671cb3d9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the list to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__new_size</td><td>Number of elements the list should contain.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will resize the list to the specified number of elements. If the number is smaller than the list's current size the list is truncated, otherwise default constructed elements are appended. </p>

</div>
</div>
<a class="anchor" id="ab9bfd70c04ab4c10ac198e65e41d5f9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the list to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__new_size</td><td>Number of elements the list should contain. </td></tr>
    <tr><td class="paramname">__x</td><td>Data with which new elements should be populated.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will resize the list to the specified number of elements. If the number is smaller than the list's current size the list is truncated, otherwise the list is extended and new elements are populated with given data. </p>

</div>
</div>
<a class="anchor" id="a7d420a62c310cd992f52c016293f969a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse the elements in list. </p>
<p>Reverse the order of elements in the list in linear time. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01650">1650</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4b6c305dd92e3c76213778feba213da2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements in the list. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l00946">946</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0093b7fd0e7113b5e4759fe4b7dba6bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort the elements. </p>
<p>Sorts the elements of this list in NlogN time. Equivalent elements remain in list order. </p>

</div>
</div>
<a class="anchor" id="a993a2dd135bf122f532b43a4bb7652f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _StrictWeakOrdering &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">_StrictWeakOrdering&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort the elements according to comparison function. </p>
<p>Sorts the elements of this list in NlogN time. Equivalent elements remain in list order. </p>

</div>
</div>
<a class="anchor" id="ae27f8110bc96c70775f1654e978b4c5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00429.html">list</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert contents of another list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>Iterator referencing the element to insert before. </td></tr>
    <tr><td class="paramname">__x</td><td>Source list.</td></tr>
  </table>
  </dd>
</dl>
<p>The elements of <em>__x</em> are inserted in constant time in front of the element referenced by <em>__position</em>. <em>__x</em> becomes an empty list.</p>
<p>Requires this != <em>__x</em>. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01386">1386</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

<p>Referenced by <a class="el" href="a01272_source.html#l01463">std::list&lt; __inp, __rebind_inp &gt;::splice()</a>.</p>

</div>
</div>
<a class="anchor" id="a11428bfeda40f933f26428bf432907db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00429.html">list</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert element from another list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>Const_iterator referencing the element to insert before. </td></tr>
    <tr><td class="paramname">__x</td><td>Source list. </td></tr>
    <tr><td class="paramname">__i</td><td>Const_iterator referencing the element to move.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes the element in list <em>__x</em> referenced by <em>__i</em> and inserts it into the current list before <em>__position</em>. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01421">1421</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa9275ed20653d145bd3c324e0b0422c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00429.html">list</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert element from another list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>Const_iterator referencing the element to insert before. </td></tr>
    <tr><td class="paramname">__x</td><td>Source list. </td></tr>
    <tr><td class="paramname">__i</td><td>Const_iterator referencing the element to move.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes the element in list <em>__x</em> referenced by <em>__i</em> and inserts it into the current list before <em>__position</em>. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01463">1463</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa4a9d0e45f35bc5c51ee5b1646304bb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00429.html">list</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert range from another list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>Const_iterator referencing the element to insert before. </td></tr>
    <tr><td class="paramname">__x</td><td>Source list. </td></tr>
    <tr><td class="paramname">__first</td><td>Const_iterator referencing the start of range in x. </td></tr>
    <tr><td class="paramname">__last</td><td>Const_iterator referencing the end of range in x.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes elements in the range [__first,__last) and inserts them before <em>__position</em> in constant time.</p>
<p>Undefined if <em>__position</em> is in [__first,__last). </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01482">1482</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5e2e8e3c78743063a5223b09a7f7abf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00429.html">list</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00500.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert range from another list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>Const_iterator referencing the element to insert before. </td></tr>
    <tr><td class="paramname">__x</td><td>Source list. </td></tr>
    <tr><td class="paramname">__first</td><td>Const_iterator referencing the start of range in x. </td></tr>
    <tr><td class="paramname">__last</td><td>Const_iterator referencing the end of range in x.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes elements in the range [__first,__last) and inserts them before <em>__position</em> in constant time.</p>
<p>Undefined if <em>__position</em> is in [__first,__last). </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01532">1532</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a695032584292f0cc36325aa8016f723b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00429.html">list</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps data with another list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A list of the same element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>This exchanges the elements between two lists in constant time. Note that the global std::swap() function is specialized such that std::swap(l1,l2) will feed to this function. </p>

<p>Definition at line <a class="el" href="a01272_source.html#l01344">1344</a> of file <a class="el" href="a01272_source.html">stl_list.h</a>.</p>

<p>Referenced by <a class="el" href="a01272_source.html#l00740">std::list&lt; __inp, __rebind_inp &gt;::operator=()</a>, and <a class="el" href="a01272_source.html#l01867">std::swap()</a>.</p>

</div>
</div>
<a class="anchor" id="ad2439ba07cb10d92d48abd7541dab5f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove consecutive duplicate elements. </p>
<p>For each consecutive set of elements with the same value, remove all but the first one. Remaining elements stay in list order. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

</div>
</div>
<a class="anchor" id="aa68b42ddc8f2a2994891cc928955e780"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00429.html">std::list</a>&lt; _Tp, _Alloc &gt;::unique </td>
          <td>(</td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove consecutive elements satisfying a predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_BinaryPredicate</td><td>Binary predicate function or object.</td></tr>
  </table>
  </dd>
</dl>
<p>For each consecutive set of elements [first,last) that satisfy predicate(first,i) where i is an iterator in [first,last), remove all but the first one. Remaining elements stay in list order. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a01272_source.html">stl_list.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a01379.html">std</a></li><li class="navelem"><a class="el" href="a00429.html">list</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>

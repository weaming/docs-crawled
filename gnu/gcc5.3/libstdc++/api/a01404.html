<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>libstdc++: Set Operation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a01404.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Set Operation<div class="ingroups"><a class="el" href="a01400.html">Algorithms</a> &raquo; <a class="el" href="a01403.html">Sorting</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Set Operation:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="a01404.svg" width="218" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga67c9386f01daa7763952b9096ab94c96"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 &gt; </td></tr>
<tr class="memitem:ga67c9386f01daa7763952b9096ab94c96"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01404.html#ga67c9386f01daa7763952b9096ab94c96">std::includes</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)</td></tr>
<tr class="separator:ga67c9386f01daa7763952b9096ab94c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeffeb80fabc63883a4d5e907ca922913"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _Compare &gt; </td></tr>
<tr class="memitem:gaeffeb80fabc63883a4d5e907ca922913"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01404.html#gaeffeb80fabc63883a4d5e907ca922913">std::includes</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)</td></tr>
<tr class="separator:gaeffeb80fabc63883a4d5e907ca922913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35787a357982adc415c29c036f7aada7"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; </td></tr>
<tr class="memitem:ga35787a357982adc415c29c036f7aada7"><td class="memTemplItemLeft" align="right" valign="top">_OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01404.html#ga35787a357982adc415c29c036f7aada7">std::set_difference</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)</td></tr>
<tr class="separator:ga35787a357982adc415c29c036f7aada7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cbebc70e1550ea9939c9269d7c7c289"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:ga7cbebc70e1550ea9939c9269d7c7c289"><td class="memTemplItemLeft" align="right" valign="top">_OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01404.html#ga7cbebc70e1550ea9939c9269d7c7c289">std::set_difference</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)</td></tr>
<tr class="separator:ga7cbebc70e1550ea9939c9269d7c7c289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7a7b81513c68b856c0a2699c29532d0"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; </td></tr>
<tr class="memitem:gad7a7b81513c68b856c0a2699c29532d0"><td class="memTemplItemLeft" align="right" valign="top">_OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01404.html#gad7a7b81513c68b856c0a2699c29532d0">std::set_intersection</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)</td></tr>
<tr class="separator:gad7a7b81513c68b856c0a2699c29532d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63b5280a2c5009456a51d38084ce1062"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:ga63b5280a2c5009456a51d38084ce1062"><td class="memTemplItemLeft" align="right" valign="top">_OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01404.html#ga63b5280a2c5009456a51d38084ce1062">std::set_intersection</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)</td></tr>
<tr class="separator:ga63b5280a2c5009456a51d38084ce1062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b7e12cbdb1a0d4e7691e9730e1924c5"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; </td></tr>
<tr class="memitem:ga3b7e12cbdb1a0d4e7691e9730e1924c5"><td class="memTemplItemLeft" align="right" valign="top">_OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01404.html#ga3b7e12cbdb1a0d4e7691e9730e1924c5">std::set_symmetric_difference</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)</td></tr>
<tr class="separator:ga3b7e12cbdb1a0d4e7691e9730e1924c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd18017e018c3090eacd4509e28cc432"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:gabd18017e018c3090eacd4509e28cc432"><td class="memTemplItemLeft" align="right" valign="top">_OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01404.html#gabd18017e018c3090eacd4509e28cc432">std::set_symmetric_difference</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)</td></tr>
<tr class="separator:gabd18017e018c3090eacd4509e28cc432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45c2e77ca73dabf6b1ccabbecf0291a6"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; </td></tr>
<tr class="memitem:ga45c2e77ca73dabf6b1ccabbecf0291a6"><td class="memTemplItemLeft" align="right" valign="top">_OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01404.html#ga45c2e77ca73dabf6b1ccabbecf0291a6">std::set_union</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)</td></tr>
<tr class="separator:ga45c2e77ca73dabf6b1ccabbecf0291a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d54d31bc70a0ff4596f5171ec728906"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; </td></tr>
<tr class="memitem:ga3d54d31bc70a0ff4596f5171ec728906"><td class="memTemplItemLeft" align="right" valign="top">_OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01404.html#ga3d54d31bc70a0ff4596f5171ec728906">std::set_union</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)</td></tr>
<tr class="separator:ga3d54d31bc70a0ff4596f5171ec728906"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>These algorithms are common set operations performed on sequences that are already sorted. The number of comparisons will be linear. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga67c9386f01daa7763952b9096ab94c96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool std::includes </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence exists in a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of search range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of search range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if each element in [__first2,__last2) is contained in order within [__first1,__last1). False otherwise.</dd></dl>
<p>This operation expects both [__first1,__last1) and [__first2,__last2) to be sorted. Searches for the presence of each element in [__first2,__last2) within [__first1,__last1). The iterators over each range only move forward, so this is a linear algorithm. If an element in [__first2,__last2) is not found before the search iterator reaches <code>__last2</code>, false is returned. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l02833">2833</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaeffeb80fabc63883a4d5e907ca922913"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool std::includes </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all elements of a sequence exists in a range using comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of search range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of search range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison function to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if each element in [__first2,__last2) is contained in order within [__first1,__last1) according to comp. False otherwise.</dd></dl>
<p>This operation expects both [__first1,__last1) and [__first2,__last2) to be sorted. Searches for the presence of each element in [__first2,__last2) within [__first1,__last1), using comp to decide. The iterators over each range only move forward, so this is a linear algorithm. If an element in [__first2,__last2) is not found before the search iterator reaches <code>__last2</code>, false is returned. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l02876">2876</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga35787a357982adc415c29c036f7aada7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::set_difference </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the difference of two sorted ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range. Iterators increment for each range. When the current element of the first range is less than the second, that element is copied and the iterator advances. If the current element of the second range is less, the iterator advances, but no element is copied. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l05220">5220</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7cbebc70e1550ea9939c9269d7c7c289"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::set_difference </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the difference of two sorted ranges using comparison functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range. Iterators increment for each range. When the current element of the first range is less than the second according to <code>__comp</code>, that element is copied and the iterator advances. If the current element of the second range is less, no element is copied and the iterator advances. If an element is contained in both ranges according to <code>__comp</code>, no elements are copied and both ranges advance. The output range may not overlap either input range. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l05268">5268</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad7a7b81513c68b856c0a2699c29532d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::set_intersection </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the intersection of two sorted ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that iterator advances. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l05104">5104</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga63b5280a2c5009456a51d38084ce1062"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::set_intersection </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the intersection of two sorted ranges using comparison functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to <code>__comp</code>, that iterator advances. If an element is contained in both ranges according to <code>__comp</code>, the element from the first range is copied and both ranges advance. The output range may not overlap either input range. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l05150">5150</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b7e12cbdb1a0d4e7691e9730e1924c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the symmetric difference of two sorted ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advances. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l05344">5344</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gabd18017e018c3090eacd4509e28cc432"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the symmetric difference of two sorted ranges using comparison functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to <code>comp</code>, that element is copied and the iterator advances. If an element is contained in both ranges according to <code>__comp</code>, no elements are copied and both ranges advance. The output range may not overlap either input range. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l05392">5392</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga45c2e77ca73dabf6b1ccabbecf0291a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::set_union </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the union of two sorted ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advanced. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l04989">4989</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3d54d31bc70a0ff4596f5171ec728906"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::set_union </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the union of two sorted ranges using a comparison functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to <code>__comp</code>, that element is copied and the iterator advanced. If an equivalent element according to <code>__comp</code> is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range. </p>

<p>Definition at line <a class="el" href="a01262_source.html#l05036">5036</a> of file <a class="el" href="a01262_source.html">stl_algo.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>libstdc++: std::deque&lt; _Tp, _Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00425.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="a02217.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">std::deque&lt; _Tp, _Alloc &gt; Class Template Reference<div class="ingroups"><a class="el" href="a01394.html">Containers</a> &raquo; <a class="el" href="a01395.html">Sequences</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for std::deque&lt; _Tp, _Alloc &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a02218.svg" width="171" height="123"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afe3fbd0baf6c30dd3fa06c3a0152aee6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe3fbd0baf6c30dd3fa06c3a0152aee6"></a>
typedef _Alloc&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:afe3fbd0baf6c30dd3fa06c3a0152aee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e32f71311ef10141cabaab48ac8e414"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e32f71311ef10141cabaab48ac8e414"></a>
typedef <a class="el" href="a00406.html">_Base::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a8e32f71311ef10141cabaab48ac8e414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5bb1b7f8f305ef36f9d962f0061d95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f5bb1b7f8f305ef36f9d962f0061d95"></a>
typedef _Alloc_traits::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:a7f5bb1b7f8f305ef36f9d962f0061d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e393735a0f7a53cf3da55bac4715f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2e393735a0f7a53cf3da55bac4715f7"></a>
typedef _Alloc_traits::const_reference&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:af2e393735a0f7a53cf3da55bac4715f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c71b231205293b158661ef681a3b3db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c71b231205293b158661ef681a3b3db"></a>
typedef <a class="el" href="a00688.html">std::reverse_iterator</a>&lt; <a class="el" href="a00406.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:a2c71b231205293b158661ef681a3b3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3317c1bdbb65b3992394420ef5f98a9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3317c1bdbb65b3992394420ef5f98a9e"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a3317c1bdbb65b3992394420ef5f98a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c936a6b01752957a341b82171006ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1c936a6b01752957a341b82171006ae"></a>
typedef <a class="el" href="a00406.html">_Base::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:af1c936a6b01752957a341b82171006ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0d108522fbeacba85c047645a91062"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade0d108522fbeacba85c047645a91062"></a>
typedef _Alloc_traits::pointer&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:ade0d108522fbeacba85c047645a91062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e682c4edd476461ddc1674192baf7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6e682c4edd476461ddc1674192baf7c"></a>
typedef _Alloc_traits::reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:ad6e682c4edd476461ddc1674192baf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7911e50991f4eb2c880b65bede5ee92d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7911e50991f4eb2c880b65bede5ee92d"></a>
typedef <a class="el" href="a00688.html">std::reverse_iterator</a>&lt; <a class="el" href="a00406.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a7911e50991f4eb2c880b65bede5ee92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7e27dbeb5afbf8391622192dc49865"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d7e27dbeb5afbf8391622192dc49865"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a7d7e27dbeb5afbf8391622192dc49865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bda40dc9295629fbf1dbcf417afea4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37bda40dc9295629fbf1dbcf417afea4"></a>
typedef _Tp&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a37bda40dc9295629fbf1dbcf417afea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae68c6ac05cd6e788a90c9b8a47c56756"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#ae68c6ac05cd6e788a90c9b8a47c56756">deque</a> ()</td></tr>
<tr class="separator:ae68c6ac05cd6e788a90c9b8a47c56756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cf87c79a7c6bdf2cf07749fb1e2ff5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#aa8cf87c79a7c6bdf2cf07749fb1e2ff5">deque</a> (const allocator_type &amp;__a)</td></tr>
<tr class="separator:aa8cf87c79a7c6bdf2cf07749fb1e2ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511a8f76d058f6bd0e2236abf8df23bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a511a8f76d058f6bd0e2236abf8df23bc">deque</a> (size_type __n, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:a511a8f76d058f6bd0e2236abf8df23bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858d7660a45a911f8ae7858246ea2f6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a858d7660a45a911f8ae7858246ea2f6d">deque</a> (size_type __n, const value_type &amp;__value, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:a858d7660a45a911f8ae7858246ea2f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03515a6af7f959e28cec591ac5f0f8b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a03515a6af7f959e28cec591ac5f0f8b2">deque</a> (const <a class="el" href="a00425.html">deque</a> &amp;__x)</td></tr>
<tr class="separator:a03515a6af7f959e28cec591ac5f0f8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d533f573a77a0f9bf33fa40dde1c9cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a7d533f573a77a0f9bf33fa40dde1c9cd">deque</a> (<a class="el" href="a00425.html">deque</a> &amp;&amp;__x)</td></tr>
<tr class="separator:a7d533f573a77a0f9bf33fa40dde1c9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0948ee096c5387c1deb1e5885d06c112"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a0948ee096c5387c1deb1e5885d06c112">deque</a> (const <a class="el" href="a00425.html">deque</a> &amp;__x, const allocator_type &amp;__a)</td></tr>
<tr class="separator:a0948ee096c5387c1deb1e5885d06c112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb7da7a228f22622f2e822252813d51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a0bb7da7a228f22622f2e822252813d51">deque</a> (<a class="el" href="a00425.html">deque</a> &amp;&amp;__x, const allocator_type &amp;__a)</td></tr>
<tr class="separator:a0bb7da7a228f22622f2e822252813d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc5fd34432d73edde92643c58d7db6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#abdc5fd34432d73edde92643c58d7db6d">deque</a> (initializer_list&lt; value_type &gt; __l, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:abdc5fd34432d73edde92643c58d7db6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11b72c35c99798a8aa8428206af7b74"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </td></tr>
<tr class="memitem:ac11b72c35c99798a8aa8428206af7b74"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00425.html#ac11b72c35c99798a8aa8428206af7b74">deque</a> (_InputIterator __first, _InputIterator __last, const allocator_type &amp;__a=allocator_type())</td></tr>
<tr class="separator:ac11b72c35c99798a8aa8428206af7b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7b8eb846862bae0ec76623338fa2a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a8e7b8eb846862bae0ec76623338fa2a7">~deque</a> ()</td></tr>
<tr class="separator:a8e7b8eb846862bae0ec76623338fa2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dabc6e005b7b5a19adf55792821e76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a65dabc6e005b7b5a19adf55792821e76">assign</a> (size_type __n, const value_type &amp;__val)</td></tr>
<tr class="separator:a65dabc6e005b7b5a19adf55792821e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0579ff04738a923ad49b8b9398af642"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </td></tr>
<tr class="memitem:ac0579ff04738a923ad49b8b9398af642"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00425.html#ac0579ff04738a923ad49b8b9398af642">assign</a> (_InputIterator __first, _InputIterator __last)</td></tr>
<tr class="separator:ac0579ff04738a923ad49b8b9398af642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16028e538ba034ad569b6933c152cdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#ab16028e538ba034ad569b6933c152cdb">assign</a> (initializer_list&lt; value_type &gt; __l)</td></tr>
<tr class="separator:ab16028e538ba034ad569b6933c152cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0080ca0ed1a2222104a5fb776a454f"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a4b0080ca0ed1a2222104a5fb776a454f">at</a> (size_type __n)</td></tr>
<tr class="separator:a4b0080ca0ed1a2222104a5fb776a454f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4761c527999561a89672ad75eceb9b38"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a4761c527999561a89672ad75eceb9b38">at</a> (size_type __n) const </td></tr>
<tr class="separator:a4761c527999561a89672ad75eceb9b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9345d8aadac1295d32b7390ede8478f5"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a9345d8aadac1295d32b7390ede8478f5">back</a> () noexcept</td></tr>
<tr class="separator:a9345d8aadac1295d32b7390ede8478f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebb54615350e129c2ce3b51368402bb"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a0ebb54615350e129c2ce3b51368402bb">back</a> () const noexcept</td></tr>
<tr class="separator:a0ebb54615350e129c2ce3b51368402bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71a8fc9a6dff2b04bfd8b219c40a940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00406.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#af71a8fc9a6dff2b04bfd8b219c40a940">begin</a> () noexcept</td></tr>
<tr class="separator:af71a8fc9a6dff2b04bfd8b219c40a940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c61891a706a301138fdc8dbf0d0209"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00406.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#ac5c61891a706a301138fdc8dbf0d0209">begin</a> () const noexcept</td></tr>
<tr class="separator:ac5c61891a706a301138fdc8dbf0d0209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289af3aac006b9faa969fbdf090f8202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00406.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a289af3aac006b9faa969fbdf090f8202">cbegin</a> () const noexcept</td></tr>
<tr class="separator:a289af3aac006b9faa969fbdf090f8202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56c2f3c25dc623eba9825a2e3eddd7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00406.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#ae56c2f3c25dc623eba9825a2e3eddd7c">cend</a> () const noexcept</td></tr>
<tr class="separator:ae56c2f3c25dc623eba9825a2e3eddd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a753bfa9e6b675bac7ee9ec4365fbdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a1a753bfa9e6b675bac7ee9ec4365fbdf">clear</a> () noexcept</td></tr>
<tr class="separator:a1a753bfa9e6b675bac7ee9ec4365fbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86674e16182ecb624e854ce7a653c03e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00688.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a86674e16182ecb624e854ce7a653c03e">crbegin</a> () const noexcept</td></tr>
<tr class="separator:a86674e16182ecb624e854ce7a653c03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d738d29f26320ce991399537a17bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00688.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a17d738d29f26320ce991399537a17bce">crend</a> () const noexcept</td></tr>
<tr class="separator:a17d738d29f26320ce991399537a17bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68320f37dc09cbf1ec830b050d9df1a7"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a68320f37dc09cbf1ec830b050d9df1a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00406.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00425.html#a68320f37dc09cbf1ec830b050d9df1a7">emplace</a> (<a class="el" href="a00406.html">const_iterator</a> __position, _Args &amp;&amp;...__args)</td></tr>
<tr class="separator:a68320f37dc09cbf1ec830b050d9df1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c89324bb69a551b554b7f6ac743bc8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac1c89324bb69a551b554b7f6ac743bc8"></a>
template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:ac1c89324bb69a551b554b7f6ac743bc8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_back</b> (_Args &amp;&amp;...__args)</td></tr>
<tr class="separator:ac1c89324bb69a551b554b7f6ac743bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d636b624a21f28b5bd77decf5b8fc92"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2d636b624a21f28b5bd77decf5b8fc92"></a>
template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a2d636b624a21f28b5bd77decf5b8fc92"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_front</b> (_Args &amp;&amp;...__args)</td></tr>
<tr class="separator:a2d636b624a21f28b5bd77decf5b8fc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512ed6c7e0dc244335b337da26d76f41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a512ed6c7e0dc244335b337da26d76f41">empty</a> () const noexcept</td></tr>
<tr class="separator:a512ed6c7e0dc244335b337da26d76f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b2da6c6329349581db042e6bbe2a40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00406.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a78b2da6c6329349581db042e6bbe2a40">end</a> () noexcept</td></tr>
<tr class="separator:a78b2da6c6329349581db042e6bbe2a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1986c3313eec924e6a7531929a82b8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00406.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#ad1986c3313eec924e6a7531929a82b8d">end</a> () const noexcept</td></tr>
<tr class="separator:ad1986c3313eec924e6a7531929a82b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0812f0cacd5dfd1108455df4fda375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00406.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a0e0812f0cacd5dfd1108455df4fda375">erase</a> (<a class="el" href="a00406.html">const_iterator</a> __position)</td></tr>
<tr class="separator:a0e0812f0cacd5dfd1108455df4fda375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f15e04574604071004bcdcd3be22fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00406.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#af8f15e04574604071004bcdcd3be22fc">erase</a> (<a class="el" href="a00406.html">const_iterator</a> __first, <a class="el" href="a00406.html">const_iterator</a> __last)</td></tr>
<tr class="separator:af8f15e04574604071004bcdcd3be22fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5172d8f3ab8a44f5f68f5d6256e5c7e"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#ae5172d8f3ab8a44f5f68f5d6256e5c7e">front</a> () noexcept</td></tr>
<tr class="separator:ae5172d8f3ab8a44f5f68f5d6256e5c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62222a6cab13f17c0489a3d6242dd6a8"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a62222a6cab13f17c0489a3d6242dd6a8">front</a> () const noexcept</td></tr>
<tr class="separator:a62222a6cab13f17c0489a3d6242dd6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d6b0cbbd61cda2b99f5fc4a274fe02"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a40d6b0cbbd61cda2b99f5fc4a274fe02">get_allocator</a> () const noexcept</td></tr>
<tr class="separator:a40d6b0cbbd61cda2b99f5fc4a274fe02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f068c70a5f8c6c08e67422551d3199"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00406.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#ad7f068c70a5f8c6c08e67422551d3199">insert</a> (<a class="el" href="a00406.html">const_iterator</a> __position, const value_type &amp;__x)</td></tr>
<tr class="separator:ad7f068c70a5f8c6c08e67422551d3199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec6ee2ba1f059f0addf6b9da5b596e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00406.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#adec6ee2ba1f059f0addf6b9da5b596e1">insert</a> (<a class="el" href="a00406.html">const_iterator</a> __position, value_type &amp;&amp;__x)</td></tr>
<tr class="separator:adec6ee2ba1f059f0addf6b9da5b596e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755a6d05ef2270de50ce270bea77250f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00406.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a755a6d05ef2270de50ce270bea77250f">insert</a> (<a class="el" href="a00406.html">const_iterator</a> __p, initializer_list&lt; value_type &gt; __l)</td></tr>
<tr class="separator:a755a6d05ef2270de50ce270bea77250f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad645c0144212cbfee911daa80578e997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00406.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#ad645c0144212cbfee911daa80578e997">insert</a> (<a class="el" href="a00406.html">const_iterator</a> __position, size_type __n, const value_type &amp;__x)</td></tr>
<tr class="separator:ad645c0144212cbfee911daa80578e997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2b0dd83e2d5c82db3b2df6918e484a"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </td></tr>
<tr class="memitem:aee2b0dd83e2d5c82db3b2df6918e484a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00406.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00425.html#aee2b0dd83e2d5c82db3b2df6918e484a">insert</a> (<a class="el" href="a00406.html">const_iterator</a> __position, _InputIterator __first, _InputIterator __last)</td></tr>
<tr class="separator:aee2b0dd83e2d5c82db3b2df6918e484a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aea8252ed76805923d591f878768f67"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a5aea8252ed76805923d591f878768f67">max_size</a> () const noexcept</td></tr>
<tr class="separator:a5aea8252ed76805923d591f878768f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c1afb4bdb22d1b03367d9c3b0a21c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00425.html">deque</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a38c1afb4bdb22d1b03367d9c3b0a21c8">operator=</a> (const <a class="el" href="a00425.html">deque</a> &amp;__x)</td></tr>
<tr class="separator:a38c1afb4bdb22d1b03367d9c3b0a21c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77734a257fa1c71752517d0ae6ae707d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00425.html">deque</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a77734a257fa1c71752517d0ae6ae707d">operator=</a> (<a class="el" href="a00425.html">deque</a> &amp;&amp;__x) noexcept(_Alloc_traits::_S_always_equal())</td></tr>
<tr class="separator:a77734a257fa1c71752517d0ae6ae707d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74898d8b495f47ced979e6ba66c4eef1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00425.html">deque</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a74898d8b495f47ced979e6ba66c4eef1">operator=</a> (initializer_list&lt; value_type &gt; __l)</td></tr>
<tr class="separator:a74898d8b495f47ced979e6ba66c4eef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461a433ad999e2d22e10f45addf1bb67"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a461a433ad999e2d22e10f45addf1bb67">operator[]</a> (size_type __n) noexcept</td></tr>
<tr class="separator:a461a433ad999e2d22e10f45addf1bb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513a4ab26ac9df40d7ec95fc50e1218b"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a513a4ab26ac9df40d7ec95fc50e1218b">operator[]</a> (size_type __n) const noexcept</td></tr>
<tr class="separator:a513a4ab26ac9df40d7ec95fc50e1218b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2299790b7c0080b2652ba374a2ea68fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a2299790b7c0080b2652ba374a2ea68fc">pop_back</a> () noexcept</td></tr>
<tr class="separator:a2299790b7c0080b2652ba374a2ea68fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5c33f2728f70a589e11a2e8b013e78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a3f5c33f2728f70a589e11a2e8b013e78">pop_front</a> () noexcept</td></tr>
<tr class="separator:a3f5c33f2728f70a589e11a2e8b013e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa261893d7576d53592700d030dedae78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#aa261893d7576d53592700d030dedae78">push_back</a> (const value_type &amp;__x)</td></tr>
<tr class="separator:aa261893d7576d53592700d030dedae78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff298f0b627fb33ac06d262cb2008259"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff298f0b627fb33ac06d262cb2008259"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (value_type &amp;&amp;__x)</td></tr>
<tr class="separator:aff298f0b627fb33ac06d262cb2008259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e23e99b8919a725e105786dd2bf20e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a5e23e99b8919a725e105786dd2bf20e9">push_front</a> (const value_type &amp;__x)</td></tr>
<tr class="separator:a5e23e99b8919a725e105786dd2bf20e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c4680e18e3644296ce686f6a6764c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20c4680e18e3644296ce686f6a6764c5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_front</b> (value_type &amp;&amp;__x)</td></tr>
<tr class="separator:a20c4680e18e3644296ce686f6a6764c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b51e916472a01d8d68945681ab8245"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00688.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a00b51e916472a01d8d68945681ab8245">rbegin</a> () noexcept</td></tr>
<tr class="separator:a00b51e916472a01d8d68945681ab8245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3714db48a222a584264a3e668bd5b3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00688.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#af3714db48a222a584264a3e668bd5b3c">rbegin</a> () const noexcept</td></tr>
<tr class="separator:af3714db48a222a584264a3e668bd5b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0daef1995ab8473dad46086c79ecb9f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00688.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a0daef1995ab8473dad46086c79ecb9f0">rend</a> () noexcept</td></tr>
<tr class="separator:a0daef1995ab8473dad46086c79ecb9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4c0290323b6a5a78b2e30d2706d753"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00688.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a2d4c0290323b6a5a78b2e30d2706d753">rend</a> () const noexcept</td></tr>
<tr class="separator:a2d4c0290323b6a5a78b2e30d2706d753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb09fae5538690a6175b6e738f39b59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a2cb09fae5538690a6175b6e738f39b59">resize</a> (size_type __new_size)</td></tr>
<tr class="separator:a2cb09fae5538690a6175b6e738f39b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7f1a01f2d6a06b4c89a4c5a84a9002"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a5f7f1a01f2d6a06b4c89a4c5a84a9002">resize</a> (size_type __new_size, const value_type &amp;__x)</td></tr>
<tr class="separator:a5f7f1a01f2d6a06b4c89a4c5a84a9002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9c2e87fe6d96dbbbf7f50f750d3cf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#abe9c2e87fe6d96dbbbf7f50f750d3cf2">shrink_to_fit</a> () noexcept</td></tr>
<tr class="separator:abe9c2e87fe6d96dbbbf7f50f750d3cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d5150e384f657ca3b317ced4dadc5d"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a24d5150e384f657ca3b317ced4dadc5d">size</a> () const noexcept</td></tr>
<tr class="separator:a24d5150e384f657ca3b317ced4dadc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453ac8930c84ded5680e0ba80cd23063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a453ac8930c84ded5680e0ba80cd23063">swap</a> (<a class="el" href="a00425.html">deque</a> &amp;__x) noexcept(_Alloc_traits::_S_nothrow_swap())</td></tr>
<tr class="separator:a453ac8930c84ded5680e0ba80cd23063"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:aff66aa061c5ac0f04b62ec4ca9ec6297"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff66aa061c5ac0f04b62ec4ca9ec6297"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>_S_initial_map_size</b>
 }</td></tr>
<tr class="separator:aff66aa061c5ac0f04b62ec4ca9ec6297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687644ef654670c010b783a163709d97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a687644ef654670c010b783a163709d97"></a>
typedef <a class="el" href="a00001.html">__gnu_cxx::__alloc_traits</a>&lt; _Map_alloc_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_Map_alloc_traits</b></td></tr>
<tr class="separator:a687644ef654670c010b783a163709d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7babfed89ab30924cfb43ffd9306dd2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7babfed89ab30924cfb43ffd9306dd2c"></a>
typedef _Alloc_traits::template rebind&lt; _Ptr &gt;::other&#160;</td><td class="memItemRight" valign="bottom"><b>_Map_alloc_type</b></td></tr>
<tr class="separator:a7babfed89ab30924cfb43ffd9306dd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9133dc0346264e1694441cbc215a6db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9133dc0346264e1694441cbc215a6db"></a>
typedef _Alloc_traits::pointer&#160;</td><td class="memItemRight" valign="bottom"><b>_Ptr</b></td></tr>
<tr class="separator:ab9133dc0346264e1694441cbc215a6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5435c02c8f84484efb996df8973dd793"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5435c02c8f84484efb996df8973dd793"></a>
typedef _Alloc_traits::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>_Ptr_const</b></td></tr>
<tr class="separator:a5435c02c8f84484efb996df8973dd793"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4605d776b9c6823e3133c1bf2d4c336a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4605d776b9c6823e3133c1bf2d4c336a"></a>
_Map_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>_M_allocate_map</b> (size_t __n)</td></tr>
<tr class="separator:a4605d776b9c6823e3133c1bf2d4c336a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0565094286d3d589d69cd8526a80b207"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0565094286d3d589d69cd8526a80b207"></a>
_Ptr&#160;</td><td class="memItemRight" valign="bottom"><b>_M_allocate_node</b> ()</td></tr>
<tr class="separator:a0565094286d3d589d69cd8526a80b207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709f6e91ef2548a3dd599694740e41b8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a709f6e91ef2548a3dd599694740e41b8"></a>
template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a709f6e91ef2548a3dd599694740e41b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_assign_aux</b> (_InputIterator __first, _InputIterator __last, <a class="el" href="a00612.html">std::input_iterator_tag</a>)</td></tr>
<tr class="separator:a709f6e91ef2548a3dd599694740e41b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac2272b2bdb5b0fa882d2d697382868"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4ac2272b2bdb5b0fa882d2d697382868"></a>
template&lt;typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:a4ac2272b2bdb5b0fa882d2d697382868"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_assign_aux</b> (_ForwardIterator __first, _ForwardIterator __last, <a class="el" href="a00565.html">std::forward_iterator_tag</a>)</td></tr>
<tr class="separator:a4ac2272b2bdb5b0fa882d2d697382868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce26fda041bf29c62785490b8ffaefa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ce26fda041bf29c62785490b8ffaefa"></a>
template&lt;typename _Integer &gt; </td></tr>
<tr class="memitem:a2ce26fda041bf29c62785490b8ffaefa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_assign_dispatch</b> (_Integer __n, _Integer __val, __true_type)</td></tr>
<tr class="separator:a2ce26fda041bf29c62785490b8ffaefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbd736977480a407bc02d9dc8d51333"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8dbd736977480a407bc02d9dc8d51333"></a>
template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a8dbd736977480a407bc02d9dc8d51333"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_assign_dispatch</b> (_InputIterator __first, _InputIterator __last, __false_type)</td></tr>
<tr class="separator:a8dbd736977480a407bc02d9dc8d51333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fb22e4b513cb736037e8dd4a115a1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74fb22e4b513cb736037e8dd4a115a1d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_create_nodes</b> (_Map_pointer __nstart, _Map_pointer __nfinish)</td></tr>
<tr class="separator:a74fb22e4b513cb736037e8dd4a115a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b97df23c5631c1a1d621503b4ee5afe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b97df23c5631c1a1d621503b4ee5afe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_deallocate_map</b> (_Map_pointer __p, size_t __n) noexcept</td></tr>
<tr class="separator:a7b97df23c5631c1a1d621503b4ee5afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e97f47e8c02f29ebaa29329649f568"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11e97f47e8c02f29ebaa29329649f568"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_deallocate_node</b> (_Ptr __p) noexcept</td></tr>
<tr class="separator:a11e97f47e8c02f29ebaa29329649f568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a268f7197eff5c854f675c37495f30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7a268f7197eff5c854f675c37495f30"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_default_append</b> (size_type __n)</td></tr>
<tr class="separator:ac7a268f7197eff5c854f675c37495f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4452a526b2b34f2f4b691bc3284a6e8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4452a526b2b34f2f4b691bc3284a6e8f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_default_initialize</b> ()</td></tr>
<tr class="separator:a4452a526b2b34f2f4b691bc3284a6e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db05f994447c462bc58b4807958b123"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0db05f994447c462bc58b4807958b123"></a>
template&lt;typename _Alloc1 &gt; </td></tr>
<tr class="memitem:a0db05f994447c462bc58b4807958b123"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_destroy_data</b> (<a class="el" href="a00406.html">iterator</a> __first, <a class="el" href="a00406.html">iterator</a> __last, const _Alloc1 &amp;)</td></tr>
<tr class="separator:a0db05f994447c462bc58b4807958b123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4056c0ac21a663bb141fa4558a24c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada4056c0ac21a663bb141fa4558a24c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_destroy_data</b> (<a class="el" href="a00406.html">iterator</a> __first, <a class="el" href="a00406.html">iterator</a> __last, const <a class="el" href="a00420.html">std::allocator</a>&lt; _Tp &gt; &amp;)</td></tr>
<tr class="separator:ada4056c0ac21a663bb141fa4558a24c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f45048ba27c192171de72440b71d7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8f45048ba27c192171de72440b71d7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_destroy_data_aux</b> (<a class="el" href="a00406.html">iterator</a> __first, <a class="el" href="a00406.html">iterator</a> __last)</td></tr>
<tr class="separator:aa8f45048ba27c192171de72440b71d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32fbc35c68d7a6a7b0fd5900e3e9610"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae32fbc35c68d7a6a7b0fd5900e3e9610"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_destroy_nodes</b> (_Map_pointer __nstart, _Map_pointer __nfinish) noexcept</td></tr>
<tr class="separator:ae32fbc35c68d7a6a7b0fd5900e3e9610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2d6a026b9e9fe63cc3d879b07a214e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc2d6a026b9e9fe63cc3d879b07a214e"></a>
<a class="el" href="a00406.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_M_erase</b> (<a class="el" href="a00406.html">iterator</a> __pos)</td></tr>
<tr class="separator:acc2d6a026b9e9fe63cc3d879b07a214e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836321e66d29c50233a504a1b7799436"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a836321e66d29c50233a504a1b7799436"></a>
<a class="el" href="a00406.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_M_erase</b> (<a class="el" href="a00406.html">iterator</a> __first, <a class="el" href="a00406.html">iterator</a> __last)</td></tr>
<tr class="separator:a836321e66d29c50233a504a1b7799436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d83aba6e3dffe62b1fc027b157e30a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57d83aba6e3dffe62b1fc027b157e30a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_erase_at_begin</b> (<a class="el" href="a00406.html">iterator</a> __pos)</td></tr>
<tr class="separator:a57d83aba6e3dffe62b1fc027b157e30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4c16713c19f42dedf7e6146bafeaaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d4c16713c19f42dedf7e6146bafeaaa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_erase_at_end</b> (<a class="el" href="a00406.html">iterator</a> __pos)</td></tr>
<tr class="separator:a6d4c16713c19f42dedf7e6146bafeaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4c9266e57c4b8ce368b252db1b15dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a4c9266e57c4b8ce368b252db1b15dc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_fill_assign</b> (size_type __n, const value_type &amp;__val)</td></tr>
<tr class="separator:a7a4c9266e57c4b8ce368b252db1b15dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccd12b9e9fa0710dce9caa5d3ebed91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#adccd12b9e9fa0710dce9caa5d3ebed91">_M_fill_initialize</a> (const value_type &amp;__value)</td></tr>
<tr class="separator:adccd12b9e9fa0710dce9caa5d3ebed91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90df0ed5c5dab5306abe6722e71f43ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90df0ed5c5dab5306abe6722e71f43ac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_fill_insert</b> (<a class="el" href="a00406.html">iterator</a> __pos, size_type __n, const value_type &amp;__x)</td></tr>
<tr class="separator:a90df0ed5c5dab5306abe6722e71f43ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34ec7649a3511dd93b8cc54d7108069"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae34ec7649a3511dd93b8cc54d7108069"></a>
_Map_alloc_type&#160;</td><td class="memItemRight" valign="bottom"><b>_M_get_map_allocator</b> () const noexcept</td></tr>
<tr class="separator:ae34ec7649a3511dd93b8cc54d7108069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415a2817dfd99640f105fae7e2097588"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a415a2817dfd99640f105fae7e2097588"></a>
_Tp_alloc_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_M_get_Tp_allocator</b> () noexcept</td></tr>
<tr class="separator:a415a2817dfd99640f105fae7e2097588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3557936e6f8bfe929846072e7cd0fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb3557936e6f8bfe929846072e7cd0fa"></a>
const _Tp_alloc_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_M_get_Tp_allocator</b> () const noexcept</td></tr>
<tr class="separator:aeb3557936e6f8bfe929846072e7cd0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedb487c969298e154c3fa4a4d4965f8"><td class="memTemplParams" colspan="2"><a class="anchor" id="acedb487c969298e154c3fa4a4d4965f8"></a>
template&lt;typename _Integer &gt; </td></tr>
<tr class="memitem:acedb487c969298e154c3fa4a4d4965f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_initialize_dispatch</b> (_Integer __n, _Integer __x, __true_type)</td></tr>
<tr class="separator:acedb487c969298e154c3fa4a4d4965f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264d6656baebebda3938367cd5e461ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a264d6656baebebda3938367cd5e461ca"></a>
template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a264d6656baebebda3938367cd5e461ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_initialize_dispatch</b> (_InputIterator __first, _InputIterator __last, __false_type)</td></tr>
<tr class="separator:a264d6656baebebda3938367cd5e461ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba38b77ebabad6056d04d9f65ffa74c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00405.html#a0ba38b77ebabad6056d04d9f65ffa74c">_M_initialize_map</a> (size_t)</td></tr>
<tr class="separator:a0ba38b77ebabad6056d04d9f65ffa74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28f8febc922625f754d05e114b72810"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac28f8febc922625f754d05e114b72810"></a>
template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:ac28f8febc922625f754d05e114b72810"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00406.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_insert_aux</b> (<a class="el" href="a00406.html">iterator</a> __pos, _Args &amp;&amp;...__args)</td></tr>
<tr class="separator:ac28f8febc922625f754d05e114b72810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ac2b801b027727e327fa0fbe1e7365"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01ac2b801b027727e327fa0fbe1e7365"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_insert_aux</b> (<a class="el" href="a00406.html">iterator</a> __pos, size_type __n, const value_type &amp;__x)</td></tr>
<tr class="separator:a01ac2b801b027727e327fa0fbe1e7365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da1ea8a0bb55438d89e49eb137d3b4d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9da1ea8a0bb55438d89e49eb137d3b4d"></a>
template&lt;typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:a9da1ea8a0bb55438d89e49eb137d3b4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_insert_aux</b> (<a class="el" href="a00406.html">iterator</a> __pos, _ForwardIterator __first, _ForwardIterator __last, size_type __n)</td></tr>
<tr class="separator:a9da1ea8a0bb55438d89e49eb137d3b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95175c53ab11dea26b321126522cef6e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a95175c53ab11dea26b321126522cef6e"></a>
template&lt;typename _Integer &gt; </td></tr>
<tr class="memitem:a95175c53ab11dea26b321126522cef6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_insert_dispatch</b> (<a class="el" href="a00406.html">iterator</a> __pos, _Integer __n, _Integer __x, __true_type)</td></tr>
<tr class="separator:a95175c53ab11dea26b321126522cef6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bc91cdee9ee972bece50561c3d8dcc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a03bc91cdee9ee972bece50561c3d8dcc"></a>
template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a03bc91cdee9ee972bece50561c3d8dcc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_insert_dispatch</b> (<a class="el" href="a00406.html">iterator</a> __pos, _InputIterator __first, _InputIterator __last, __false_type)</td></tr>
<tr class="separator:a03bc91cdee9ee972bece50561c3d8dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c5b81866d150bd167ae93d24b4006f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37c5b81866d150bd167ae93d24b4006f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_move_assign1</b> (<a class="el" href="a00425.html">deque</a> &amp;&amp;__x, true_type) noexcept</td></tr>
<tr class="separator:a37c5b81866d150bd167ae93d24b4006f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e07f2c0eacd093651a4eac0cd24f1a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e07f2c0eacd093651a4eac0cd24f1a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_move_assign1</b> (<a class="el" href="a00425.html">deque</a> &amp;&amp;__x, false_type)</td></tr>
<tr class="separator:a3e07f2c0eacd093651a4eac0cd24f1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087033ee97f430e6d37dce41b01b8c7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a087033ee97f430e6d37dce41b01b8c7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_move_assign2</b> (<a class="el" href="a00425.html">deque</a> &amp;&amp;__x, true_type)</td></tr>
<tr class="separator:a087033ee97f430e6d37dce41b01b8c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac603972d06c5d27a84b53822d0e1e117"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac603972d06c5d27a84b53822d0e1e117"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_M_move_assign2</b> (<a class="el" href="a00425.html">deque</a> &amp;&amp;__x, false_type)</td></tr>
<tr class="separator:ac603972d06c5d27a84b53822d0e1e117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84f5efa22db9cca063cca43f6d42622"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#aa84f5efa22db9cca063cca43f6d42622">_M_range_check</a> (size_type __n) const </td></tr>
<tr class="separator:aa84f5efa22db9cca063cca43f6d42622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cd73fee591b1b5e0a02eecd7166c39"><td class="memTemplParams" colspan="2"><a class="anchor" id="a33cd73fee591b1b5e0a02eecd7166c39"></a>
template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a33cd73fee591b1b5e0a02eecd7166c39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_range_insert_aux</b> (<a class="el" href="a00406.html">iterator</a> __pos, _InputIterator __first, _InputIterator __last, <a class="el" href="a00612.html">std::input_iterator_tag</a>)</td></tr>
<tr class="separator:a33cd73fee591b1b5e0a02eecd7166c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6757d55a8986453625b94233959de7c"><td class="memTemplParams" colspan="2"><a class="anchor" id="af6757d55a8986453625b94233959de7c"></a>
template&lt;typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:af6757d55a8986453625b94233959de7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_range_insert_aux</b> (<a class="el" href="a00406.html">iterator</a> __pos, _ForwardIterator __first, _ForwardIterator __last, <a class="el" href="a00565.html">std::forward_iterator_tag</a>)</td></tr>
<tr class="separator:af6757d55a8986453625b94233959de7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b8f511daa8a453538507ed6be885f5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a42b8f511daa8a453538507ed6be885f5"></a>
template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a42b8f511daa8a453538507ed6be885f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_M_replace_map</b> (_Args &amp;&amp;...__args)</td></tr>
<tr class="separator:a42b8f511daa8a453538507ed6be885f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56d5c0ef577f1af92696c4334f7546a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad56d5c0ef577f1af92696c4334f7546a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_M_shrink_to_fit</b> ()</td></tr>
<tr class="separator:ad56d5c0ef577f1af92696c4334f7546a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4d091c9fc4c0a4e27ba647d41cefff63"><td class="memTemplParams" colspan="2">template&lt;typename _InputIterator &gt; </td></tr>
<tr class="memitem:a4d091c9fc4c0a4e27ba647d41cefff63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00425.html#a4d091c9fc4c0a4e27ba647d41cefff63">_M_range_initialize</a> (_InputIterator __first, _InputIterator __last, <a class="el" href="a00612.html">std::input_iterator_tag</a>)</td></tr>
<tr class="separator:a4d091c9fc4c0a4e27ba647d41cefff63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b41e944b2520c325d9cd106b3f0726"><td class="memTemplParams" colspan="2">template&lt;typename _ForwardIterator &gt; </td></tr>
<tr class="memitem:a75b41e944b2520c325d9cd106b3f0726"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00425.html#a75b41e944b2520c325d9cd106b3f0726">_M_range_initialize</a> (_ForwardIterator __first, _ForwardIterator __last, <a class="el" href="a00565.html">std::forward_iterator_tag</a>)</td></tr>
<tr class="separator:a75b41e944b2520c325d9cd106b3f0726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a494d390912055fdc2f60740547935142"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a494d390912055fdc2f60740547935142"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00425.html#a494d390912055fdc2f60740547935142">_M_push_back_aux</a> (_Args &amp;&amp;...__args)</td></tr>
<tr class="separator:a494d390912055fdc2f60740547935142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc5650dc606f7b50dddea8d420b641f"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:addc5650dc606f7b50dddea8d420b641f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00425.html#addc5650dc606f7b50dddea8d420b641f">_M_push_front_aux</a> (_Args &amp;&amp;...__args)</td></tr>
<tr class="separator:addc5650dc606f7b50dddea8d420b641f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c874695d9fa0e900d66b0ec5d667c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#ad3c874695d9fa0e900d66b0ec5d667c7">_M_pop_back_aux</a> ()</td></tr>
<tr class="separator:ad3c874695d9fa0e900d66b0ec5d667c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d816928bc099bdd42613a23e3114ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a1d816928bc099bdd42613a23e3114ec5">_M_pop_front_aux</a> ()</td></tr>
<tr class="separator:a1d816928bc099bdd42613a23e3114ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2f8d8d37581896d79e8759a827bab9e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00406.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a2f8d8d37581896d79e8759a827bab9e0">_M_reserve_elements_at_front</a> (size_type __n)</td></tr>
<tr class="separator:a2f8d8d37581896d79e8759a827bab9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae525555e5d42a93d328bdd620705ce94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00406.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#ae525555e5d42a93d328bdd620705ce94">_M_reserve_elements_at_back</a> (size_type __n)</td></tr>
<tr class="separator:ae525555e5d42a93d328bdd620705ce94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650c36ee4ca474c9400d03d27483ea85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a650c36ee4ca474c9400d03d27483ea85">_M_new_elements_at_front</a> (size_type __new_elements)</td></tr>
<tr class="separator:a650c36ee4ca474c9400d03d27483ea85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679c4bafdc37634644268bb640765408"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a679c4bafdc37634644268bb640765408">_M_new_elements_at_back</a> (size_type __new_elements)</td></tr>
<tr class="separator:a679c4bafdc37634644268bb640765408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8ebf868f4aae064167a0a05292b19093"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a8ebf868f4aae064167a0a05292b19093">_M_reserve_map_at_back</a> (size_type __nodes_to_add=1)</td></tr>
<tr class="separator:a8ebf868f4aae064167a0a05292b19093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8eb5a8eedeacb9a0de37a42dfc5abc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#aa8eb5a8eedeacb9a0de37a42dfc5abc9">_M_reserve_map_at_front</a> (size_type __nodes_to_add=1)</td></tr>
<tr class="separator:aa8eb5a8eedeacb9a0de37a42dfc5abc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f4f06b5ef4d6ef48679da4739dc573"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00425.html#a65f4f06b5ef4d6ef48679da4739dc573">_M_reallocate_map</a> (size_type __nodes_to_add, bool __add_at_front)</td></tr>
<tr class="separator:a65f4f06b5ef4d6ef48679da4739dc573"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ad606e654ee0bcec85c1dadf76602fb1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad606e654ee0bcec85c1dadf76602fb1a"></a>
static size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_S_buffer_size</b> () noexcept</td></tr>
<tr class="separator:ad606e654ee0bcec85c1dadf76602fb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5e3339e8baafd02e6d232c5b25d42d63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e3339e8baafd02e6d232c5b25d42d63"></a>
_Deque_impl&#160;</td><td class="memItemRight" valign="bottom"><b>_M_impl</b></td></tr>
<tr class="separator:a5e3339e8baafd02e6d232c5b25d42d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;<br />
class std::deque&lt; _Tp, _Alloc &gt;</h3>

<p>A standard container using fixed-size memory allocation and constant-time manipulation of elements at either end. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Type of element. </td></tr>
    <tr><td class="paramname">_Alloc</td><td>Allocator type, defaults to allocator&lt;_Tp&gt;.</td></tr>
  </table>
  </dd>
</dl>
<p>Meets the requirements of a <a href="tables.html#65">container</a>, a <a href="tables.html#66">reversible container</a>, and a <a href="tables.html#67">sequence</a>, including the <a href="tables.html#68">optional sequence requirements</a>.</p>
<p>In previous HP/SGI versions of deque, there was an extra template parameter so users could control the node size. This extension turned out to violate the C++ standard (it can be detected using template template parameters), and it was removed.</p>
<p>Here's how a deque&lt;Tp&gt; manages memory. Each deque has 4 members:</p>
<ul>
<li>Tp** _M_map</li>
<li>size_t _M_map_size</li>
<li>iterator _M_start, _M_finish</li>
</ul>
<p>map_size is at least 8. map is an array of map_size pointers-to-<em>nodes</em>. (The name map has nothing to do with the std::map class, and <b>nodes</b> should not be confused with std::list's usage of <em>node</em>.)</p>
<p>A <em>node</em> has no specific type name as such, but it is referred to as <em>node</em> in this file. It is a simple array-of-Tp. If Tp is very large, there will be one Tp element per node (i.e., an <em>array</em> of one). For non-huge Tp's, node size is inversely related to Tp size: the larger the Tp, the fewer Tp's will fit in a node. The goal here is to keep the total size of a node relatively small and constant over different Tp's, to improve allocator efficiency.</p>
<p>Not every pointer in the map array will point to a node. If the initial number of elements in the deque is small, the /middle/ map pointers will be valid, and the ones at the edges will be unused. This same situation will arise as the map grows: available map pointers, if any, will be on the ends. As new nodes are created, only a subset of the map's pointers need to be copied <em>outward</em>.</p>
<p>Class invariants:</p><ul>
<li>For any nonsingular iterator i:<ul>
<li>i.node points to a member of the map array. (Yes, you read that correctly: i.node does not actually point to a node.) The member of the map array is what actually points to the node.</li>
<li>i.first == *(i.node) (This points to the node (first Tp element).)</li>
<li>i.last == i.first + node_size</li>
<li>i.cur is a pointer in the range [i.first, i.last). NOTE: the implication of this is that i.cur is always a dereferenceable pointer, even if i is a past-the-end iterator.</li>
</ul>
</li>
<li>Start and Finish are always nonsingular iterators. NOTE: this means that an empty deque must have one node, a deque with &lt;N elements (where N is the node buffer size) must have one node, a deque with N through (2N-1) elements must have two nodes, etc.</li>
<li>For every node other than start.node and finish.node, every element in the node is an initialized object. If start.node == finish.node, then [start.cur, finish.cur) are initialized objects, and the elements outside that range are uninitialized storage. Otherwise, [start.cur, start.last) and [finish.first, finish.cur) are initialized objects, and [start.first, start.cur) and [finish.cur, finish.last) are uninitialized storage.</li>
<li>[map, map + map_size) is a valid, non-empty range.</li>
<li>[start.node, finish.node] is a valid range contained within [map, map + map_size).</li>
<li><p class="startli">A pointer in the range [map, map + map_size) points to an allocated node if and only if the pointer is in the range [start.node, finish.node].</p>
<p class="startli">Here's the magic: nothing in deque is <b>aware</b> of the discontiguous storage!</p>
<p class="startli">The memory setup and layout occurs in the parent, _Base, and the iterator class is entirely responsible for <em>leaping</em> from one node to the next. All the implementation routines for deque itself work only through the start and finish iterators. This keeps the routines simple and sane, and we can use other standard algorithms as well. </p>
</li>
</ul>

<p>Definition at line <a class="el" href="a01266_source.html#l00830">830</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae68c6ac05cd6e788a90c9b8a47c56756"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00425.html">deque</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deque with no elements. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l00883">883</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa8cf87c79a7c6bdf2cf07749fb1e2ff5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00425.html">deque</a> </td>
          <td>(</td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deque with no elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>An allocator object. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a01266_source.html#l00890">890</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a511a8f76d058f6bd0e2236abf8df23bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00425.html">deque</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deque with default constructed elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The number of elements to initially create.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor fills the deque with <em>n</em> default constructed elements. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l00902">902</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a858d7660a45a911f8ae7858246ea2f6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00425.html">deque</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deque with copies of an exemplar element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The number of elements to initially create. </td></tr>
    <tr><td class="paramname">__value</td><td>An element to copy. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor fills the deque with <em>__n</em> copies of <em>__value</em>. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l00914">914</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a03515a6af7f959e28cec591ac5f0f8b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00425.html">deque</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00425.html">deque</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deque copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A deque of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>The newly-created deque uses a copy of the allocation object used by <em>__x</em>. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l00941">941</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7d533f573a77a0f9bf33fa40dde1c9cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00425.html">deque</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00425.html">deque</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deque move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A deque of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>The newly-created deque contains the exact contents of <em>__x</em>. The contents of <em>__x</em> are a valid, but unspecified deque. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l00956">956</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0948ee096c5387c1deb1e5885d06c112"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00425.html">deque</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00425.html">deque</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor with alternative allocator. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l00960">960</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0bb7da7a228f22622f2e822252813d51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00425.html">deque</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00425.html">deque</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor with alternative allocator. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l00967">967</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="abdc5fd34432d73edde92643c58d7db6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00425.html">deque</a> </td>
          <td>(</td>
          <td class="paramtype">initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>__l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a deque from an initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a deque consisting of copies of the elements in the initializer_list <em>__l</em>.</p>
<p>This will call the element type's copy constructor N times (where N is __l.size()) and do no memory reallocation. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l00990">990</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac11b72c35c99798a8aa8428206af7b74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::<a class="el" href="a00425.html">deque</a> </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a deque from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a deque consisting of copies of the elements from [__first, __last).</p>
<p>If the iterators are forward, bidirectional, or random-access, then this will call the elements' copy constructor N times (where N is distance(__first,__last)) and do no memory reallocation. But if only input iterators are used, then this will do at most 2N calls to the copy constructor, and logN memory reallocations. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01017">1017</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8e7b8eb846862bae0ec76623338fa2a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::~<a class="el" href="a00425.html">deque</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dtor only erases the elements, and note that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01038">1038</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adccd12b9e9fa0710dce9caa5d3ebed91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::_M_fill_initialize </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the deque with copies of value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__value</td><td>Initial value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>_M_start and _M_finish have already been initialized, but none of the deque's elements have yet been constructed.</dd></dl>
<p>This function is called only when the user provides an explicit size (with or without an explicit exemplar value). </p>

<p>Referenced by <a class="el" href="a01266_source.html#l00914">std::deque&lt; _StateSeqT &gt;::deque()</a>.</p>

</div>
</div>
<a class="anchor" id="a0ba38b77ebabad6056d04d9f65ffa74c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00405.html">std::_Deque_base</a>&lt; _Tp, _Alloc &gt;::_M_initialize_map </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>__num_elements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Layout storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__num_elements</td><td>The count of T's for which to allocate space at first. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The initial underlying memory layout is a bit complicated... </p>

<p>Definition at line <a class="el" href="a01266_source.html#l00681">681</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

<p>References <a class="el" href="a01263_source.html#l00219">std::max()</a>.</p>

</div>
</div>
<a class="anchor" id="a679c4bafdc37634644268bb640765408"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::_M_new_elements_at_back </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__new_elements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory-handling helpers for the previous internal insert functions. </p>

<p>Referenced by <a class="el" href="a01266_source.html#l02088">std::deque&lt; _StateSeqT &gt;::_M_reserve_elements_at_back()</a>.</p>

</div>
</div>
<a class="anchor" id="a650c36ee4ca474c9400d03d27483ea85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::_M_new_elements_at_front </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__new_elements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory-handling helpers for the previous internal insert functions. </p>

<p>Referenced by <a class="el" href="a01266_source.html#l02078">std::deque&lt; _StateSeqT &gt;::_M_reserve_elements_at_front()</a>.</p>

</div>
</div>
<a class="anchor" id="ad3c874695d9fa0e900d66b0ec5d667c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::_M_pop_back_aux </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper functions for push_* and pop_*. </p>

<p>Referenced by <a class="el" href="a01266_source.html#l01570">std::deque&lt; _StateSeqT &gt;::pop_back()</a>.</p>

</div>
</div>
<a class="anchor" id="a1d816928bc099bdd42613a23e3114ec5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::_M_pop_front_aux </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper functions for push_* and pop_*. </p>

<p>Referenced by <a class="el" href="a01266_source.html#l01548">std::deque&lt; _StateSeqT &gt;::pop_front()</a>.</p>

</div>
</div>
<a class="anchor" id="a494d390912055fdc2f60740547935142"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::_M_push_back_aux </td>
          <td>(</td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper functions for push_* and pop_*. </p>

<p>Referenced by <a class="el" href="a01266_source.html#l01516">std::deque&lt; _StateSeqT &gt;::push_back()</a>.</p>

</div>
</div>
<a class="anchor" id="addc5650dc606f7b50dddea8d420b641f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::_M_push_front_aux </td>
          <td>(</td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper functions for push_* and pop_*. </p>

<p>Referenced by <a class="el" href="a01266_source.html#l01483">std::deque&lt; _StateSeqT &gt;::push_front()</a>.</p>

</div>
</div>
<a class="anchor" id="aa84f5efa22db9cca063cca43f6d42622"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::_M_range_check </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safety check used only from at(). </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01386">1386</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

<p>Referenced by <a class="el" href="a01266_source.html#l01408">std::deque&lt; _StateSeqT &gt;::at()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d091c9fc4c0a4e27ba647d41cefff63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::_M_range_initialize </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00612.html">std::input_iterator_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the deque with whatever is in [first,last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>If the iterators are actually forward iterators (or better), then the memory layout can be done all at once. Else we move forward using push_back on each value from the iterator. </p>

<p>Referenced by <a class="el" href="a01266_source.html#l00990">std::deque&lt; _StateSeqT &gt;::deque()</a>.</p>

</div>
</div>
<a class="anchor" id="a75b41e944b2520c325d9cd106b3f0726"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::_M_range_initialize </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00565.html">std::forward_iterator_tag</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the deque with whatever is in [first,last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>If the iterators are actually forward iterators (or better), then the memory layout can be done all at once. Else we move forward using push_back on each value from the iterator. </p>

</div>
</div>
<a class="anchor" id="a65f4f06b5ef4d6ef48679da4739dc573"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::_M_reallocate_map </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__nodes_to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>__add_at_front</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory-handling helpers for the major map. </p>
<p>Makes sure the _M_map has space for new nodes. Does not actually add the nodes. Can invalidate _M_map pointers. (And consequently, deque iterators.) </p>

<p>Referenced by <a class="el" href="a01266_source.html#l02114">std::deque&lt; _StateSeqT &gt;::_M_reserve_map_at_back()</a>, and <a class="el" href="a01266_source.html#l02122">std::deque&lt; _StateSeqT &gt;::_M_reserve_map_at_front()</a>.</p>

</div>
</div>
<a class="anchor" id="ae525555e5d42a93d328bdd620705ce94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00406.html">iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::_M_reserve_elements_at_back </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory-handling helpers for the previous internal insert functions. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l02088">2088</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2f8d8d37581896d79e8759a827bab9e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00406.html">iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::_M_reserve_elements_at_front </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory-handling helpers for the previous internal insert functions. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l02078">2078</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8ebf868f4aae064167a0a05292b19093"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::_M_reserve_map_at_back </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__nodes_to_add</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory-handling helpers for the major map. </p>
<p>Makes sure the _M_map has space for new nodes. Does not actually add the nodes. Can invalidate _M_map pointers. (And consequently, deque iterators.) </p>

<p>Definition at line <a class="el" href="a01266_source.html#l02114">2114</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa8eb5a8eedeacb9a0de37a42dfc5abc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::_M_reserve_map_at_front </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__nodes_to_add</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory-handling helpers for the major map. </p>
<p>Makes sure the _M_map has space for new nodes. Does not actually add the nodes. Can invalidate _M_map pointers. (And consequently, deque iterators.) </p>

<p>Definition at line <a class="el" href="a01266_source.html#l02122">2122</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a65dabc6e005b7b5a19adf55792821e76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a given value to a deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>Number of elements to be assigned. </td></tr>
    <tr><td class="paramname">__val</td><td>Value to be assigned.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills a deque with <em>n</em> copies of the given value. Note that the assignment completely changes the deque and that the resulting deque's size is the same as the number of elements assigned. Old data may be lost. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01099">1099</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

<p>Referenced by <a class="el" href="a01266_source.html#l01143">std::deque&lt; _StateSeqT &gt;::assign()</a>, and <a class="el" href="a01266_source.html#l01081">std::deque&lt; _StateSeqT &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="ac0579ff04738a923ad49b8b9398af642"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a range to a deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills a deque with copies of the elements in the range [__first,__last).</p>
<p>Note that the assignment completely changes the deque and that the resulting deque's size is the same as the number of elements assigned. Old data may be lost. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01118">1118</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab16028e538ba034ad569b6933c152cdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an initializer list to a deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills a deque with copies of the elements in the initializer_list <em>__l</em>.</p>
<p>Note that the assignment completely changes the deque and that the resulting deque's size is the same as the number of elements assigned. Old data may be lost. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01143">1143</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4b0080ca0ed1a2222104a5fb776a454f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the data contained in the deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read/write reference to data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <em>__n</em> is an invalid index.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides for safer data access. The parameter is first checked that it is in the range of the deque. The function throws out_of_range if the check fails. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01408">1408</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4761c527999561a89672ad75eceb9b38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the data contained in the deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read-only (constant) reference to data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <em>__n</em> is an invalid index.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides for safer data access. The parameter is first checked that it is in the range of the deque. The function throws out_of_range if the check fails. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01426">1426</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9345d8aadac1295d32b7390ede8478f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reference to the data at the last element of the deque. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01453">1453</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0ebb54615350e129c2ce3b51368402bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reference to the data at the last element of the deque. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01465">1465</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="af71a8fc9a6dff2b04bfd8b219c40a940"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00406.html">iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points to the first element in the deque. Iteration is done in ordinary element order. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01158">1158</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

<p>Referenced by <a class="el" href="a01266_source.html#l01800">std::deque&lt; _StateSeqT &gt;::clear()</a>, <a class="el" href="a01266_source.html#l00941">std::deque&lt; _StateSeqT &gt;::deque()</a>, <a class="el" href="a01266_source.html#l01437">std::deque&lt; _StateSeqT &gt;::front()</a>, <a class="el" href="a01266_source.html#l01662">std::deque&lt; _StateSeqT &gt;::insert()</a>, <a class="el" href="a01266_source.html#l02220">std::operator==()</a>, and <a class="el" href="a01266_source.html#l01038">std::deque&lt; _StateSeqT &gt;::~deque()</a>.</p>

</div>
</div>
<a class="anchor" id="ac5c61891a706a301138fdc8dbf0d0209"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00406.html">const_iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the deque. Iteration is done in ordinary element order. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01166">1166</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a289af3aac006b9faa969fbdf090f8202"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00406.html">const_iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the deque. Iteration is done in ordinary element order. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01229">1229</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

<p>Referenced by <a class="el" href="a01266_source.html#l01662">std::deque&lt; _StateSeqT &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="ae56c2f3c25dc623eba9825a2e3eddd7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00406.html">const_iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the deque. Iteration is done in ordinary element order. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01238">1238</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1a753bfa9e6b675bac7ee9ec4365fbdf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases all the elements. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01800">1800</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a86674e16182ecb624e854ce7a653c03e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00688.html">const_reverse_iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to the last element in the deque. Iteration is done in reverse element order. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01247">1247</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a17d738d29f26320ce991399537a17bce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00688.html">const_reverse_iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to one before the first element in the deque. Iteration is done in reverse element order. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01256">1256</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a68320f37dc09cbf1ec830b050d9df1a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00406.html">iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00406.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an object in deque before specified iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the deque. </td></tr>
    <tr><td class="paramname">__args</td><td>Arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert an object of type T constructed with T(std::forward&lt;Args&gt;(args)...) before the specified location. </p>

<p>Referenced by <a class="el" href="a01266_source.html#l01633">std::deque&lt; _StateSeqT &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="a512ed6c7e0dc244335b337da26d76f41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the deque is empty. (Thus begin() would equal end().) </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01349">1349</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a78b2da6c6329349581db042e6bbe2a40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00406.html">iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points one past the last element in the deque. Iteration is done in ordinary element order. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01175">1175</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

<p>Referenced by <a class="el" href="a01266_source.html#l01453">std::deque&lt; _StateSeqT &gt;::back()</a>, <a class="el" href="a01266_source.html#l00941">std::deque&lt; _StateSeqT &gt;::deque()</a>, <a class="el" href="a01266_source.html#l02220">std::operator==()</a>, and <a class="el" href="a01266_source.html#l01038">std::deque&lt; _StateSeqT &gt;::~deque()</a>.</p>

</div>
</div>
<a class="anchor" id="ad1986c3313eec924e6a7531929a82b8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00406.html">const_iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the deque. Iteration is done in ordinary element order. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01184">1184</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0e0812f0cacd5dfd1108455df4fda375"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00406.html">iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00406.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove element at given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>Iterator pointing to element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the next element (or end()).</dd></dl>
<p>This function will erase the element at the given position and thus shorten the deque by one.</p>
<p>The user is cautioned that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01743">1743</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="af8f15e04574604071004bcdcd3be22fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00406.html">iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00406.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00406.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a range of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Iterator pointing to the first element to be erased. </td></tr>
    <tr><td class="paramname">__last</td><td>Iterator pointing to one past the last element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element pointed to by <em>last</em> prior to erasing (or end()).</dd></dl>
<p>This function will erase the elements in the range [__first,__last) and shorten the deque accordingly.</p>
<p>The user is cautioned that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01767">1767</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae5172d8f3ab8a44f5f68f5d6256e5c7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reference to the data at the first element of the deque. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01437">1437</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a62222a6cab13f17c0489a3d6242dd6a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reference to the data at the first element of the deque. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01445">1445</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a40d6b0cbbd61cda2b99f5fc4a274fe02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the memory allocation object. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01149">1149</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad7f068c70a5f8c6c08e67422551d3199"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00406.html">iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00406.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts given value into deque before specified iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the deque. </td></tr>
    <tr><td class="paramname">__x</td><td>Data to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert a copy of the given value before the specified location. </p>

<p>Referenced by <a class="el" href="a01266_source.html#l01646">std::deque&lt; _StateSeqT &gt;::insert()</a>, and <a class="el" href="a01266_source.html#l01304">std::deque&lt; _StateSeqT &gt;::resize()</a>.</p>

</div>
</div>
<a class="anchor" id="adec6ee2ba1f059f0addf6b9da5b596e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00406.html">iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00406.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts given rvalue into deque before specified iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the deque. </td></tr>
    <tr><td class="paramname">__x</td><td>Data to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert a copy of the given rvalue before the specified location. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01633">1633</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a755a6d05ef2270de50ce270bea77250f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00406.html">iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00406.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>__l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an initializer list into the deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__p</td><td>An iterator into the deque. </td></tr>
    <tr><td class="paramname">__l</td><td>An initializer_list.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will insert copies of the data in the initializer_list <em>__l</em> into the deque before the location specified by <em>__p</em>. This is known as <em>list insert</em>. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01646">1646</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad645c0144212cbfee911daa80578e997"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00406.html">iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00406.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a number of copies of given data into the deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the deque. </td></tr>
    <tr><td class="paramname">__n</td><td>Number of elements to be inserted. </td></tr>
    <tr><td class="paramname">__x</td><td>Data to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert a specified number of copies of the given data before the location specified by <em>__position</em>. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01662">1662</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="aee2b0dd83e2d5c82db3b2df6918e484a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator , typename  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00406.html">iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00406.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a range into the deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>A const_iterator into the deque. </td></tr>
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted data.</dd></dl>
<p>This function will insert copies of the data in the range [__first,__last) into the deque before the location specified by <em>__position</em>. This is known as <em>range insert</em>. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01698">1698</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5aea8252ed76805923d591f878768f67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size() of the largest possible deque. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01268">1268</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a38c1afb4bdb22d1b03367d9c3b0a21c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00425.html">deque</a>&amp; <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00425.html">deque</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deque assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A deque of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>All the elements of <em>x</em> are copied, but unlike the copy constructor, the allocator object is not copied. </p>

</div>
</div>
<a class="anchor" id="a77734a257fa1c71752517d0ae6ae707d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00425.html">deque</a>&amp; <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00425.html">deque</a>&lt; _Tp, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deque move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A deque of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>The contents of <em>__x</em> are moved into this deque (without copying, if the allocators permit it). <em>__x</em> is a valid, but unspecified deque. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01061">1061</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a74898d8b495f47ced979e6ba66c4eef1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00425.html">deque</a>&amp; <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an initializer list to a deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills a deque with copies of the elements in the initializer_list <em>__l</em>.</p>
<p>Note that the assignment completely changes the deque and that the resulting deque's size is the same as the number of elements assigned. Old data may be lost. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01081">1081</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a461a433ad999e2d22e10f45addf1bb67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript access to the data contained in the deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read/write reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. (For checked lookups see at().) </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01365">1365</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a513a4ab26ac9df40d7ec95fc50e1218b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript access to the data contained in the deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The index of the element for which data should be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read-only (constant) reference to data.</dd></dl>
<p>This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and out_of_range lookups are not defined. (For checked lookups see at().) </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01380">1380</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2299790b7c0080b2652ba374a2ea68fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes last element. </p>
<p>This is a typical stack operation. It shrinks the deque by one.</p>
<p>Note that no data is returned, and if the last element's data is needed, it should be retrieved before pop_back() is called. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01570">1570</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3f5c33f2728f70a589e11a2e8b013e78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes first element. </p>
<p>This is a typical stack operation. It shrinks the deque by one.</p>
<p>Note that no data is returned, and if the first element's data is needed, it should be retrieved before pop_front() is called. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01548">1548</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa261893d7576d53592700d030dedae78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add data to the end of the deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Data to be added.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a typical stack operation. The function creates an element at the end of the deque and assigns the given data to it. Due to the nature of a deque this operation can be done in constant time. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01516">1516</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5e23e99b8919a725e105786dd2bf20e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add data to the front of the deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Data to be added.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a typical stack operation. The function creates an element at the front of the deque and assigns the given data to it. Due to the nature of a deque this operation can be done in constant time. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01483">1483</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a00b51e916472a01d8d68945681ab8245"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00688.html">reverse_iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reverse iterator that points to the last element in the deque. Iteration is done in reverse element order. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01193">1193</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="af3714db48a222a584264a3e668bd5b3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00688.html">const_reverse_iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to the last element in the deque. Iteration is done in reverse element order. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01202">1202</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0daef1995ab8473dad46086c79ecb9f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00688.html">reverse_iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write reverse iterator that points to one before the first element in the deque. Iteration is done in reverse element order. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01211">1211</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2d4c0290323b6a5a78b2e30d2706d753"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00688.html">const_reverse_iterator</a> <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to one before the first element in the deque. Iteration is done in reverse element order. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01220">1220</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2cb09fae5538690a6175b6e738f39b59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the deque to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__new_size</td><td>Number of elements the deque should contain.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will resize the deque to the specified number of elements. If the number is smaller than the deque's current size the deque is truncated, otherwise default constructed elements are appended. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01282">1282</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5f7f1a01f2d6a06b4c89a4c5a84a9002"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>__new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the deque to the specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__new_size</td><td>Number of elements the deque should contain. </td></tr>
    <tr><td class="paramname">__x</td><td>Data with which new elements should be populated.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will resize the deque to the specified number of elements. If the number is smaller than the deque's current size the deque is truncated, otherwise the deque is extended and new elements are populated with given data. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01304">1304</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="abe9c2e87fe6d96dbbbf7f50f750d3cf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A non-binding request to reduce memory use. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01340">1340</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

</div>
</div>
<a class="anchor" id="a24d5150e384f657ca3b317ced4dadc5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements in the deque. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01263">1263</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

<p>Referenced by <a class="el" href="a01266_source.html#l01386">std::deque&lt; _StateSeqT &gt;::_M_range_check()</a>, <a class="el" href="a01266_source.html#l02220">std::operator==()</a>, and <a class="el" href="a01266_source.html#l01282">std::deque&lt; _StateSeqT &gt;::resize()</a>.</p>

</div>
</div>
<a class="anchor" id="a453ac8930c84ded5680e0ba80cd23063"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00425.html">std::deque</a>&lt; _Tp, _Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00425.html">deque</a>&lt; _Tp, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps data with another deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A deque of the same element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>This exchanges the elements between two deques in constant time. (Four pointers, so it should be quite fast.) Note that the global std::swap() function is specialized such that std::swap(d1,d2) will feed to this function. </p>

<p>Definition at line <a class="el" href="a01266_source.html#l01783">1783</a> of file <a class="el" href="a01266_source.html">stl_deque.h</a>.</p>

<p>Referenced by <a class="el" href="a01266_source.html#l02274">std::swap()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a01266_source.html">stl_deque.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a01379.html">std</a></li><li class="navelem"><a class="el" href="a00425.html">deque</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>

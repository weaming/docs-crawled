<html lang="en">
<head>
<title>Calling Conventions - GNAT User's Guide for Native Platforms</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="GNAT User's Guide for Native Platforms">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Mixed-Language-Programming.html#Mixed-Language-Programming" title="Mixed Language Programming">
<link rel="prev" href="Interfacing-to-C.html#Interfacing-to-C" title="Interfacing to C">
<link rel="next" href="Building-Mixed-Ada-and-C_002b_002b-Programs.html#Building-Mixed-Ada-and-C_002b_002b-Programs" title="Building Mixed Ada and C++ Programs">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--

     GNAT User's Guide for Native Platforms , March 24, 2015

     AdaCore

     Copyright (C) 2008-2015, Free Software Foundation
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Calling-Conventions"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Building-Mixed-Ada-and-C_002b_002b-Programs.html#Building-Mixed-Ada-and-C_002b_002b-Programs">Building Mixed Ada and C++ Programs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Interfacing-to-C.html#Interfacing-to-C">Interfacing to C</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Mixed-Language-Programming.html#Mixed-Language-Programming">Mixed Language Programming</a>
<hr>
</div>

<p><a name="gnat_005fugn_002fthe_005fgnat_005fcompilation_005fmodel-calling_002dconventions"></a><a name="bb"></a><a name="gnat_005fugn_002fthe_005fgnat_005fcompilation_005fmodel-id63"></a><a name="bc"></a>

<h4 class="subsection">3.11.2 Calling Conventions</h4>

<p><a name="index-Foreign-Languages-118"></a>
<a name="index-Calling-Conventions-119"></a>
GNAT follows standard calling sequence conventions and will thus interface
to any other language that also follows these conventions. The following
Convention identifiers are recognized by GNAT:

<p><a name="index-Interfacing-to-Ada-120"></a>
<a name="index-Other-Ada-compilers-121"></a>
<a name="index-Convention-Ada-122"></a>

     <dl>
<dt>`Ada'<dd>
This indicates that the standard Ada calling sequence will be
used and all Ada data items may be passed without any limitations in the
case where GNAT is used to generate both the caller and callee. It is also
possible to mix GNAT generated code and code generated by another Ada
compiler. In this case, the data types should be restricted to simple
cases, including primitive types. Whether complex data types can be passed
depends on the situation. Probably it is safe to pass simple arrays, such
as arrays of integers or floats. Records may or may not work, depending
on whether both compilers lay them out identically. Complex structures
involving variant records, access parameters, tasks, or protected types,
are unlikely to be able to be passed.

     <p>Note that in the case of GNAT running
on a platform that supports HP Ada 83, a higher degree of compatibility
can be guaranteed, and in particular records are laid out in an identical
manner in the two compilers. Note also that if output from two different
compilers is mixed, the program is responsible for dealing with elaboration
issues. Probably the safest approach is to write the main program in the
version of Ada other than GNAT, so that it takes care of its own elaboration
requirements, and then call the GNAT-generated adainit procedure to ensure
elaboration of the GNAT components. Consult the documentation of the other
Ada compiler for further details on elaboration.

     <p>However, it is not possible to mix the tasking run time of GNAT and
HP Ada 83, All the tasking operations must either be entirely within
GNAT compiled sections of the program, or entirely within HP Ada 83
compiled sections of the program. 
</dl>

<p><a name="index-Interfacing-to-Assembly-123"></a>
<a name="index-Convention-Assembler-124"></a>

     <dl>
<dt>`Assembler'<dd>
Specifies assembler as the convention. In practice this has the
same effect as convention Ada (but is not equivalent in the sense of being
considered the same convention). 
</dl>

<p><a name="index-Convention-Asm-125"></a>
<a name="index-Asm-126"></a>

     <dl>
<dt>`Asm'<dd>
Equivalent to Assembler.

     <p><a name="index-Interfacing-to-COBOL-127"></a>
<a name="index-Convention-COBOL-128"></a></dl>

<p><a name="index-COBOL-129"></a>

     <dl>
<dt>`COBOL'<dd>
Data will be passed according to the conventions described
in section B.4 of the Ada Reference Manual. 
</dl>

<p><a name="index-C-130"></a>
<a name="index-Interfacing-to-C-131"></a>
<a name="index-Convention-C-132"></a>

     <dl>
<dt>`C'<dd>
Data will be passed according to the conventions described
in section B.3 of the Ada Reference Manual.

     <p>A note on interfacing to a C 'varargs' function:

     <blockquote>

     <p><a name="index-C-varargs-function-133"></a>
<a name="index-Interfacing-to-C-varargs-function-134"></a>
<a name="index-varargs-function-interfaces-135"></a>
In C, <cite>varargs</cite> allows a function to take a variable number of
arguments. There is no direct equivalent in this to Ada. One
approach that can be used is to create a C wrapper for each
different profile and then interface to this C wrapper. For
example, to print an <cite>int</cite> value using <cite>printf</cite>,
create a C function <cite>printfi</cite> that takes two arguments, a
pointer to a string and an int, and calls <cite>printf</cite>. 
Then in the Ada program, use pragma <cite>Import</cite> to
interface to <cite>printfi</cite>.

     <p>It may work on some platforms to directly interface to
a <cite>varargs</cite> function by providing a specific Ada profile
for a particular call. However, this does not work on
all platforms, since there is no guarantee that the
calling sequence for a two argument normal C function
is the same as for calling a <cite>varargs</cite> C function with
the same two arguments. 
</blockquote>
     </dl>

<p><a name="index-Convention-Default-136"></a>
<a name="index-Default-137"></a>

     <dl>
<dt>`Default'<dd>
Equivalent to C. 
</dl>

<p><a name="index-Convention-External-138"></a>
<a name="index-External-139"></a>

     <dl>
<dt>`External'<dd>
Equivalent to C. 
</dl>

<p><a name="index-C_002b_002b-140"></a>
<a name="index-Interfacing-to-C_002b_002b-141"></a>
<a name="index-Convention-C_002b_002b-142"></a>

     <dl>
<dt>`C_Plus_Plus (or CPP)'<dd>
This stands for C++. For most purposes this is identical to C. 
See the separate description of the specialized GNAT pragmas relating to
C++ interfacing for further details. 
</dl>

<p><a name="index-Fortran-143"></a>
<a name="index-Interfacing-to-Fortran-144"></a>
<a name="index-Convention-Fortran-145"></a>

     <dl>
<dt>`Fortran'<dd>
Data will be passed according to the conventions described
in section B.5 of the Ada Reference Manual.

     <br><dt>`Intrinsic'<dd>
This applies to an intrinsic operation, as defined in the Ada
Reference Manual. If a pragma Import (Intrinsic) applies to a subprogram,
this means that the body of the subprogram is provided by the compiler itself,
usually by means of an efficient code sequence, and that the user does not
supply an explicit body for it. In an application program, the pragma may
be applied to the following sets of names:

          <ul>
<li>Rotate_Left, Rotate_Right, Shift_Left, Shift_Right, Shift_Right_Arithmetic. 
The corresponding subprogram declaration must have
two formal parameters. The
first one must be a signed integer type or a modular type with a binary
modulus, and the second parameter must be of type Natural. 
The return type must be the same as the type of the first argument. The size
of this type can only be 8, 16, 32, or 64.

          <li>Binary arithmetic operators: '+', '-', '*', '/'. 
The corresponding operator declaration must have parameters and result type
that have the same root numeric type (for example, all three are long_float
types). This simplifies the definition of operations that use type checking
to perform dimensional checks:
</ul>

     <!-- code-block: ada -->
     <!-- type Distance is new Long_Float; -->
     <!-- type Time     is new Long_Float; -->
     <!-- type Velocity is new Long_Float; -->
     <!-- function "/" (D : Distance; T : Time) -->
     <!-- return Velocity; -->
     <!-- pragma Import (Intrinsic, "/"); -->
     <!-- This common idiom is often programmed with a generic definition and an -->
     <!-- explicit body. The pragma makes it simpler to introduce such declarations. -->
     <!-- It incurs no overhead in compilation time or code size, because it is -->
     <!-- implemented as a single machine instruction. -->
          <ul>
<li>General subprogram entities. This is used  to bind an Ada subprogram
declaration to
a compiler builtin by name with back-ends where such interfaces are
available. A typical example is the set of <cite>__builtin</cite> functions
exposed by the GCC back-end, as in the following example:

          <pre class="example">              function builtin_sqrt (F : Float) return Float;
              pragma Import (Intrinsic, builtin_sqrt, "__builtin_sqrtf");
</pre>
          <p>Most of the GCC builtins are accessible this way, and as for other
import conventions (e.g. C), it is the user's responsibility to ensure
that the Ada subprogram profile matches the underlying builtin
expectations. 
</ul>
     </dl>

<p><a name="index-Stdcall-146"></a>
<a name="index-Convention-Stdcall-147"></a>

     <dl>
<dt>`Stdcall'<dd>
This is relevant only to Windows XP/2000/NT implementations of GNAT,
and specifies that the <cite>Stdcall</cite> calling sequence will be used,
as defined by the NT API. Nevertheless, to ease building
cross-platform bindings this convention will be handled as a <cite>C</cite> calling
convention on non-Windows platforms. 
</dl>

<p><a name="index-DLL-148"></a>
<a name="index-Convention-DLL-149"></a>

     <dl>
<dt>`DLL'<dd>
This is equivalent to <cite>Stdcall</cite>. 
</dl>

<p><a name="index-Win32-150"></a>
<a name="index-Convention-Win32-151"></a>

     <dl>
<dt>`Win32'<dd>
This is equivalent to <cite>Stdcall</cite>. 
</dl>

<p><a name="index-Stubbed-152"></a>
<a name="index-Convention-Stubbed-153"></a>

     <dl>
<dt>`Stubbed'<dd>
This is a special convention that indicates that the compiler
should provide a stub body that raises <cite>Program_Error</cite>. 
</dl>

<p>GNAT additionally provides a useful pragma <cite>Convention_Identifier</cite>
that can be used to parameterize conventions and allow additional synonyms
to be specified. For example if you have legacy code in which the convention
identifier Fortran77 was used for Fortran, you can use the configuration
pragma:

<pre class="example">    pragma Convention_Identifier (Fortran77, Fortran);
</pre>
<p>And from now on the identifier Fortran77 may be used as a convention
identifier (for example in an <cite>Import</cite> pragma) with the same
meaning as Fortran.

</body></html>


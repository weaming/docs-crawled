<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API &mdash; Jinja2 2.8 documentation</title>
    
    <link rel="stylesheet" href="_static/jinja.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Jinja2 2.8 documentation" href="index.html" />
    <link rel="next" title="Sandbox" href="sandbox.html" />
    <link rel="prev" title="Introduction" href="intro.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="sandbox.html" title="Sandbox"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="intro.html" title="Introduction"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Jinja2 2.8 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-jinja2">
<span id="api"></span><h1>API<a class="headerlink" href="#module-jinja2" title="Permalink to this headline">¶</a></h1>
<p>This document describes the API to Jinja2 and not the template language.  It
will be most useful as reference to those implementing the template interface
to the application and not those who are creating Jinja2 templates.</p>
<div class="section" id="basics">
<h2>Basics<a class="headerlink" href="#basics" title="Permalink to this headline">¶</a></h2>
<p>Jinja2 uses a central object called the template <a class="reference internal" href="#jinja2.Environment" title="jinja2.Environment"><code class="xref py py-class docutils literal"><span class="pre">Environment</span></code></a>.
Instances of this class are used to store the configuration and global objects,
and are used to load templates from the file system or other locations.
Even if you are creating templates from strings by using the constructor of
<a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code class="xref py py-class docutils literal"><span class="pre">Template</span></code></a> class, an environment is created automatically for you,
albeit a shared one.</p>
<p>Most applications will create one <a class="reference internal" href="#jinja2.Environment" title="jinja2.Environment"><code class="xref py py-class docutils literal"><span class="pre">Environment</span></code></a> object on application
initialization and use that to load templates.  In some cases it&#8217;s however
useful to have multiple environments side by side, if different configurations
are in use.</p>
<p>The simplest way to configure Jinja2 to load templates for your application
looks roughly like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">jinja2</span> <span class="kn">import</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">PackageLoader</span>
<span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">(</span><span class="n">loader</span><span class="o">=</span><span class="n">PackageLoader</span><span class="p">(</span><span class="s">&#39;yourapplication&#39;</span><span class="p">,</span> <span class="s">&#39;templates&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>This will create a template environment with the default settings and a
loader that looks up the templates in the <cite>templates</cite> folder inside the
<cite>yourapplication</cite> python package.  Different loaders are available
and you can also write your own if you want to load templates from a
database or other resources.</p>
<p>To load a template from this environment you just have to call the
<code class="xref py py-meth docutils literal"><span class="pre">get_template()</span></code> method which then returns the loaded <a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code class="xref py py-class docutils literal"><span class="pre">Template</span></code></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">template</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">get_template</span><span class="p">(</span><span class="s">&#39;mytemplate.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To render it with some variables, just call the <code class="xref py py-meth docutils literal"><span class="pre">render()</span></code> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="n">template</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">the</span><span class="o">=</span><span class="s">&#39;variables&#39;</span><span class="p">,</span> <span class="n">go</span><span class="o">=</span><span class="s">&#39;here&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Using a template loader rather than passing strings to <a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code class="xref py py-class docutils literal"><span class="pre">Template</span></code></a>
or <a class="reference internal" href="#jinja2.Environment.from_string" title="jinja2.Environment.from_string"><code class="xref py py-meth docutils literal"><span class="pre">Environment.from_string()</span></code></a> has multiple advantages.  Besides being
a lot easier to use it also enables template inheritance.</p>
</div>
<div class="section" id="unicode">
<h2>Unicode<a class="headerlink" href="#unicode" title="Permalink to this headline">¶</a></h2>
<p>Jinja2 is using Unicode internally which means that you have to pass Unicode
objects to the render function or bytestrings that only consist of ASCII
characters.  Additionally newlines are normalized to one end of line
sequence which is per default UNIX style (<code class="docutils literal"><span class="pre">\n</span></code>).</p>
<p>Python 2.x supports two ways of representing string objects.  One is the
<cite>str</cite> type and the other is the <cite>unicode</cite> type, both of which extend a type
called <cite>basestring</cite>.  Unfortunately the default is <cite>str</cite> which should not
be used to store text based information unless only ASCII characters are
used.  With Python 2.6 it is possible to make <cite>unicode</cite> the default on a per
module level and with Python 3 it will be the default.</p>
<p>To explicitly use a Unicode string you have to prefix the string literal
with a <cite>u</cite>: <code class="docutils literal"><span class="pre">u'Hänsel</span> <span class="pre">und</span> <span class="pre">Gretel</span> <span class="pre">sagen</span> <span class="pre">Hallo'</span></code>.  That way Python will
store the string as Unicode by decoding the string with the character
encoding from the current Python module.  If no encoding is specified this
defaults to &#8216;ASCII&#8217; which means that you can&#8217;t use any non ASCII identifier.</p>
<p>To set a better module encoding add the following comment to the first or
second line of the Python module using the Unicode literal:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># -*- coding: utf-8 -*-</span>
</pre></div>
</div>
<p>We recommend utf-8 as Encoding for Python modules and templates as it&#8217;s
possible to represent every Unicode character in utf-8 and because it&#8217;s
backwards compatible to ASCII.  For Jinja2 the default encoding of templates
is assumed to be utf-8.</p>
<p>It is not possible to use Jinja2 to process non-Unicode data.  The reason
for this is that Jinja2 uses Unicode already on the language level.  For
example Jinja2 treats the non-breaking space as valid whitespace inside
expressions which requires knowledge of the encoding or operating on an
Unicode string.</p>
<p>For more details about Unicode in Python have a look at the excellent
<a class="reference external" href="http://docs.python.org/dev/howto/unicode.html">Unicode documentation</a>.</p>
<p>Another important thing is how Jinja2 is handling string literals in
templates.  A naive implementation would be using Unicode strings for
all string literals but it turned out in the past that this is problematic
as some libraries are typechecking against <cite>str</cite> explicitly.  For example
<cite>datetime.strftime</cite> does not accept Unicode arguments.  To not break it
completely Jinja2 is returning <cite>str</cite> for strings that fit into ASCII and
for everything else <cite>unicode</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s">u&quot;{</span><span class="si">% s</span><span class="s">et a, b = &#39;foo&#39;, &#39;föö&#39; %}&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">module</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">a</span>
<span class="go">&#39;foo&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">b</span>
<span class="go">u&#39;f\xf6\xf6&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="high-level-api">
<h2>High Level API<a class="headerlink" href="#high-level-api" title="Permalink to this headline">¶</a></h2>
<p>The high-level API is the API you will use in the application to load and
render Jinja2 templates.  The <a class="reference internal" href="#low-level-api"><span>Low Level API</span></a> on the other side is only
useful if you want to dig deeper into Jinja2 or <a class="reference internal" href="extensions.html#jinja-extensions"><span>develop extensions</span></a>.</p>
<dl class="class">
<dt id="jinja2.Environment">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">Environment</code><span class="sig-paren">(</span><span class="optional">[</span><em>options</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Environment" title="Permalink to this definition">¶</a></dt>
<dd><p>The core component of Jinja is the <cite>Environment</cite>.  It contains
important shared variables like configuration, filters, tests,
globals and others.  Instances of this class may be modified if
they are not shared and if no template was loaded so far.
Modifications on environments after the first template was loaded
will lead to surprising effects and undefined behavior.</p>
<p>Here are the possible initialization parameters:</p>
<blockquote>
<div><dl class="docutils">
<dt><cite>block_start_string</cite></dt>
<dd>The string marking the beginning of a block.  Defaults to <code class="docutils literal"><span class="pre">'{%'</span></code>.</dd>
<dt><cite>block_end_string</cite></dt>
<dd>The string marking the end of a block.  Defaults to <code class="docutils literal"><span class="pre">'%}'</span></code>.</dd>
<dt><cite>variable_start_string</cite></dt>
<dd>The string marking the beginning of a print statement.
Defaults to <code class="docutils literal"><span class="pre">'{{'</span></code>.</dd>
<dt><cite>variable_end_string</cite></dt>
<dd>The string marking the end of a print statement.  Defaults to
<code class="docutils literal"><span class="pre">'}}'</span></code>.</dd>
<dt><cite>comment_start_string</cite></dt>
<dd>The string marking the beginning of a comment.  Defaults to <code class="docutils literal"><span class="pre">'{#'</span></code>.</dd>
<dt><cite>comment_end_string</cite></dt>
<dd>The string marking the end of a comment.  Defaults to <code class="docutils literal"><span class="pre">'#}'</span></code>.</dd>
<dt><cite>line_statement_prefix</cite></dt>
<dd>If given and a string, this will be used as prefix for line based
statements.  See also <a class="reference internal" href="templates.html#line-statements"><span>Line Statements</span></a>.</dd>
<dt><cite>line_comment_prefix</cite></dt>
<dd><p class="first">If given and a string, this will be used as prefix for line based
comments.  See also <a class="reference internal" href="templates.html#line-statements"><span>Line Statements</span></a>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 2.2.</span></p>
</div>
</dd>
<dt><cite>trim_blocks</cite></dt>
<dd>If this is set to <code class="docutils literal"><span class="pre">True</span></code> the first newline after a block is
removed (block, not variable tag!).  Defaults to <cite>False</cite>.</dd>
<dt><cite>lstrip_blocks</cite></dt>
<dd>If this is set to <code class="docutils literal"><span class="pre">True</span></code> leading spaces and tabs are stripped
from the start of a line to a block.  Defaults to <cite>False</cite>.</dd>
<dt><cite>newline_sequence</cite></dt>
<dd>The sequence that starts a newline.  Must be one of <code class="docutils literal"><span class="pre">'\r'</span></code>,
<code class="docutils literal"><span class="pre">'\n'</span></code> or <code class="docutils literal"><span class="pre">'\r\n'</span></code>.  The default is <code class="docutils literal"><span class="pre">'\n'</span></code> which is a
useful default for Linux and OS X systems as well as web
applications.</dd>
<dt><cite>keep_trailing_newline</cite></dt>
<dd><p class="first">Preserve the trailing newline when rendering templates.
The default is <code class="docutils literal"><span class="pre">False</span></code>, which causes a single newline,
if present, to be stripped from the end of the template.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 2.7.</span></p>
</div>
</dd>
<dt><cite>extensions</cite></dt>
<dd>List of Jinja extensions to use.  This can either be import paths
as strings or extension classes.  For more information have a
look at <a class="reference internal" href="extensions.html#jinja-extensions"><span>the extensions documentation</span></a>.</dd>
<dt><cite>optimized</cite></dt>
<dd>should the optimizer be enabled?  Default is <cite>True</cite>.</dd>
<dt><cite>undefined</cite></dt>
<dd><a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code class="xref py py-class docutils literal"><span class="pre">Undefined</span></code></a> or a subclass of it that is used to represent
undefined values in the template.</dd>
<dt><cite>finalize</cite></dt>
<dd>A callable that can be used to process the result of a variable
expression before it is output.  For example one can convert
<cite>None</cite> implicitly into an empty string here.</dd>
<dt><cite>autoescape</cite></dt>
<dd><p class="first">If set to true the XML/HTML autoescaping feature is enabled by
default.  For more details about autoescaping see
<code class="xref py py-class docutils literal"><span class="pre">Markup</span></code>.  As of Jinja 2.4 this can also
be a callable that is passed the template name and has to
return <cite>True</cite> or <cite>False</cite> depending on autoescape should be
enabled by default.</p>
<div class="last versionchanged">
<p><span class="versionmodified">Changed in version 2.4: </span><cite>autoescape</cite> can now be a function</p>
</div>
</dd>
<dt><cite>loader</cite></dt>
<dd>The template loader for this environment.</dd>
<dt><cite>cache_size</cite></dt>
<dd><p class="first">The size of the cache.  Per default this is <code class="docutils literal"><span class="pre">400</span></code> which means
that if more than 400 templates are loaded the loader will clean
out the least recently used template.  If the cache size is set to
<code class="docutils literal"><span class="pre">0</span></code> templates are recompiled all the time, if the cache size is
<code class="docutils literal"><span class="pre">-1</span></code> the cache will not be cleaned.</p>
<div class="last versionchanged">
<p><span class="versionmodified">Changed in version 2.8: </span>The cache size was increased to 400 from a low 50.</p>
</div>
</dd>
<dt><cite>auto_reload</cite></dt>
<dd>Some loaders load templates from locations where the template
sources may change (ie: file system or database).  If
<cite>auto_reload</cite> is set to <cite>True</cite> (default) every time a template is
requested the loader checks if the source changed and if yes, it
will reload the template.  For higher performance it&#8217;s possible to
disable that.</dd>
<dt><cite>bytecode_cache</cite></dt>
<dd><p class="first">If set to a bytecode cache object, this object will provide a
cache for the internal Jinja bytecode so that templates don&#8217;t
have to be parsed if they were not changed.</p>
<p class="last">See <a class="reference internal" href="#bytecode-cache"><span>Bytecode Cache</span></a> for more information.</p>
</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="jinja2.Environment.shared">
<code class="descname">shared</code><a class="headerlink" href="#jinja2.Environment.shared" title="Permalink to this definition">¶</a></dt>
<dd><p>If a template was created by using the <a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code class="xref py py-class docutils literal"><span class="pre">Template</span></code></a> constructor
an environment is created automatically.  These environments are
created as shared environments which means that multiple templates
may have the same anonymous environment.  For all shared environments
this attribute is <cite>True</cite>, else <cite>False</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Environment.sandboxed">
<code class="descname">sandboxed</code><a class="headerlink" href="#jinja2.Environment.sandboxed" title="Permalink to this definition">¶</a></dt>
<dd><p>If the environment is sandboxed this attribute is <cite>True</cite>.  For the
sandbox mode have a look at the documentation for the
<a class="reference internal" href="sandbox.html#jinja2.sandbox.SandboxedEnvironment" title="jinja2.sandbox.SandboxedEnvironment"><code class="xref py py-class docutils literal"><span class="pre">SandboxedEnvironment</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Environment.filters">
<code class="descname">filters</code><a class="headerlink" href="#jinja2.Environment.filters" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict of filters for this environment.  As long as no template was
loaded it&#8217;s safe to add new filters or remove old.  For custom filters
see <a class="reference internal" href="#writing-filters"><span>Custom Filters</span></a>.  For valid filter names have a look at
<a class="reference internal" href="#identifier-naming"><span>Notes on Identifiers</span></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Environment.tests">
<code class="descname">tests</code><a class="headerlink" href="#jinja2.Environment.tests" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict of test functions for this environment.  As long as no
template was loaded it&#8217;s safe to modify this dict.  For custom tests
see <a class="reference internal" href="#writing-tests"><span>Custom Tests</span></a>.  For valid test names have a look at
<a class="reference internal" href="#identifier-naming"><span>Notes on Identifiers</span></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Environment.globals">
<code class="descname">globals</code><a class="headerlink" href="#jinja2.Environment.globals" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict of global variables.  These variables are always available
in a template.  As long as no template was loaded it&#8217;s safe
to modify this dict.  For more details see <a class="reference internal" href="#global-namespace"><span>The Global Namespace</span></a>.
For valid object names have a look at <a class="reference internal" href="#identifier-naming"><span>Notes on Identifiers</span></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Environment.code_generator_class">
<code class="descname">code_generator_class</code><a class="headerlink" href="#jinja2.Environment.code_generator_class" title="Permalink to this definition">¶</a></dt>
<dd><p>The class used for code generation.  This should not be changed
in most cases, unless you need to modify the Python code a
template compiles to.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Environment.context_class">
<code class="descname">context_class</code><a class="headerlink" href="#jinja2.Environment.context_class" title="Permalink to this definition">¶</a></dt>
<dd><p>The context used for templates.  This should not be changed
in most cases, unless you need to modify internals of how
template variables are handled.  For details, see
<a class="reference internal" href="#jinja2.runtime.Context" title="jinja2.runtime.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.Environment.overlay">
<code class="descname">overlay</code><span class="sig-paren">(</span><span class="optional">[</span><em>options</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Environment.overlay" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new overlay environment that shares all the data with the
current environment except for cache and the overridden attributes.
Extensions cannot be removed for an overlayed environment.  An overlayed
environment automatically gets all the extensions of the environment it
is linked to plus optional extra extensions.</p>
<p>Creating overlays should happen after the initial environment was set
up completely.  Not all attributes are truly linked, some are just
copied over so modifications on the original environment may not shine
through.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.Environment.undefined">
<code class="descname">undefined</code><span class="sig-paren">(</span><span class="optional">[</span><em>hint</em>, <em>obj</em>, <em>name</em>, <em>exc</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Environment.undefined" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code class="xref py py-class docutils literal"><span class="pre">Undefined</span></code></a> object for <cite>name</cite>.  This is useful
for filters or functions that may return undefined objects for
some operations.  All parameters except of <cite>hint</cite> should be provided
as keyword parameters for better readability.  The <cite>hint</cite> is used as
error message for the exception if provided, otherwise the error
message will be generated from <cite>obj</cite> and <cite>name</cite> automatically.  The exception
provided as <cite>exc</cite> is raised if something with the generated undefined
object is done that the undefined object does not allow.  The default
exception is <a class="reference internal" href="#jinja2.UndefinedError" title="jinja2.UndefinedError"><code class="xref py py-exc docutils literal"><span class="pre">UndefinedError</span></code></a>.  If a <cite>hint</cite> is provided the
<cite>name</cite> may be omitted.</p>
<p>The most common way to create an undefined object is by providing
a name only:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">return</span> <span class="n">environment</span><span class="o">.</span><span class="n">undefined</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;some_name&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This means that the name <cite>some_name</cite> is not defined.  If the name
was from an attribute of an object it makes sense to tell the
undefined object the holder object to improve the error message:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&#39;attr&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">environment</span><span class="o">.</span><span class="n">undefined</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;attr&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>For a more complex example you can provide a hint.  For example
the <a class="reference internal" href="templates.html#first" title="first"><code class="xref py py-func docutils literal"><span class="pre">first()</span></code></a> filter creates an undefined object that way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">return</span> <span class="n">environment</span><span class="o">.</span><span class="n">undefined</span><span class="p">(</span><span class="s">&#39;no first item, sequence was empty&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If it the <cite>name</cite> or <cite>obj</cite> is known (for example because an attribute
was accessed) it should be passed to the undefined object, even if
a custom <cite>hint</cite> is provided.  This gives undefined objects the
possibility to enhance the error message.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.Environment.add_extension">
<code class="descname">add_extension</code><span class="sig-paren">(</span><em>extension</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Environment.add_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an extension after the environment was created.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.5.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="jinja2.Environment.compile_expression">
<code class="descname">compile_expression</code><span class="sig-paren">(</span><em>source</em>, <em>undefined_to_none=True</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Environment.compile_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>A handy helper method that returns a callable that accepts keyword
arguments that appear as variables in the expression.  If called it
returns the result of the expression.</p>
<p>This is useful if applications want to use the same rules as Jinja
in template &#8220;configuration files&#8221; or similar situations.</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">compile_expression</span><span class="p">(</span><span class="s">&#39;foo == 42&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="p">(</span><span class="n">foo</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="p">(</span><span class="n">foo</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Per default the return value is converted to <cite>None</cite> if the
expression returns an undefined value.  This can be changed
by setting <cite>undefined_to_none</cite> to <cite>False</cite>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">env</span><span class="o">.</span><span class="n">compile_expression</span><span class="p">(</span><span class="s">&#39;var&#39;</span><span class="p">)()</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">env</span><span class="o">.</span><span class="n">compile_expression</span><span class="p">(</span><span class="s">&#39;var&#39;</span><span class="p">,</span> <span class="n">undefined_to_none</span><span class="o">=</span><span class="bp">False</span><span class="p">)()</span>
<span class="go">Undefined</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.1.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="jinja2.Environment.compile_templates">
<code class="descname">compile_templates</code><span class="sig-paren">(</span><em>target</em>, <em>extensions=None</em>, <em>filter_func=None</em>, <em>zip='deflated'</em>, <em>log_function=None</em>, <em>ignore_errors=True</em>, <em>py_compile=False</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Environment.compile_templates" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all the templates the loader can find, compiles them
and stores them in <cite>target</cite>.  If <cite>zip</cite> is <cite>None</cite>, instead of in a
zipfile, the templates will be stored in a directory.
By default a deflate zip algorithm is used. To switch to
the stored algorithm, <cite>zip</cite> can be set to <code class="docutils literal"><span class="pre">'stored'</span></code>.</p>
<p><cite>extensions</cite> and <cite>filter_func</cite> are passed to <a class="reference internal" href="#jinja2.Environment.list_templates" title="jinja2.Environment.list_templates"><code class="xref py py-meth docutils literal"><span class="pre">list_templates()</span></code></a>.
Each template returned will be compiled to the target folder or
zipfile.</p>
<p>By default template compilation errors are ignored.  In case a
log function is provided, errors are logged.  If you want template
syntax errors to abort the compilation you can set <cite>ignore_errors</cite>
to <cite>False</cite> and you will get an exception on syntax errors.</p>
<p>If <cite>py_compile</cite> is set to <cite>True</cite> .pyc files will be written to the
target instead of standard .py files.  This flag does not do anything
on pypy and Python 3 where pyc files are not picked up by itself and
don&#8217;t give much benefit.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.4.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="jinja2.Environment.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>**attributes</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Environment.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the items to the instance of the environment if they do not exist
yet.  This is used by <a class="reference internal" href="extensions.html#writing-extensions"><span>extensions</span></a> to register
callbacks and configuration values without breaking inheritance.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.Environment.from_string">
<code class="descname">from_string</code><span class="sig-paren">(</span><em>source</em>, <em>globals=None</em>, <em>template_class=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Environment.from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a template from a string.  This parses the source given and
returns a <a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code class="xref py py-class docutils literal"><span class="pre">Template</span></code></a> object.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.Environment.get_or_select_template">
<code class="descname">get_or_select_template</code><span class="sig-paren">(</span><em>template_name_or_list</em>, <em>parent=None</em>, <em>globals=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Environment.get_or_select_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Does a typecheck and dispatches to <a class="reference internal" href="#jinja2.Environment.select_template" title="jinja2.Environment.select_template"><code class="xref py py-meth docutils literal"><span class="pre">select_template()</span></code></a>
if an iterable of template names is given, otherwise to
<a class="reference internal" href="#jinja2.Environment.get_template" title="jinja2.Environment.get_template"><code class="xref py py-meth docutils literal"><span class="pre">get_template()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.3.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="jinja2.Environment.get_template">
<code class="descname">get_template</code><span class="sig-paren">(</span><em>name</em>, <em>parent=None</em>, <em>globals=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Environment.get_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a template from the loader.  If a loader is configured this
method ask the loader for the template and returns a <a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code class="xref py py-class docutils literal"><span class="pre">Template</span></code></a>.
If the <cite>parent</cite> parameter is not <cite>None</cite>, <a class="reference internal" href="#jinja2.Environment.join_path" title="jinja2.Environment.join_path"><code class="xref py py-meth docutils literal"><span class="pre">join_path()</span></code></a> is called
to get the real template name before loading.</p>
<p>The <cite>globals</cite> parameter can be used to provide template wide globals.
These variables are available in the context at render time.</p>
<p>If the template does not exist a <a class="reference internal" href="#jinja2.TemplateNotFound" title="jinja2.TemplateNotFound"><code class="xref py py-exc docutils literal"><span class="pre">TemplateNotFound</span></code></a> exception is
raised.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 2.4: </span>If <cite>name</cite> is a <a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code class="xref py py-class docutils literal"><span class="pre">Template</span></code></a> object it is returned from the
function unchanged.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="jinja2.Environment.join_path">
<code class="descname">join_path</code><span class="sig-paren">(</span><em>template</em>, <em>parent</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Environment.join_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Join a template with the parent.  By default all the lookups are
relative to the loader root so this method returns the <cite>template</cite>
parameter unchanged, but if the paths should be relative to the
parent template, this function can be used to calculate the real
template name.</p>
<p>Subclasses may override this method and implement template path
joining here.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.Environment.list_templates">
<code class="descname">list_templates</code><span class="sig-paren">(</span><em>extensions=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Environment.list_templates" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of templates for this environment.  This requires
that the loader supports the loader&#8217;s
<code class="xref py py-meth docutils literal"><span class="pre">list_templates()</span></code> method.</p>
<p>If there are other files in the template folder besides the
actual templates, the returned list can be filtered.  There are two
ways: either <cite>extensions</cite> is set to a list of file extensions for
templates, or a <cite>filter_func</cite> can be provided which is a callable that
is passed a template name and should return <cite>True</cite> if it should end up
in the result list.</p>
<p>If the loader does not support that, a <code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.4.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="jinja2.Environment.select_template">
<code class="descname">select_template</code><span class="sig-paren">(</span><em>names</em>, <em>parent=None</em>, <em>globals=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Environment.select_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Works like <a class="reference internal" href="#jinja2.Environment.get_template" title="jinja2.Environment.get_template"><code class="xref py py-meth docutils literal"><span class="pre">get_template()</span></code></a> but tries a number of templates
before it fails.  If it cannot find any of the templates, it will
raise a <a class="reference internal" href="#jinja2.TemplatesNotFound" title="jinja2.TemplatesNotFound"><code class="xref py py-exc docutils literal"><span class="pre">TemplatesNotFound</span></code></a> exception.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 2.4: </span>If <cite>names</cite> contains a <a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code class="xref py py-class docutils literal"><span class="pre">Template</span></code></a> object it is returned
from the function unchanged.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="jinja2.Template">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">Template</code><a class="headerlink" href="#jinja2.Template" title="Permalink to this definition">¶</a></dt>
<dd><p>The central template object.  This class represents a compiled template
and is used to evaluate it.</p>
<p>Normally the template object is generated from an <a class="reference internal" href="#jinja2.Environment" title="jinja2.Environment"><code class="xref py py-class docutils literal"><span class="pre">Environment</span></code></a> but
it also has a constructor that makes it possible to create a template
instance directly using the constructor.  It takes the same arguments as
the environment constructor but it&#8217;s not possible to specify a loader.</p>
<p>Every template object has a few methods and members that are guaranteed
to exist.  However it&#8217;s important that a template object should be
considered immutable.  Modifications on the object are not supported.</p>
<p>Template objects created from the constructor rather than an environment
do have an <cite>environment</cite> attribute that points to a temporary environment
that is probably shared with other templates created with the constructor
and compatible settings.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s">&#39;Hello {{ name }}!&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">template</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;John Doe&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s">u&#39;Hello John Doe!&#39;</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stream</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;John Doe&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span> <span class="o">==</span> <span class="s">u&#39;Hello John Doe!&#39;</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="jinja2.Template.globals">
<code class="descname">globals</code><a class="headerlink" href="#jinja2.Template.globals" title="Permalink to this definition">¶</a></dt>
<dd><p>The dict with the globals of that template.  It&#8217;s unsafe to modify
this dict as it may be shared with other templates or the environment
that loaded the template.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Template.name">
<code class="descname">name</code><a class="headerlink" href="#jinja2.Template.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The loading name of the template.  If the template was loaded from a
string this is <cite>None</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Template.filename">
<code class="descname">filename</code><a class="headerlink" href="#jinja2.Template.filename" title="Permalink to this definition">¶</a></dt>
<dd><p>The filename of the template on the file system if it was loaded from
there.  Otherwise this is <cite>None</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.Template.render">
<code class="descname">render</code><span class="sig-paren">(</span><span class="optional">[</span><em>context</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Template.render" title="Permalink to this definition">¶</a></dt>
<dd><p>This method accepts the same arguments as the <cite>dict</cite> constructor:
A dict, a dict subclass or some keyword arguments.  If no arguments
are given the context will be empty.  These two calls do the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">template</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">knights</span><span class="o">=</span><span class="s">&#39;that say nih&#39;</span><span class="p">)</span>
<span class="n">template</span><span class="o">.</span><span class="n">render</span><span class="p">({</span><span class="s">&#39;knights&#39;</span><span class="p">:</span> <span class="s">&#39;that say nih&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>This will return the rendered template as unicode string.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.Template.generate">
<code class="descname">generate</code><span class="sig-paren">(</span><span class="optional">[</span><em>context</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Template.generate" title="Permalink to this definition">¶</a></dt>
<dd><p>For very large templates it can be useful to not render the whole
template at once but evaluate each statement after another and yield
piece for piece.  This method basically does exactly that and returns
a generator that yields one item after another as unicode strings.</p>
<p>It accepts the same arguments as <a class="reference internal" href="#jinja2.Template.render" title="jinja2.Template.render"><code class="xref py py-meth docutils literal"><span class="pre">render()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.Template.stream">
<code class="descname">stream</code><span class="sig-paren">(</span><span class="optional">[</span><em>context</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Template.stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Works exactly like <a class="reference internal" href="#jinja2.Template.generate" title="jinja2.Template.generate"><code class="xref py py-meth docutils literal"><span class="pre">generate()</span></code></a> but returns a
<code class="xref py py-class docutils literal"><span class="pre">TemplateStream</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.Template.make_module">
<code class="descname">make_module</code><span class="sig-paren">(</span><em>vars=None</em>, <em>shared=False</em>, <em>locals=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Template.make_module" title="Permalink to this definition">¶</a></dt>
<dd><p>This method works like the <a class="reference internal" href="#jinja2.Template.module" title="jinja2.Template.module"><code class="xref py py-attr docutils literal"><span class="pre">module</span></code></a> attribute when called
without arguments but it will evaluate the template on every call
rather than caching it.  It&#8217;s also possible to provide
a dict which is then used as context.  The arguments are the same
as for the <a class="reference internal" href="#jinja2.Template.new_context" title="jinja2.Template.new_context"><code class="xref py py-meth docutils literal"><span class="pre">new_context()</span></code></a> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Template.module">
<code class="descname">module</code><a class="headerlink" href="#jinja2.Template.module" title="Permalink to this definition">¶</a></dt>
<dd><p>The template as module.  This is used for imports in the
template runtime but is also useful if one wants to access
exported template variables from the Python layer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s">&#39;{% macro foo() %}42{</span><span class="si">% e</span><span class="s">ndmacro %}23&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">module</span><span class="p">)</span>
<span class="go">&#39;23&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span> <span class="o">==</span> <span class="s">u&#39;42&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="jinja2.environment.TemplateStream">
<em class="property">class </em><code class="descclassname">jinja2.environment.</code><code class="descname">TemplateStream</code><a class="headerlink" href="#jinja2.environment.TemplateStream" title="Permalink to this definition">¶</a></dt>
<dd><p>A template stream works pretty much like an ordinary python generator
but it can buffer multiple items to reduce the number of total iterations.
Per default the output is unbuffered which means that for every unbuffered
instruction in the template one unicode string is yielded.</p>
<p>If buffering is enabled with a buffer size of 5, five items are combined
into a new unicode string.  This is mainly useful if you are streaming
big templates to a client via WSGI which flushes after each iteration.</p>
<dl class="method">
<dt id="jinja2.environment.TemplateStream.disable_buffering">
<code class="descname">disable_buffering</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.environment.TemplateStream.disable_buffering" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable the output buffering.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.environment.TemplateStream.dump">
<code class="descname">dump</code><span class="sig-paren">(</span><em>fp</em>, <em>encoding=None</em>, <em>errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.environment.TemplateStream.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump the complete stream into a file or file-like object.
Per default unicode strings are written, if you want to encode
before writing specify an <cite>encoding</cite>.</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Template</span><span class="p">(</span><span class="s">&#39;Hello {{ name }}!&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s">&#39;hello.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="jinja2.environment.TemplateStream.enable_buffering">
<code class="descname">enable_buffering</code><span class="sig-paren">(</span><em>size=5</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.environment.TemplateStream.enable_buffering" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable buffering.  Buffer <cite>size</cite> items before yielding them.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="autoescaping">
<h2>Autoescaping<a class="headerlink" href="#autoescaping" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.4.</span></p>
</div>
<p>As of Jinja 2.4 the preferred way to do autoescaping is to enable the
<a class="reference internal" href="extensions.html#autoescape-extension"><span>Autoescape Extension</span></a> and to configure a sensible default for
autoescaping.  This makes it possible to enable and disable autoescaping
on a per-template basis (HTML versus text for instance).</p>
<p>Here a recommended setup that enables autoescaping for templates ending
in <code class="docutils literal"><span class="pre">'.html'</span></code>, <code class="docutils literal"><span class="pre">'.htm'</span></code> and <code class="docutils literal"><span class="pre">'.xml'</span></code> and disabling it by default
for all other extensions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">guess_autoescape</span><span class="p">(</span><span class="n">template_name</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">template_name</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="s">&#39;.&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">template_name</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="n">ext</span> <span class="o">=</span> <span class="n">template_name</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;html&#39;</span><span class="p">,</span> <span class="s">&#39;htm&#39;</span><span class="p">,</span> <span class="s">&#39;xml&#39;</span><span class="p">)</span>

<span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">(</span><span class="n">autoescape</span><span class="o">=</span><span class="n">guess_autoescape</span><span class="p">,</span>
                  <span class="n">loader</span><span class="o">=</span><span class="n">PackageLoader</span><span class="p">(</span><span class="s">&#39;mypackage&#39;</span><span class="p">),</span>
                  <span class="n">extensions</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;jinja2.ext.autoescape&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>When implementing a guessing autoescape function, make sure you also
accept <cite>None</cite> as valid template name.  This will be passed when generating
templates from strings.</p>
<p>Inside the templates the behaviour can be temporarily changed by using
the <cite>autoescape</cite> block (see <a class="reference internal" href="templates.html#autoescape-overrides"><span>Autoescape Extension</span></a>).</p>
</div>
<div class="section" id="notes-on-identifiers">
<span id="identifier-naming"></span><h2>Notes on Identifiers<a class="headerlink" href="#notes-on-identifiers" title="Permalink to this headline">¶</a></h2>
<p>Jinja2 uses the regular Python 2.x naming rules.  Valid identifiers have to
match <code class="docutils literal"><span class="pre">[a-zA-Z_][a-zA-Z0-9_]*</span></code>.  As a matter of fact non ASCII characters
are currently not allowed.  This limitation will probably go away as soon as
unicode identifiers are fully specified for Python 3.</p>
<p>Filters and tests are looked up in separate namespaces and have slightly
modified identifier syntax.  Filters and tests may contain dots to group
filters and tests by topic.  For example it&#8217;s perfectly valid to add a
function into the filter dict and call it <cite>to.unicode</cite>.  The regular
expression for filter and test identifiers is
<code class="docutils literal"><span class="pre">[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)*`</span></code>.</p>
</div>
<div class="section" id="undefined-types">
<h2>Undefined Types<a class="headerlink" href="#undefined-types" title="Permalink to this headline">¶</a></h2>
<p>These classes can be used as undefined types.  The <a class="reference internal" href="#jinja2.Environment" title="jinja2.Environment"><code class="xref py py-class docutils literal"><span class="pre">Environment</span></code></a>
constructor takes an <cite>undefined</cite> parameter that can be one of those classes
or a custom subclass of <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code class="xref py py-class docutils literal"><span class="pre">Undefined</span></code></a>.  Whenever the template engine is
unable to look up a name or access an attribute one of those objects is
created and returned.  Some operations on undefined values are then allowed,
others fail.</p>
<p>The closest to regular Python behavior is the <cite>StrictUndefined</cite> which
disallows all operations beside testing if it&#8217;s an undefined object.</p>
<dl class="class">
<dt id="jinja2.Undefined">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">Undefined</code><a class="headerlink" href="#jinja2.Undefined" title="Permalink to this definition">¶</a></dt>
<dd><p>The default undefined type.  This undefined type can be printed and
iterated over, but every other access will raise an <code class="xref py py-exc docutils literal"><span class="pre">jinja2.exceptions.UndefinedError</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span> <span class="o">=</span> <span class="n">Undefined</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="go">&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="ow">not</span> <span class="n">foo</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span> <span class="o">+</span> <span class="mi">42</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">jinja2.exceptions.UndefinedError</span>: <span class="n">&#39;foo&#39; is undefined</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="jinja2.Undefined._undefined_hint">
<code class="descname">_undefined_hint</code><a class="headerlink" href="#jinja2.Undefined._undefined_hint" title="Permalink to this definition">¶</a></dt>
<dd><p>Either <cite>None</cite> or an unicode string with the error message for
the undefined object.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Undefined._undefined_obj">
<code class="descname">_undefined_obj</code><a class="headerlink" href="#jinja2.Undefined._undefined_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Either <cite>None</cite> or the owner object that caused the undefined object
to be created (for example because an attribute does not exist).</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Undefined._undefined_name">
<code class="descname">_undefined_name</code><a class="headerlink" href="#jinja2.Undefined._undefined_name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name for the undefined variable / attribute or just <cite>None</cite>
if no such information exists.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Undefined._undefined_exception">
<code class="descname">_undefined_exception</code><a class="headerlink" href="#jinja2.Undefined._undefined_exception" title="Permalink to this definition">¶</a></dt>
<dd><p>The exception that the undefined object wants to raise.  This
is usually one of <a class="reference internal" href="#jinja2.UndefinedError" title="jinja2.UndefinedError"><code class="xref py py-exc docutils literal"><span class="pre">UndefinedError</span></code></a> or <code class="xref py py-exc docutils literal"><span class="pre">SecurityError</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.Undefined._fail_with_undefined_error">
<code class="descname">_fail_with_undefined_error</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Undefined._fail_with_undefined_error" title="Permalink to this definition">¶</a></dt>
<dd><p>When called with any arguments this method raises
<a class="reference internal" href="#jinja2.Undefined._undefined_exception" title="jinja2.Undefined._undefined_exception"><code class="xref py py-attr docutils literal"><span class="pre">_undefined_exception</span></code></a> with an error message generated
from the undefined hints stored on the undefined object.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="jinja2.DebugUndefined">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">DebugUndefined</code><a class="headerlink" href="#jinja2.DebugUndefined" title="Permalink to this definition">¶</a></dt>
<dd><p>An undefined that returns the debug info when printed.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span> <span class="o">=</span> <span class="n">DebugUndefined</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="go">&#39;{{ foo }}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="ow">not</span> <span class="n">foo</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span> <span class="o">+</span> <span class="mi">42</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">jinja2.exceptions.UndefinedError</span>: <span class="n">&#39;foo&#39; is undefined</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="jinja2.StrictUndefined">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">StrictUndefined</code><a class="headerlink" href="#jinja2.StrictUndefined" title="Permalink to this definition">¶</a></dt>
<dd><p>An undefined that barks on print and iteration as well as boolean
tests and all kinds of comparisons.  In other words: you can do nothing
with it except checking if it&#8217;s defined using the <cite>defined</cite> test.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span> <span class="o">=</span> <span class="n">StrictUndefined</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">jinja2.exceptions.UndefinedError</span>: <span class="n">&#39;foo&#39; is undefined</span>
<span class="gp">&gt;&gt;&gt; </span><span class="ow">not</span> <span class="n">foo</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">jinja2.exceptions.UndefinedError</span>: <span class="n">&#39;foo&#39; is undefined</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span> <span class="o">+</span> <span class="mi">42</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">jinja2.exceptions.UndefinedError</span>: <span class="n">&#39;foo&#39; is undefined</span>
</pre></div>
</div>
</dd></dl>

<p>There is also a factory function that can decorate undefined objects to
implement logging on failures:</p>
<dl class="function">
<dt id="jinja2.make_logging_undefined">
<code class="descclassname">jinja2.</code><code class="descname">make_logging_undefined</code><span class="sig-paren">(</span><em>logger=None</em>, <em>base=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.make_logging_undefined" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a logger object this returns a new undefined class that will
log certain failures.  It will log iterations and printing.  If no
logger is given a default logger is created.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">LoggingUndefined</span> <span class="o">=</span> <span class="n">make_logging_undefined</span><span class="p">(</span>
    <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
    <span class="n">base</span><span class="o">=</span><span class="n">Undefined</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.8.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>logger</strong> &#8211; the logger to use.  If not provided, a default logger
is created.</li>
<li><strong>base</strong> &#8211; the base class to add logging functionality to.  This
defaults to <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code class="xref py py-class docutils literal"><span class="pre">Undefined</span></code></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Undefined objects are created by calling <a class="reference internal" href="templates.html#undefined" title="undefined"><code class="xref py py-attr docutils literal"><span class="pre">undefined</span></code></a>.</p>
<div class="admonition-implementation admonition">
<p class="first admonition-title">Implementation</p>
<p><a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code class="xref py py-class docutils literal"><span class="pre">Undefined</span></code></a> objects are implemented by overriding the special
<cite>__underscore__</cite> methods.  For example the default <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code class="xref py py-class docutils literal"><span class="pre">Undefined</span></code></a>
class implements <cite>__unicode__</cite> in a way that it returns an empty
string, however <cite>__int__</cite> and others still fail with an exception.  To
allow conversion to int by returning <code class="docutils literal"><span class="pre">0</span></code> you can implement your own:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NullUndefined</span><span class="p">(</span><span class="n">Undefined</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.0</span>
</pre></div>
</div>
<p>To disallow a method, just override it and raise
<a class="reference internal" href="#jinja2.Undefined._undefined_exception" title="jinja2.Undefined._undefined_exception"><code class="xref py py-attr docutils literal"><span class="pre">_undefined_exception</span></code></a>.  Because this is a very common
idom in undefined objects there is the helper method
<a class="reference internal" href="#jinja2.Undefined._fail_with_undefined_error" title="jinja2.Undefined._fail_with_undefined_error"><code class="xref py py-meth docutils literal"><span class="pre">_fail_with_undefined_error()</span></code></a> that does the error raising
automatically.  Here a class that works like the regular <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code class="xref py py-class docutils literal"><span class="pre">Undefined</span></code></a>
but chokes on iteration:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NonIterableUndefined</span><span class="p">(</span><span class="n">Undefined</span><span class="p">):</span>
    <span class="n">__iter__</span> <span class="o">=</span> <span class="n">Undefined</span><span class="o">.</span><span class="n">_fail_with_undefined_error</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-context">
<h2>The Context<a class="headerlink" href="#the-context" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="jinja2.runtime.Context">
<em class="property">class </em><code class="descclassname">jinja2.runtime.</code><code class="descname">Context</code><a class="headerlink" href="#jinja2.runtime.Context" title="Permalink to this definition">¶</a></dt>
<dd><p>The template context holds the variables of a template.  It stores the
values passed to the template and also the names the template exports.
Creating instances is neither supported nor useful as it&#8217;s created
automatically at various stages of the template evaluation and should not
be created by hand.</p>
<p>The context is immutable.  Modifications on <a class="reference internal" href="#jinja2.Context.parent" title="jinja2.Context.parent"><code class="xref py py-attr docutils literal"><span class="pre">parent</span></code></a> <strong>must not</strong>
happen and modifications on <a class="reference internal" href="#jinja2.Context.vars" title="jinja2.Context.vars"><code class="xref py py-attr docutils literal"><span class="pre">vars</span></code></a> are allowed from generated
template code only.  Template filters and global functions marked as
<a class="reference internal" href="#jinja2.contextfunction" title="jinja2.contextfunction"><code class="xref py py-func docutils literal"><span class="pre">contextfunction()</span></code></a>s get the active context passed as first argument
and are allowed to access the context read-only.</p>
<p>The template context supports read only dict operations (<cite>get</cite>,
<cite>keys</cite>, <cite>values</cite>, <cite>items</cite>, <cite>iterkeys</cite>, <cite>itervalues</cite>, <cite>iteritems</cite>,
<cite>__getitem__</cite>, <cite>__contains__</cite>).  Additionally there is a <code class="xref py py-meth docutils literal"><span class="pre">resolve()</span></code>
method that doesn&#8217;t fail with a <cite>KeyError</cite> but returns an
<a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code class="xref py py-class docutils literal"><span class="pre">Undefined</span></code></a> object for missing variables.</p>
<dl class="attribute">
<dt id="jinja2.Context.parent">
<code class="descname">parent</code><a class="headerlink" href="#jinja2.Context.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict of read only, global variables the template looks up.  These
can either come from another <code class="xref py py-class docutils literal"><span class="pre">Context</span></code>, from the
<a class="reference internal" href="#jinja2.Environment.globals" title="jinja2.Environment.globals"><code class="xref py py-attr docutils literal"><span class="pre">Environment.globals</span></code></a> or <a class="reference internal" href="#jinja2.Template.globals" title="jinja2.Template.globals"><code class="xref py py-attr docutils literal"><span class="pre">Template.globals</span></code></a> or points
to a dict created by combining the globals with the variables
passed to the render function.  It must not be altered.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Context.vars">
<code class="descname">vars</code><a class="headerlink" href="#jinja2.Context.vars" title="Permalink to this definition">¶</a></dt>
<dd><p>The template local variables.  This list contains environment and
context functions from the <a class="reference internal" href="#jinja2.Context.parent" title="jinja2.Context.parent"><code class="xref py py-attr docutils literal"><span class="pre">parent</span></code></a> scope as well as local
modifications and exported variables from the template.  The template
will modify this dict during template evaluation but filters and
context functions are not allowed to modify it.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Context.environment">
<code class="descname">environment</code><a class="headerlink" href="#jinja2.Context.environment" title="Permalink to this definition">¶</a></dt>
<dd><p>The environment that loaded the template.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Context.exported_vars">
<code class="descname">exported_vars</code><a class="headerlink" href="#jinja2.Context.exported_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>This set contains all the names the template exports.  The values for
the names are in the <a class="reference internal" href="#jinja2.Context.vars" title="jinja2.Context.vars"><code class="xref py py-attr docutils literal"><span class="pre">vars</span></code></a> dict.  In order to get a copy of the
exported variables as dict, <code class="xref py py-meth docutils literal"><span class="pre">get_exported()</span></code> can be used.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Context.name">
<code class="descname">name</code><a class="headerlink" href="#jinja2.Context.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The load name of the template owning this context.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Context.blocks">
<code class="descname">blocks</code><a class="headerlink" href="#jinja2.Context.blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict with the current mapping of blocks in the template.  The keys
in this dict are the names of the blocks, and the values a list of
blocks registered.  The last item in each list is the current active
block (latest in the inheritance chain).</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Context.eval_ctx">
<code class="descname">eval_ctx</code><a class="headerlink" href="#jinja2.Context.eval_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>The current <a class="reference internal" href="#eval-context"><span>Evaluation Context</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.runtime.Context.call">
<code class="descname">call</code><span class="sig-paren">(</span><em>callable</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.runtime.Context.call" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the callable with the arguments and keyword arguments
provided but inject the active context or environment as first
argument if the callable is a <a class="reference internal" href="#jinja2.contextfunction" title="jinja2.contextfunction"><code class="xref py py-func docutils literal"><span class="pre">contextfunction()</span></code></a> or
<a class="reference internal" href="#jinja2.environmentfunction" title="jinja2.environmentfunction"><code class="xref py py-func docutils literal"><span class="pre">environmentfunction()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.runtime.Context.get_all">
<code class="descname">get_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.runtime.Context.get_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the complete context as dict including the
exported variables.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.runtime.Context.get_exported">
<code class="descname">get_exported</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.runtime.Context.get_exported" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a new dict with the exported variables.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.runtime.Context.resolve">
<code class="descname">resolve</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.runtime.Context.resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Looks up a variable like <cite>__getitem__</cite> or <cite>get</cite> but returns an
<a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code class="xref py py-class docutils literal"><span class="pre">Undefined</span></code></a> object with the name of the name looked up.</p>
</dd></dl>

</dd></dl>

<div class="admonition-implementation admonition">
<p class="first admonition-title">Implementation</p>
<p>Context is immutable for the same reason Python&#8217;s frame locals are
immutable inside functions.  Both Jinja2 and Python are not using the
context / frame locals as data storage for variables but only as primary
data source.</p>
<p class="last">When a template accesses a variable the template does not define, Jinja2
looks up the variable in the context, after that the variable is treated
as if it was defined in the template.</p>
</div>
</div>
<div class="section" id="loaders">
<span id="id1"></span><h2>Loaders<a class="headerlink" href="#loaders" title="Permalink to this headline">¶</a></h2>
<p>Loaders are responsible for loading templates from a resource such as the
file system.  The environment will keep the compiled modules in memory like
Python&#8217;s <cite>sys.modules</cite>.  Unlike <cite>sys.modules</cite> however this cache is limited in
size by default and templates are automatically reloaded.
All loaders are subclasses of <a class="reference internal" href="#jinja2.BaseLoader" title="jinja2.BaseLoader"><code class="xref py py-class docutils literal"><span class="pre">BaseLoader</span></code></a>.  If you want to create your
own loader, subclass <a class="reference internal" href="#jinja2.BaseLoader" title="jinja2.BaseLoader"><code class="xref py py-class docutils literal"><span class="pre">BaseLoader</span></code></a> and override <cite>get_source</cite>.</p>
<dl class="class">
<dt id="jinja2.BaseLoader">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">BaseLoader</code><a class="headerlink" href="#jinja2.BaseLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>Baseclass for all loaders.  Subclass this and override <cite>get_source</cite> to
implement a custom loading mechanism.  The environment provides a
<cite>get_template</cite> method that calls the loader&#8217;s <cite>load</cite> method to get the
<a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code class="xref py py-class docutils literal"><span class="pre">Template</span></code></a> object.</p>
<p>A very basic example for a loader that looks up templates on the file
system could look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">jinja2</span> <span class="kn">import</span> <span class="n">BaseLoader</span><span class="p">,</span> <span class="n">TemplateNotFound</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">join</span><span class="p">,</span> <span class="n">exists</span><span class="p">,</span> <span class="n">getmtime</span>

<span class="k">class</span> <span class="nc">MyLoader</span><span class="p">(</span><span class="n">BaseLoader</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">get_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environment</span><span class="p">,</span> <span class="n">template</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">TemplateNotFound</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
        <span class="n">mtime</span> <span class="o">=</span> <span class="n">getmtime</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&#39;utf-8&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">source</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">mtime</span> <span class="o">==</span> <span class="n">getmtime</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="jinja2.BaseLoader.get_source">
<code class="descname">get_source</code><span class="sig-paren">(</span><em>environment</em>, <em>template</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.BaseLoader.get_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the template source, filename and reload helper for a template.
It&#8217;s passed the environment and template name and has to return a
tuple in the form <code class="docutils literal"><span class="pre">(source,</span> <span class="pre">filename,</span> <span class="pre">uptodate)</span></code> or raise a
<cite>TemplateNotFound</cite> error if it can&#8217;t locate the template.</p>
<p>The source part of the returned tuple must be the source of the
template as unicode string or a ASCII bytestring.  The filename should
be the name of the file on the filesystem if it was loaded from there,
otherwise <cite>None</cite>.  The filename is used by python for the tracebacks
if no loader extension is used.</p>
<p>The last item in the tuple is the <cite>uptodate</cite> function.  If auto
reloading is enabled it&#8217;s always called to check if the template
changed.  No arguments are passed so the function must store the
old state somewhere (for example in a closure).  If it returns <cite>False</cite>
the template will be reloaded.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.BaseLoader.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>environment</em>, <em>name</em>, <em>globals=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.BaseLoader.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a template.  This method looks up the template in the cache
or loads one by calling <a class="reference internal" href="#jinja2.BaseLoader.get_source" title="jinja2.BaseLoader.get_source"><code class="xref py py-meth docutils literal"><span class="pre">get_source()</span></code></a>.  Subclasses should not
override this method as loaders working on collections of other
loaders (such as <a class="reference internal" href="#jinja2.PrefixLoader" title="jinja2.PrefixLoader"><code class="xref py py-class docutils literal"><span class="pre">PrefixLoader</span></code></a> or <a class="reference internal" href="#jinja2.ChoiceLoader" title="jinja2.ChoiceLoader"><code class="xref py py-class docutils literal"><span class="pre">ChoiceLoader</span></code></a>)
will not call this method but <cite>get_source</cite> directly.</p>
</dd></dl>

</dd></dl>

<p>Here a list of the builtin loaders Jinja2 provides:</p>
<dl class="class">
<dt id="jinja2.FileSystemLoader">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">FileSystemLoader</code><span class="sig-paren">(</span><em>searchpath</em>, <em>encoding='utf-8'</em>, <em>followlinks=False</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.FileSystemLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads templates from the file system.  This loader can find templates
in folders on the file system and is the preferred way to load them.</p>
<p>The loader takes the path to the templates as string, or if multiple
locations are wanted a list of them which is then looked up in the
given order:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">loader</span> <span class="o">=</span> <span class="n">FileSystemLoader</span><span class="p">(</span><span class="s">&#39;/path/to/templates&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loader</span> <span class="o">=</span> <span class="n">FileSystemLoader</span><span class="p">([</span><span class="s">&#39;/path/to/templates&#39;</span><span class="p">,</span> <span class="s">&#39;/other/path&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Per default the template encoding is <code class="docutils literal"><span class="pre">'utf-8'</span></code> which can be changed
by setting the <cite>encoding</cite> parameter to something else.</p>
<p>To follow symbolic links, set the <em>followlinks</em> parameter to <code class="docutils literal"><span class="pre">True</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">loader</span> <span class="o">=</span> <span class="n">FileSystemLoader</span><span class="p">(</span><span class="s">&#39;/path/to/templates&#39;</span><span class="p">,</span> <span class="n">followlinks</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 2.8+: </span>The <em>followlinks</em> parameter was added.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="jinja2.PackageLoader">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">PackageLoader</code><span class="sig-paren">(</span><em>package_name</em>, <em>package_path='templates'</em>, <em>encoding='utf-8'</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.PackageLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>Load templates from python eggs or packages.  It is constructed with
the name of the python package and the path to the templates in that
package:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">loader</span> <span class="o">=</span> <span class="n">PackageLoader</span><span class="p">(</span><span class="s">&#39;mypackage&#39;</span><span class="p">,</span> <span class="s">&#39;views&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If the package path is not given, <code class="docutils literal"><span class="pre">'templates'</span></code> is assumed.</p>
<p>Per default the template encoding is <code class="docutils literal"><span class="pre">'utf-8'</span></code> which can be changed
by setting the <cite>encoding</cite> parameter to something else.  Due to the nature
of eggs it&#8217;s only possible to reload templates if the package was loaded
from the file system and not a zip file.</p>
</dd></dl>

<dl class="class">
<dt id="jinja2.DictLoader">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">DictLoader</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.DictLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a template from a python dict.  It&#8217;s passed a dict of unicode
strings bound to template names.  This loader is useful for unittesting:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">loader</span> <span class="o">=</span> <span class="n">DictLoader</span><span class="p">({</span><span class="s">&#39;index.html&#39;</span><span class="p">:</span> <span class="s">&#39;source here&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>Because auto reloading is rarely useful this is disabled per default.</p>
</dd></dl>

<dl class="class">
<dt id="jinja2.FunctionLoader">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">FunctionLoader</code><span class="sig-paren">(</span><em>load_func</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.FunctionLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>A loader that is passed a function which does the loading.  The
function receives the name of the template and has to return either
an unicode string with the template source, a tuple in the form <code class="docutils literal"><span class="pre">(source,</span>
<span class="pre">filename,</span> <span class="pre">uptodatefunc)</span></code> or <cite>None</cite> if the template does not exist.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">load_template</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;index.html&#39;</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s">&#39;...&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loader</span> <span class="o">=</span> <span class="n">FunctionLoader</span><span class="p">(</span><span class="n">load_template</span><span class="p">)</span>
</pre></div>
</div>
<p>The <cite>uptodatefunc</cite> is a function that is called if autoreload is enabled
and has to return <cite>True</cite> if the template is still up to date.  For more
details have a look at <a class="reference internal" href="#jinja2.BaseLoader.get_source" title="jinja2.BaseLoader.get_source"><code class="xref py py-meth docutils literal"><span class="pre">BaseLoader.get_source()</span></code></a> which has the same
return value.</p>
</dd></dl>

<dl class="class">
<dt id="jinja2.PrefixLoader">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">PrefixLoader</code><span class="sig-paren">(</span><em>mapping</em>, <em>delimiter='/'</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.PrefixLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>A loader that is passed a dict of loaders where each loader is bound
to a prefix.  The prefix is delimited from the template by a slash per
default, which can be changed by setting the <cite>delimiter</cite> argument to
something else:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">loader</span> <span class="o">=</span> <span class="n">PrefixLoader</span><span class="p">({</span>
    <span class="s">&#39;app1&#39;</span><span class="p">:</span>     <span class="n">PackageLoader</span><span class="p">(</span><span class="s">&#39;mypackage.app1&#39;</span><span class="p">),</span>
    <span class="s">&#39;app2&#39;</span><span class="p">:</span>     <span class="n">PackageLoader</span><span class="p">(</span><span class="s">&#39;mypackage.app2&#39;</span><span class="p">)</span>
<span class="p">})</span>
</pre></div>
</div>
<p>By loading <code class="docutils literal"><span class="pre">'app1/index.html'</span></code> the file from the app1 package is loaded,
by loading <code class="docutils literal"><span class="pre">'app2/index.html'</span></code> the file from the second.</p>
</dd></dl>

<dl class="class">
<dt id="jinja2.ChoiceLoader">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">ChoiceLoader</code><span class="sig-paren">(</span><em>loaders</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.ChoiceLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>This loader works like the <cite>PrefixLoader</cite> just that no prefix is
specified.  If a template could not be found by one loader the next one
is tried.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">loader</span> <span class="o">=</span> <span class="n">ChoiceLoader</span><span class="p">([</span>
<span class="gp">... </span>    <span class="n">FileSystemLoader</span><span class="p">(</span><span class="s">&#39;/path/to/user/templates&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">FileSystemLoader</span><span class="p">(</span><span class="s">&#39;/path/to/system/templates&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">])</span>
</pre></div>
</div>
<p>This is useful if you want to allow users to override builtin templates
from a different location.</p>
</dd></dl>

<dl class="class">
<dt id="jinja2.ModuleLoader">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">ModuleLoader</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.ModuleLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>This loader loads templates from precompiled templates.</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">loader</span> <span class="o">=</span> <span class="n">ChoiceLoader</span><span class="p">([</span>
<span class="gp">... </span>    <span class="n">ModuleLoader</span><span class="p">(</span><span class="s">&#39;/path/to/compiled/templates&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">FileSystemLoader</span><span class="p">(</span><span class="s">&#39;/path/to/templates&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">])</span>
</pre></div>
</div>
<p>Templates can be precompiled with <a class="reference internal" href="#jinja2.Environment.compile_templates" title="jinja2.Environment.compile_templates"><code class="xref py py-meth docutils literal"><span class="pre">Environment.compile_templates()</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="bytecode-cache">
<span id="id2"></span><h2>Bytecode Cache<a class="headerlink" href="#bytecode-cache" title="Permalink to this headline">¶</a></h2>
<p>Jinja 2.1 and higher support external bytecode caching.  Bytecode caches make
it possible to store the generated bytecode on the file system or a different
location to avoid parsing the templates on first use.</p>
<p>This is especially useful if you have a web application that is initialized on
the first request and Jinja compiles many templates at once which slows down
the application.</p>
<p>To use a bytecode cache, instantiate it and pass it to the <a class="reference internal" href="#jinja2.Environment" title="jinja2.Environment"><code class="xref py py-class docutils literal"><span class="pre">Environment</span></code></a>.</p>
<dl class="class">
<dt id="jinja2.BytecodeCache">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">BytecodeCache</code><a class="headerlink" href="#jinja2.BytecodeCache" title="Permalink to this definition">¶</a></dt>
<dd><p>To implement your own bytecode cache you have to subclass this class
and override <a class="reference internal" href="#jinja2.BytecodeCache.load_bytecode" title="jinja2.BytecodeCache.load_bytecode"><code class="xref py py-meth docutils literal"><span class="pre">load_bytecode()</span></code></a> and <a class="reference internal" href="#jinja2.BytecodeCache.dump_bytecode" title="jinja2.BytecodeCache.dump_bytecode"><code class="xref py py-meth docutils literal"><span class="pre">dump_bytecode()</span></code></a>.  Both of
these methods are passed a <a class="reference internal" href="#jinja2.bccache.Bucket" title="jinja2.bccache.Bucket"><code class="xref py py-class docutils literal"><span class="pre">Bucket</span></code></a>.</p>
<p>A very basic bytecode cache that saves the bytecode on the file system:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">path</span>

<span class="k">class</span> <span class="nc">MyCache</span><span class="p">(</span><span class="n">BytecodeCache</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directory</span> <span class="o">=</span> <span class="n">directory</span>

    <span class="k">def</span> <span class="nf">load_bytecode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bucket</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="n">bucket</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">bucket</span><span class="o">.</span><span class="n">load_bytecode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dump_bytecode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bucket</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="n">bucket</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">bucket</span><span class="o">.</span><span class="n">write_bytecode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>A more advanced version of a filesystem based bytecode cache is part of
Jinja2.</p>
<dl class="method">
<dt id="jinja2.BytecodeCache.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.BytecodeCache.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the cache.  This method is not used by Jinja2 but should be
implemented to allow applications to clear the bytecode cache used
by a particular environment.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.BytecodeCache.dump_bytecode">
<code class="descname">dump_bytecode</code><span class="sig-paren">(</span><em>bucket</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.BytecodeCache.dump_bytecode" title="Permalink to this definition">¶</a></dt>
<dd><p>Subclasses have to override this method to write the bytecode
from a bucket back to the cache.  If it unable to do so it must not
fail silently but raise an exception.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.BytecodeCache.load_bytecode">
<code class="descname">load_bytecode</code><span class="sig-paren">(</span><em>bucket</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.BytecodeCache.load_bytecode" title="Permalink to this definition">¶</a></dt>
<dd><p>Subclasses have to override this method to load bytecode into a
bucket.  If they are not able to find code in the cache for the
bucket, it must not do anything.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="jinja2.bccache.Bucket">
<em class="property">class </em><code class="descclassname">jinja2.bccache.</code><code class="descname">Bucket</code><span class="sig-paren">(</span><em>environment</em>, <em>key</em>, <em>checksum</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.bccache.Bucket" title="Permalink to this definition">¶</a></dt>
<dd><p>Buckets are used to store the bytecode for one template.  It&#8217;s created
and initialized by the bytecode cache and passed to the loading functions.</p>
<p>The buckets get an internal checksum from the cache assigned and use this
to automatically reject outdated cache material.  Individual bytecode
cache subclasses don&#8217;t have to care about cache invalidation.</p>
<dl class="attribute">
<dt id="jinja2.Bucket.environment">
<code class="descname">environment</code><a class="headerlink" href="#jinja2.Bucket.environment" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#jinja2.Environment" title="jinja2.Environment"><code class="xref py py-class docutils literal"><span class="pre">Environment</span></code></a> that created the bucket.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Bucket.key">
<code class="descname">key</code><a class="headerlink" href="#jinja2.Bucket.key" title="Permalink to this definition">¶</a></dt>
<dd><p>The unique cache key for this bucket</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Bucket.code">
<code class="descname">code</code><a class="headerlink" href="#jinja2.Bucket.code" title="Permalink to this definition">¶</a></dt>
<dd><p>The bytecode if it&#8217;s loaded, otherwise <cite>None</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.bccache.Bucket.bytecode_from_string">
<code class="descname">bytecode_from_string</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.bccache.Bucket.bytecode_from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Load bytecode from a string.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.bccache.Bucket.bytecode_to_string">
<code class="descname">bytecode_to_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.bccache.Bucket.bytecode_to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bytecode as string.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.bccache.Bucket.load_bytecode">
<code class="descname">load_bytecode</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.bccache.Bucket.load_bytecode" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads bytecode from a file or file like object.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.bccache.Bucket.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.bccache.Bucket.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the bucket (unloads the bytecode).</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.bccache.Bucket.write_bytecode">
<code class="descname">write_bytecode</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.bccache.Bucket.write_bytecode" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump the bytecode into the file or file like object passed.</p>
</dd></dl>

</dd></dl>

<p>Builtin bytecode caches:</p>
<dl class="class">
<dt id="jinja2.FileSystemBytecodeCache">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">FileSystemBytecodeCache</code><span class="sig-paren">(</span><em>directory=None</em>, <em>pattern='__jinja2_%s.cache'</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.FileSystemBytecodeCache" title="Permalink to this definition">¶</a></dt>
<dd><p>A bytecode cache that stores bytecode on the filesystem.  It accepts
two arguments: The directory where the cache items are stored and a
pattern string that is used to build the filename.</p>
<p>If no directory is specified a default cache directory is selected.  On
Windows the user&#8217;s temp directory is used, on UNIX systems a directory
is created for the user in the system temp directory.</p>
<p>The pattern can be used to have multiple separate caches operate on the
same directory.  The default pattern is <code class="docutils literal"><span class="pre">'__jinja2_%s.cache'</span></code>.  <code class="docutils literal"><span class="pre">%s</span></code>
is replaced with the cache key.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bcc</span> <span class="o">=</span> <span class="n">FileSystemBytecodeCache</span><span class="p">(</span><span class="s">&#39;/tmp/jinja_cache&#39;</span><span class="p">,</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">.cache&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This bytecode cache supports clearing of the cache using the clear method.</p>
</dd></dl>

<dl class="class">
<dt id="jinja2.MemcachedBytecodeCache">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">MemcachedBytecodeCache</code><span class="sig-paren">(</span><em>client</em>, <em>prefix='jinja2/bytecode/'</em>, <em>timeout=None</em>, <em>ignore_memcache_errors=True</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.MemcachedBytecodeCache" title="Permalink to this definition">¶</a></dt>
<dd><p>This class implements a bytecode cache that uses a memcache cache for
storing the information.  It does not enforce a specific memcache library
(tummy&#8217;s memcache or cmemcache) but will accept any class that provides
the minimal interface required.</p>
<p>Libraries compatible with this class:</p>
<ul class="simple">
<li><a class="reference external" href="http://werkzeug.pocoo.org/">werkzeug</a>.contrib.cache</li>
<li><a class="reference external" href="http://www.tummy.com/Community/software/python-memcached/">python-memcached</a></li>
<li><a class="reference external" href="http://gijsbert.org/cmemcache/">cmemcache</a></li>
</ul>
<p>(Unfortunately the django cache interface is not compatible because it
does not support storing binary data, only unicode.  You can however pass
the underlying cache client to the bytecode cache which is available
as <cite>django.core.cache.cache._client</cite>.)</p>
<p>The minimal interface for the client passed to the constructor is this:</p>
<dl class="class">
<dt id="jinja2.MemcachedBytecodeCache.MinimalClientInterface">
<em class="property">class </em><code class="descname">MinimalClientInterface</code><a class="headerlink" href="#jinja2.MemcachedBytecodeCache.MinimalClientInterface" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="jinja2.MemcachedBytecodeCache.MinimalClientInterface.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="optional">[</span>, <em>timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.MemcachedBytecodeCache.MinimalClientInterface.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores the bytecode in the cache.  <cite>value</cite> is a string and
<cite>timeout</cite> the timeout of the key.  If timeout is not provided
a default timeout or no timeout should be assumed, if it&#8217;s
provided it&#8217;s an integer with the number of seconds the cache
item should exist.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.MemcachedBytecodeCache.MinimalClientInterface.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.MemcachedBytecodeCache.MinimalClientInterface.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value for the cache key.  If the item does not
exist in the cache the return value must be <cite>None</cite>.</p>
</dd></dl>

</dd></dl>

<p>The other arguments to the constructor are the prefix for all keys that
is added before the actual cache key and the timeout for the bytecode in
the cache system.  We recommend a high (or no) timeout.</p>
<p>This bytecode cache does not support clearing of used items in the cache.
The clear method is a no-operation function.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.7: </span>Added support for ignoring memcache errors through the
<cite>ignore_memcache_errors</cite> parameter.</p>
</div>
</dd></dl>

</div>
<div class="section" id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h2>
<p>These helper functions and classes are useful if you add custom filters or
functions to a Jinja2 environment.</p>
<dl class="function">
<dt id="jinja2.environmentfilter">
<code class="descclassname">jinja2.</code><code class="descname">environmentfilter</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.environmentfilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator for marking evironment dependent filters.  The current
<a class="reference internal" href="#jinja2.Environment" title="jinja2.Environment"><code class="xref py py-class docutils literal"><span class="pre">Environment</span></code></a> is passed to the filter as first argument.</p>
</dd></dl>

<dl class="function">
<dt id="jinja2.contextfilter">
<code class="descclassname">jinja2.</code><code class="descname">contextfilter</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.contextfilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator for marking context dependent filters. The current
<code class="xref py py-class docutils literal"><span class="pre">Context</span></code> will be passed as first argument.</p>
</dd></dl>

<dl class="function">
<dt id="jinja2.evalcontextfilter">
<code class="descclassname">jinja2.</code><code class="descname">evalcontextfilter</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.evalcontextfilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator for marking eval-context dependent filters.  An eval
context object is passed as first argument.  For more information
about the eval context, see <a class="reference internal" href="#eval-context"><span>Evaluation Context</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.4.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="jinja2.environmentfunction">
<code class="descclassname">jinja2.</code><code class="descname">environmentfunction</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.environmentfunction" title="Permalink to this definition">¶</a></dt>
<dd><p>This decorator can be used to mark a function or method as environment
callable.  This decorator works exactly like the <a class="reference internal" href="#jinja2.contextfunction" title="jinja2.contextfunction"><code class="xref py py-func docutils literal"><span class="pre">contextfunction()</span></code></a>
decorator just that the first argument is the active <a class="reference internal" href="#jinja2.Environment" title="jinja2.Environment"><code class="xref py py-class docutils literal"><span class="pre">Environment</span></code></a>
and not context.</p>
</dd></dl>

<dl class="function">
<dt id="jinja2.contextfunction">
<code class="descclassname">jinja2.</code><code class="descname">contextfunction</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.contextfunction" title="Permalink to this definition">¶</a></dt>
<dd><p>This decorator can be used to mark a function or method context callable.
A context callable is passed the active <code class="xref py py-class docutils literal"><span class="pre">Context</span></code> as first argument when
called from the template.  This is useful if a function wants to get access
to the context or functions provided on the context object.  For example
a function that returns a sorted list of template variables the current
template exports could look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@contextfunction</span>
<span class="k">def</span> <span class="nf">get_exported_names</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">exported_vars</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="jinja2.evalcontextfunction">
<code class="descclassname">jinja2.</code><code class="descname">evalcontextfunction</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.evalcontextfunction" title="Permalink to this definition">¶</a></dt>
<dd><p>This decorator can be used to mark a function or method as an eval
context callable.  This is similar to the <a class="reference internal" href="#jinja2.contextfunction" title="jinja2.contextfunction"><code class="xref py py-func docutils literal"><span class="pre">contextfunction()</span></code></a>
but instead of passing the context, an evaluation context object is
passed.  For more information about the eval context, see
<a class="reference internal" href="#eval-context"><span>Evaluation Context</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.4.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="jinja2.escape">
<code class="descclassname">jinja2.</code><code class="descname">escape</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.escape" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the characters <code class="docutils literal"><span class="pre">&amp;</span></code>, <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">'</span></code>, and <code class="docutils literal"><span class="pre">&quot;</span></code> in string <cite>s</cite>
to HTML-safe sequences.  Use this if you need to display text that might
contain such characters in HTML.  This function will not escaped objects
that do have an HTML representation such as already escaped data.</p>
<p>The return value is a <a class="reference internal" href="#jinja2.Markup" title="jinja2.Markup"><code class="xref py py-class docutils literal"><span class="pre">Markup</span></code></a> string.</p>
</dd></dl>

<dl class="function">
<dt id="jinja2.clear_caches">
<code class="descclassname">jinja2.</code><code class="descname">clear_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.clear_caches" title="Permalink to this definition">¶</a></dt>
<dd><p>Jinja2 keeps internal caches for environments and lexers.  These are
used so that Jinja2 doesn&#8217;t have to recreate environments and lexers all
the time.  Normally you don&#8217;t have to care about that but if you are
messuring memory consumption you may want to clean the caches.</p>
</dd></dl>

<dl class="function">
<dt id="jinja2.is_undefined">
<code class="descclassname">jinja2.</code><code class="descname">is_undefined</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.is_undefined" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the object passed is undefined.  This does nothing more than
performing an instance check against <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code class="xref py py-class docutils literal"><span class="pre">Undefined</span></code></a> but looks nicer.
This can be used for custom filters or tests that want to react to
undefined variables.  For example a custom default filter can look like
this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">default</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_undefined</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">default</span>
    <span class="k">return</span> <span class="n">var</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="jinja2.Markup">
<em class="property">class </em><code class="descclassname">jinja2.</code><code class="descname">Markup</code><span class="sig-paren">(</span><span class="optional">[</span><em>string</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Markup" title="Permalink to this definition">¶</a></dt>
<dd><p>Marks a string as being safe for inclusion in HTML/XML output without
needing to be escaped.  This implements the <cite>__html__</cite> interface a couple
of frameworks and web applications use.  <a class="reference internal" href="#jinja2.Markup" title="jinja2.Markup"><code class="xref py py-class docutils literal"><span class="pre">Markup</span></code></a> is a direct
subclass of <cite>unicode</cite> and provides all the methods of <cite>unicode</cite> just that
it escapes arguments passed and always returns <cite>Markup</cite>.</p>
<p>The <cite>escape</cite> function returns markup objects so that double escaping can&#8217;t
happen.</p>
<p>The constructor of the <a class="reference internal" href="#jinja2.Markup" title="jinja2.Markup"><code class="xref py py-class docutils literal"><span class="pre">Markup</span></code></a> class can be used for three
different things:  When passed an unicode object it&#8217;s assumed to be safe,
when passed an object with an HTML representation (has an <cite>__html__</cite>
method) that representation is used, otherwise the object passed is
converted into a unicode string and then assumed to be safe:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s">&quot;Hello &lt;em&gt;World&lt;/em&gt;!&quot;</span><span class="p">)</span>
<span class="go">Markup(u&#39;Hello &lt;em&gt;World&lt;/em&gt;!&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span> <span class="k">def</span> <span class="nf">__html__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>  <span class="k">return</span> <span class="s">&#39;&lt;a href=&quot;#&quot;&gt;foo&lt;/a&gt;&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="n">Foo</span><span class="p">())</span>
<span class="go">Markup(u&#39;&lt;a href=&quot;#&quot;&gt;foo&lt;/a&gt;&#39;)</span>
</pre></div>
</div>
<p>If you want object passed being always treated as unsafe you can use the
<a class="reference internal" href="templates.html#escape" title="escape"><code class="xref py py-meth docutils literal"><span class="pre">escape()</span></code></a> classmethod to create a <a class="reference internal" href="#jinja2.Markup" title="jinja2.Markup"><code class="xref py py-class docutils literal"><span class="pre">Markup</span></code></a> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s">&quot;Hello &lt;em&gt;World&lt;/em&gt;!&quot;</span><span class="p">)</span>
<span class="go">Markup(u&#39;Hello &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt;!&#39;)</span>
</pre></div>
</div>
<p>Operations on a markup string are markup aware which means that all
arguments are passed through the <a class="reference internal" href="templates.html#escape" title="escape"><code class="xref py py-func docutils literal"><span class="pre">escape()</span></code></a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">=</span> <span class="n">Markup</span><span class="p">(</span><span class="s">&quot;&lt;em&gt;</span><span class="si">%s</span><span class="s">&lt;/em&gt;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">%</span> <span class="s">&quot;foo &amp; bar&quot;</span>
<span class="go">Markup(u&#39;&lt;em&gt;foo &amp;amp; bar&lt;/em&gt;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strong</span> <span class="o">=</span> <span class="n">Markup</span><span class="p">(</span><span class="s">&quot;&lt;strong&gt;</span><span class="si">%(text)s</span><span class="s">&lt;/strong&gt;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strong</span> <span class="o">%</span> <span class="p">{</span><span class="s">&#39;text&#39;</span><span class="p">:</span> <span class="s">&#39;&lt;blink&gt;hacker here&lt;/blink&gt;&#39;</span><span class="p">}</span>
<span class="go">Markup(u&#39;&lt;strong&gt;&amp;lt;blink&amp;gt;hacker here&amp;lt;/blink&amp;gt;&lt;/strong&gt;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s">&quot;&lt;em&gt;Hello&lt;/em&gt; &quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;&lt;foo&gt;&quot;</span>
<span class="go">Markup(u&#39;&lt;em&gt;Hello&lt;/em&gt; &amp;lt;foo&amp;gt;&#39;)</span>
</pre></div>
</div>
<dl class="classmethod">
<dt id="jinja2.Markup.escape">
<em class="property">classmethod </em><code class="descname">escape</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Markup.escape" title="Permalink to this definition">¶</a></dt>
<dd><p>Escape the string.  Works like <a class="reference internal" href="templates.html#escape" title="escape"><code class="xref py py-func docutils literal"><span class="pre">escape()</span></code></a> with the difference
that for subclasses of <a class="reference internal" href="#jinja2.Markup" title="jinja2.Markup"><code class="xref py py-class docutils literal"><span class="pre">Markup</span></code></a> this function would return the
correct subclass.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.Markup.striptags">
<code class="descname">striptags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Markup.striptags" title="Permalink to this definition">¶</a></dt>
<dd><p>Unescape markup into an text_type string and strip all tags.  This
also resolves known HTML4 and XHTML entities.  Whitespace is
normalized to one:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s">&quot;Main &amp;raquo;  &lt;em&gt;About&lt;/em&gt;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">striptags</span><span class="p">()</span>
<span class="go">u&#39;Main \xbb About&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="jinja2.Markup.unescape">
<code class="descname">unescape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Markup.unescape" title="Permalink to this definition">¶</a></dt>
<dd><p>Unescape markup again into an text_type string.  This also resolves
known HTML4 and XHTML entities:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s">&quot;Main &amp;raquo; &lt;em&gt;About&lt;/em&gt;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unescape</span><span class="p">()</span>
<span class="go">u&#39;Main \xbb &lt;em&gt;About&lt;/em&gt;&#39;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">The Jinja2 <a class="reference internal" href="#jinja2.Markup" title="jinja2.Markup"><code class="xref py py-class docutils literal"><span class="pre">Markup</span></code></a> class is compatible with at least Pylons and
Genshi.  It&#8217;s expected that more template engines and framework will pick
up the <cite>__html__</cite> concept soon.</p>
</div>
</div>
<div class="section" id="exceptions">
<h2>Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="jinja2.TemplateError">
<em class="property">exception </em><code class="descclassname">jinja2.</code><code class="descname">TemplateError</code><span class="sig-paren">(</span><em>message=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.TemplateError" title="Permalink to this definition">¶</a></dt>
<dd><p>Baseclass for all template errors.</p>
</dd></dl>

<dl class="exception">
<dt id="jinja2.UndefinedError">
<em class="property">exception </em><code class="descclassname">jinja2.</code><code class="descname">UndefinedError</code><span class="sig-paren">(</span><em>message=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.UndefinedError" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised if a template tries to operate on <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code class="xref py py-class docutils literal"><span class="pre">Undefined</span></code></a>.</p>
</dd></dl>

<dl class="exception">
<dt id="jinja2.TemplateNotFound">
<em class="property">exception </em><code class="descclassname">jinja2.</code><code class="descname">TemplateNotFound</code><span class="sig-paren">(</span><em>name</em>, <em>message=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.TemplateNotFound" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised if a template does not exist.</p>
</dd></dl>

<dl class="exception">
<dt id="jinja2.TemplatesNotFound">
<em class="property">exception </em><code class="descclassname">jinja2.</code><code class="descname">TemplatesNotFound</code><span class="sig-paren">(</span><em>names=()</em>, <em>message=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.TemplatesNotFound" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#jinja2.TemplateNotFound" title="jinja2.TemplateNotFound"><code class="xref py py-class docutils literal"><span class="pre">TemplateNotFound</span></code></a> but raised if multiple templates
are selected.  This is a subclass of <a class="reference internal" href="#jinja2.TemplateNotFound" title="jinja2.TemplateNotFound"><code class="xref py py-class docutils literal"><span class="pre">TemplateNotFound</span></code></a>
exception, so just catching the base exception will catch both.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.2.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="jinja2.TemplateSyntaxError">
<em class="property">exception </em><code class="descclassname">jinja2.</code><code class="descname">TemplateSyntaxError</code><span class="sig-paren">(</span><em>message</em>, <em>lineno</em>, <em>name=None</em>, <em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.TemplateSyntaxError" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised to tell the user that there is a problem with the template.</p>
<dl class="attribute">
<dt id="jinja2.TemplateSyntaxError.message">
<code class="descname">message</code><a class="headerlink" href="#jinja2.TemplateSyntaxError.message" title="Permalink to this definition">¶</a></dt>
<dd><p>The error message as utf-8 bytestring.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.TemplateSyntaxError.lineno">
<code class="descname">lineno</code><a class="headerlink" href="#jinja2.TemplateSyntaxError.lineno" title="Permalink to this definition">¶</a></dt>
<dd><p>The line number where the error occurred</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.TemplateSyntaxError.name">
<code class="descname">name</code><a class="headerlink" href="#jinja2.TemplateSyntaxError.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The load name for the template as unicode string.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.TemplateSyntaxError.filename">
<code class="descname">filename</code><a class="headerlink" href="#jinja2.TemplateSyntaxError.filename" title="Permalink to this definition">¶</a></dt>
<dd><p>The filename that loaded the template as bytestring in the encoding
of the file system (most likely utf-8 or mbcs on Windows systems).</p>
</dd></dl>

<p>The reason why the filename and error message are bytestrings and not
unicode strings is that Python 2.x is not using unicode for exceptions
and tracebacks as well as the compiler.  This will change with Python 3.</p>
</dd></dl>

<dl class="exception">
<dt id="jinja2.TemplateAssertionError">
<em class="property">exception </em><code class="descclassname">jinja2.</code><code class="descname">TemplateAssertionError</code><span class="sig-paren">(</span><em>message</em>, <em>lineno</em>, <em>name=None</em>, <em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.TemplateAssertionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Like a template syntax error, but covers cases where something in the
template caused an error at compile time that wasn&#8217;t necessarily caused
by a syntax error.  However it&#8217;s a direct subclass of
<a class="reference internal" href="#jinja2.TemplateSyntaxError" title="jinja2.TemplateSyntaxError"><code class="xref py py-exc docutils literal"><span class="pre">TemplateSyntaxError</span></code></a> and has the same attributes.</p>
</dd></dl>

</div>
<div class="section" id="custom-filters">
<span id="writing-filters"></span><h2>Custom Filters<a class="headerlink" href="#custom-filters" title="Permalink to this headline">¶</a></h2>
<p>Custom filters are just regular Python functions that take the left side of
the filter as first argument and the the arguments passed to the filter as
extra arguments or keyword arguments.</p>
<p>For example in the filter <code class="docutils literal"><span class="pre">{{</span> <span class="pre">42|myfilter(23)</span> <span class="pre">}}</span></code> the function would be
called with <code class="docutils literal"><span class="pre">myfilter(42,</span> <span class="pre">23)</span></code>.  Here for example a simple filter that can
be applied to datetime objects to format them:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">datetimeformat</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;%H:%M / </span><span class="si">%d</span><span class="s">-%m-%Y&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
</pre></div>
</div>
<p>You can register it on the template environment by updating the
<a class="reference internal" href="#jinja2.Environment.filters" title="jinja2.Environment.filters"><code class="xref py py-attr docutils literal"><span class="pre">filters</span></code></a> dict on the environment:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">environment</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s">&#39;datetimeformat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">datetimeformat</span>
</pre></div>
</div>
<p>Inside the template it can then be used as follows:</p>
<div class="highlight-jinja"><div class="highlight"><pre><span class="x">written on: </span><span class="cp">{{</span> <span class="nv">article.pub_date</span><span class="o">|</span><span class="nf">datetimeformat</span> <span class="cp">}}</span><span class="x"></span>
<span class="x">publication date: </span><span class="cp">{{</span> <span class="nv">article.pub_date</span><span class="o">|</span><span class="nf">datetimeformat</span><span class="o">(</span><span class="s1">&#39;%d-%m-%Y&#39;</span><span class="o">)</span> <span class="cp">}}</span><span class="x"></span>
</pre></div>
</div>
<p>Filters can also be passed the current template context or environment.  This
is useful if a filter wants to return an undefined value or check the current
<code class="xref py py-attr docutils literal"><span class="pre">autoescape</span></code> setting.  For this purpose three decorators
exist: <a class="reference internal" href="#jinja2.environmentfilter" title="jinja2.environmentfilter"><code class="xref py py-func docutils literal"><span class="pre">environmentfilter()</span></code></a>, <a class="reference internal" href="#jinja2.contextfilter" title="jinja2.contextfilter"><code class="xref py py-func docutils literal"><span class="pre">contextfilter()</span></code></a> and
<a class="reference internal" href="#jinja2.evalcontextfilter" title="jinja2.evalcontextfilter"><code class="xref py py-func docutils literal"><span class="pre">evalcontextfilter()</span></code></a>.</p>
<p>Here a small example filter that breaks a text into HTML line breaks and
paragraphs and marks the return value as safe HTML string if autoescaping is
enabled:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">jinja2</span> <span class="kn">import</span> <span class="n">evalcontextfilter</span><span class="p">,</span> <span class="n">Markup</span><span class="p">,</span> <span class="n">escape</span>

<span class="n">_paragraph_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;(?:\r\n|\r|\n){2,}&#39;</span><span class="p">)</span>

<span class="nd">@evalcontextfilter</span>
<span class="k">def</span> <span class="nf">nl2br</span><span class="p">(</span><span class="n">eval_ctx</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="s">u&#39;</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">u&#39;&lt;p&gt;</span><span class="si">%s</span><span class="s">&lt;/p&gt;&#39;</span> <span class="o">%</span> <span class="n">p</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">Markup</span><span class="p">(</span><span class="s">&#39;&lt;br&gt;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">))</span>
                          <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">_paragraph_re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">escape</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">eval_ctx</span><span class="o">.</span><span class="n">autoescape</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Markup</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>Context filters work the same just that the first argument is the current
active <code class="xref py py-class docutils literal"><span class="pre">Context</span></code> rather then the environment.</p>
</div>
<div class="section" id="evaluation-context">
<span id="eval-context"></span><h2>Evaluation Context<a class="headerlink" href="#evaluation-context" title="Permalink to this headline">¶</a></h2>
<p>The evaluation context (short eval context or eval ctx) is a new object
introduced in Jinja 2.4 that makes it possible to activate and deactivate
compiled features at runtime.</p>
<p>Currently it is only used to enable and disable the automatic escaping but
can be used for extensions as well.</p>
<p>In previous Jinja versions filters and functions were marked as
environment callables in order to check for the autoescape status from the
environment.  In new versions it&#8217;s encouraged to check the setting from the
evaluation context instead.</p>
<p>Previous versions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@environmentfilter</span>
<span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">do_something</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">env</span><span class="o">.</span><span class="n">autoescape</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Markup</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>In new versions you can either use a <a class="reference internal" href="#jinja2.contextfilter" title="jinja2.contextfilter"><code class="xref py py-func docutils literal"><span class="pre">contextfilter()</span></code></a> and access the
evaluation context from the actual context, or use a
<a class="reference internal" href="#jinja2.evalcontextfilter" title="jinja2.evalcontextfilter"><code class="xref py py-func docutils literal"><span class="pre">evalcontextfilter()</span></code></a> which directly passes the evaluation context to
the function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@contextfilter</span>
<span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">do_something</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">eval_ctx</span><span class="o">.</span><span class="n">autoescape</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Markup</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="nd">@evalcontextfilter</span>
<span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="n">eval_ctx</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">do_something</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">eval_ctx</span><span class="o">.</span><span class="n">autoescape</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Markup</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>The evaluation context must not be modified at runtime.  Modifications
must only happen with a <a class="reference internal" href="extensions.html#jinja2.nodes.EvalContextModifier" title="jinja2.nodes.EvalContextModifier"><code class="xref py py-class docutils literal"><span class="pre">nodes.EvalContextModifier</span></code></a> and
<a class="reference internal" href="extensions.html#jinja2.nodes.ScopedEvalContextModifier" title="jinja2.nodes.ScopedEvalContextModifier"><code class="xref py py-class docutils literal"><span class="pre">nodes.ScopedEvalContextModifier</span></code></a> from an extension, not on the
eval context object itself.</p>
<dl class="class">
<dt id="jinja2.nodes.EvalContext">
<em class="property">class </em><code class="descclassname">jinja2.nodes.</code><code class="descname">EvalContext</code><span class="sig-paren">(</span><em>environment</em>, <em>template_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.nodes.EvalContext" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds evaluation time information.  Custom attributes can be attached
to it in extensions.</p>
<dl class="attribute">
<dt id="jinja2.EvalContext.autoescape">
<code class="descname">autoescape</code><a class="headerlink" href="#jinja2.EvalContext.autoescape" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>True</cite> or <cite>False</cite> depending on if autoescaping is active or not.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.EvalContext.volatile">
<code class="descname">volatile</code><a class="headerlink" href="#jinja2.EvalContext.volatile" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>True</cite> if the compiler cannot evaluate some expressions at compile
time.  At runtime this should always be <cite>False</cite>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="custom-tests">
<span id="writing-tests"></span><h2>Custom Tests<a class="headerlink" href="#custom-tests" title="Permalink to this headline">¶</a></h2>
<p>Tests work like filters just that there is no way for a test to get access
to the environment or context and that they can&#8217;t be chained.  The return
value of a test should be <cite>True</cite> or <cite>False</cite>.  The purpose of a test is to
give the template designers the possibility to perform type and conformability
checks.</p>
<p>Here a simple test that checks if a variable is a prime number:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>
</div>
<p>You can register it on the template environment by updating the
<a class="reference internal" href="#jinja2.Environment.tests" title="jinja2.Environment.tests"><code class="xref py py-attr docutils literal"><span class="pre">tests</span></code></a> dict on the environment:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">environment</span><span class="o">.</span><span class="n">tests</span><span class="p">[</span><span class="s">&#39;prime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_prime</span>
</pre></div>
</div>
<p>A template designer can then use the test like this:</p>
<div class="highlight-jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">if</span> <span class="m">42</span> <span class="k">is</span> <span class="nf">prime</span> <span class="cp">%}</span><span class="x"></span>
<span class="x">    42 is a prime number</span>
<span class="cp">{%</span> <span class="k">else</span> <span class="cp">%}</span><span class="x"></span>
<span class="x">    42 is not a prime number</span>
<span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span><span class="x"></span>
</pre></div>
</div>
</div>
<div class="section" id="the-global-namespace">
<span id="global-namespace"></span><h2>The Global Namespace<a class="headerlink" href="#the-global-namespace" title="Permalink to this headline">¶</a></h2>
<p>Variables stored in the <a class="reference internal" href="#jinja2.Environment.globals" title="jinja2.Environment.globals"><code class="xref py py-attr docutils literal"><span class="pre">Environment.globals</span></code></a> dict are special as they
are available for imported templates too, even if they are imported without
context.  This is the place where you can put variables and functions
that should be available all the time.  Additionally <a class="reference internal" href="#jinja2.Template.globals" title="jinja2.Template.globals"><code class="xref py py-attr docutils literal"><span class="pre">Template.globals</span></code></a>
exist that are variables available to a specific template that are available
to all <a class="reference internal" href="#jinja2.Template.render" title="jinja2.Template.render"><code class="xref py py-meth docutils literal"><span class="pre">render()</span></code></a> calls.</p>
</div>
<div class="section" id="low-level-api">
<span id="id3"></span><h2>Low Level API<a class="headerlink" href="#low-level-api" title="Permalink to this headline">¶</a></h2>
<p>The low level API exposes functionality that can be useful to understand some
implementation details, debugging purposes or advanced <a class="reference internal" href="extensions.html#jinja-extensions"><span>extension</span></a> techniques.  Unless you know exactly what you are doing we
don&#8217;t recommend using any of those.</p>
<dl class="method">
<dt id="jinja2.Environment.lex">
<code class="descclassname">Environment.</code><code class="descname">lex</code><span class="sig-paren">(</span><em>source</em>, <em>name=None</em>, <em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Environment.lex" title="Permalink to this definition">¶</a></dt>
<dd><p>Lex the given sourcecode and return a generator that yields
tokens as tuples in the form <code class="docutils literal"><span class="pre">(lineno,</span> <span class="pre">token_type,</span> <span class="pre">value)</span></code>.
This can be useful for <a class="reference internal" href="extensions.html#writing-extensions"><span>extension development</span></a>
and debugging templates.</p>
<p>This does not perform preprocessing.  If you want the preprocessing
of the extensions to be applied you have to filter source through
the <a class="reference internal" href="#jinja2.Environment.preprocess" title="jinja2.Environment.preprocess"><code class="xref py py-meth docutils literal"><span class="pre">preprocess()</span></code></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.Environment.parse">
<code class="descclassname">Environment.</code><code class="descname">parse</code><span class="sig-paren">(</span><em>source</em>, <em>name=None</em>, <em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Environment.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the sourcecode and return the abstract syntax tree.  This
tree of nodes is used by the compiler to convert the template into
executable source- or bytecode.  This is useful for debugging or to
extract information from templates.</p>
<p>If you are <a class="reference internal" href="extensions.html#writing-extensions"><span>developing Jinja2 extensions</span></a>
this gives you a good overview of the node tree generated.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.Environment.preprocess">
<code class="descclassname">Environment.</code><code class="descname">preprocess</code><span class="sig-paren">(</span><em>source</em>, <em>name=None</em>, <em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Environment.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Preprocesses the source with all extensions.  This is automatically
called for all parsing and compiling methods but <em>not</em> for <a class="reference internal" href="#jinja2.Environment.lex" title="jinja2.Environment.lex"><code class="xref py py-meth docutils literal"><span class="pre">lex()</span></code></a>
because there you usually only want the actual source tokenized.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.Template.new_context">
<code class="descclassname">Template.</code><code class="descname">new_context</code><span class="sig-paren">(</span><em>vars=None</em>, <em>shared=False</em>, <em>locals=None</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Template.new_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new <code class="xref py py-class docutils literal"><span class="pre">Context</span></code> for this template.  The vars
provided will be passed to the template.  Per default the globals
are added to the context.  If shared is set to <cite>True</cite> the data
is passed as it to the context without adding the globals.</p>
<p><cite>locals</cite> can be a dict of local variables for internal usage.</p>
</dd></dl>

<dl class="method">
<dt id="jinja2.Template.root_render_func">
<code class="descclassname">Template.</code><code class="descname">root_render_func</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.Template.root_render_func" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the low level render function.  It&#8217;s passed a <code class="xref py py-class docutils literal"><span class="pre">Context</span></code>
that has to be created by <a class="reference internal" href="#jinja2.Template.new_context" title="jinja2.Template.new_context"><code class="xref py py-meth docutils literal"><span class="pre">new_context()</span></code></a> of the same template or
a compatible template.  This render function is generated by the
compiler from the template code and returns a generator that yields
unicode strings.</p>
<p>If an exception in the template code happens the template engine will
not rewrite the exception but pass through the original one.  As a
matter of fact this function should only be called from within a
<a class="reference internal" href="#jinja2.Template.render" title="jinja2.Template.render"><code class="xref py py-meth docutils literal"><span class="pre">render()</span></code></a> / <a class="reference internal" href="#jinja2.Template.generate" title="jinja2.Template.generate"><code class="xref py py-meth docutils literal"><span class="pre">generate()</span></code></a> / <a class="reference internal" href="#jinja2.Template.stream" title="jinja2.Template.stream"><code class="xref py py-meth docutils literal"><span class="pre">stream()</span></code></a> call.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Template.blocks">
<code class="descclassname">Template.</code><code class="descname">blocks</code><a class="headerlink" href="#jinja2.Template.blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict of block render functions.  Each of these functions works exactly
like the <a class="reference internal" href="#jinja2.Template.root_render_func" title="jinja2.Template.root_render_func"><code class="xref py py-meth docutils literal"><span class="pre">root_render_func()</span></code></a> with the same limitations.</p>
</dd></dl>

<dl class="attribute">
<dt id="jinja2.Template.is_up_to_date">
<code class="descclassname">Template.</code><code class="descname">is_up_to_date</code><a class="headerlink" href="#jinja2.Template.is_up_to_date" title="Permalink to this definition">¶</a></dt>
<dd><p>This attribute is <cite>False</cite> if there is a newer version of the template
available, otherwise <cite>True</cite>.</p>
</dd></dl>

<div class="admonition-note admonition">
<p class="first admonition-title">Note</p>
<p class="last">The low-level API is fragile.  Future Jinja2 versions will try not to
change it in a backwards incompatible way but modifications in the Jinja2
core may shine through.  For example if Jinja2 introduces a new AST node
in later versions that may be returned by <a class="reference internal" href="#jinja2.Environment.parse" title="jinja2.Environment.parse"><code class="xref py py-meth docutils literal"><span class="pre">parse()</span></code></a>.</p>
</div>
</div>
<div class="section" id="the-meta-api">
<h2>The Meta API<a class="headerlink" href="#the-meta-api" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.2.</span></p>
</div>
<p>The meta API returns some information about abstract syntax trees that
could help applications to implement more advanced template concepts.  All
the functions of the meta API operate on an abstract syntax tree as
returned by the <a class="reference internal" href="#jinja2.Environment.parse" title="jinja2.Environment.parse"><code class="xref py py-meth docutils literal"><span class="pre">Environment.parse()</span></code></a> method.</p>
<dl class="function">
<dt id="jinja2.meta.find_undeclared_variables">
<code class="descclassname">jinja2.meta.</code><code class="descname">find_undeclared_variables</code><span class="sig-paren">(</span><em>ast</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.meta.find_undeclared_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a set of all variables in the AST that will be looked up from
the context at runtime.  Because at compile time it&#8217;s not known which
variables will be used depending on the path the execution takes at
runtime, all variables are returned.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">jinja2</span> <span class="kn">import</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">meta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ast</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#39;{</span><span class="si">% s</span><span class="s">et foo = 42 %}{{ bar + foo }}&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meta</span><span class="o">.</span><span class="n">find_undeclared_variables</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;bar&#39;</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition-implementation admonition">
<p class="first admonition-title">Implementation</p>
<p class="last">Internally the code generator is used for finding undeclared variables.
This is good to know because the code generator might raise a
<a class="reference internal" href="#jinja2.TemplateAssertionError" title="jinja2.TemplateAssertionError"><code class="xref py py-exc docutils literal"><span class="pre">TemplateAssertionError</span></code></a> during compilation and as a matter of
fact this function can currently raise that exception as well.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="jinja2.meta.find_referenced_templates">
<code class="descclassname">jinja2.meta.</code><code class="descname">find_referenced_templates</code><span class="sig-paren">(</span><em>ast</em><span class="sig-paren">)</span><a class="headerlink" href="#jinja2.meta.find_referenced_templates" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all the referenced templates from the AST.  This will return an
iterator over all the hardcoded template extensions, inclusions and
imports.  If dynamic inheritance or inclusion is used, <cite>None</cite> will be
yielded.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">jinja2</span> <span class="kn">import</span> <span class="n">Environment</span><span class="p">,</span> <span class="n">meta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ast</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#39;{</span><span class="si">% e</span><span class="s">xtends &quot;layout.html&quot; %}{</span><span class="si">% i</span><span class="s">nclude helper %}&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">find_referenced_templates</span><span class="p">(</span><span class="n">ast</span><span class="p">))</span>
<span class="go">[&#39;layout.html&#39;, None]</span>
</pre></div>
</div>
<p>This function is useful for dependency tracking.  For example if you want
to rebuild parts of the website after a layout template has changed.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><p class="logo"><a href="index.html">
  <img class="logo" src="_static/jinja-small.png" alt="Logo"/>
</a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">API</a><ul>
<li><a class="reference internal" href="#basics">Basics</a></li>
<li><a class="reference internal" href="#unicode">Unicode</a></li>
<li><a class="reference internal" href="#high-level-api">High Level API</a></li>
<li><a class="reference internal" href="#autoescaping">Autoescaping</a></li>
<li><a class="reference internal" href="#notes-on-identifiers">Notes on Identifiers</a></li>
<li><a class="reference internal" href="#undefined-types">Undefined Types</a></li>
<li><a class="reference internal" href="#the-context">The Context</a></li>
<li><a class="reference internal" href="#loaders">Loaders</a></li>
<li><a class="reference internal" href="#bytecode-cache">Bytecode Cache</a></li>
<li><a class="reference internal" href="#utilities">Utilities</a></li>
<li><a class="reference internal" href="#exceptions">Exceptions</a></li>
<li><a class="reference internal" href="#custom-filters">Custom Filters</a></li>
<li><a class="reference internal" href="#evaluation-context">Evaluation Context</a></li>
<li><a class="reference internal" href="#custom-tests">Custom Tests</a></li>
<li><a class="reference internal" href="#the-global-namespace">The Global Namespace</a></li>
<li><a class="reference internal" href="#low-level-api">Low Level API</a></li>
<li><a class="reference internal" href="#the-meta-api">The Meta API</a></li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="intro.html" title="previous chapter">Introduction</a></li>
      <li>Next: <a href="sandbox.html" title="next chapter">Sandbox</a></li>
  </ul></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/api.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy; Copyright 2008, Armin Ronacher.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
    </div>
  </body>
</html>
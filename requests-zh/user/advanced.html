<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>高级用法 &mdash; Requests 1.1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/flasky.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Requests 1.1.0 documentation" href="../index.html" />
    <link rel="next" title="身份认证" href="authentication.html" />
    <link rel="prev" title="快速上手" href="quickstart.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="authentication.html" title="身份认证"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="quickstart.html" title="快速上手"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Requests 1.1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="advanced">
<span id="id1"></span><h1>高级用法<a class="headerlink" href="#advanced" title="Permalink to this headline">¶</a></h1>
<p>本篇文档涵盖了Requests的一些更加高级的特性。</p>
<div class="section" id="id2">
<h2>会话对象<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>会话对象让你能够跨请求保持某些参数。它也会在同一个Session实例发出的所有请求之间保持cookies。</p>
<p>会话对象具有主要的Requests API的所有方法。</p>
<p>我们来跨请求保持一些cookies:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">s</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span>

<span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;http://httpbin.org/cookies/set/sessioncookie/123456789&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;http://httpbin.org/cookies&quot;</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="c"># &#39;{&quot;cookies&quot;: {&quot;sessioncookie&quot;: &quot;123456789&quot;}}&#39;</span>
</pre></div>
</div>
<p>会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">s</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">auth</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;user&#39;</span><span class="p">,</span> <span class="s">&#39;pass&#39;</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">&#39;x-test&#39;</span><span class="p">:</span> <span class="s">&#39;true&#39;</span><span class="p">})</span>

<span class="c"># both &#39;x-test&#39; and &#39;x-test2&#39; are sent</span>
<span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;http://httpbin.org/headers&#39;</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;x-test2&#39;</span><span class="p">:</span> <span class="s">&#39;true&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>任何你传递给请求方法的字典都会与已设置会话层数据合并。方法层的参数覆盖会话的参数。</p>
<div class="admonition- admonition">
<p class="first admonition-title">从字典参数中移除一个值</p>
<p class="last">有时你会想省略字典参数中一些会话层的键。要做到这一点，你只需简单地在方法层参数中将那个键的值设置为 <code class="docutils literal"><span class="pre">None</span></code> ，那个键就会被自动省略掉。</p>
</div>
<p>包含在一个会话中的所有数据你都可以直接使用。学习更多细节请阅读 <a class="reference internal" href="../api.html#sessionapi"><span>会话API文档</span></a> 。</p>
</div>
<div class="section" id="id3">
<h2>请求与响应对象<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>任何时候调用requests.*()你都在做两件主要的事情。其一，你在构建一个 <cite>Request</cite> 对象，
该对象将被发送到某个服务器请求或查询一些资源。其二，一旦 <code class="docutils literal"><span class="pre">requests</span></code> 得到一个从
服务器返回的响应就会产生一个 <code class="docutils literal"><span class="pre">Response</span></code> 对象。该响应对象包含服务器返回的所有信息，
也包含你原来创建的 <code class="docutils literal"><span class="pre">Request</span></code> 对象。如下是一个简单的请求，从Wikipedia的服务器得到
一些非常重要的信息:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;http://en.wikipedia.org/wiki/Monty_Python&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果想访问服务器返回给我们的响应头部信息，可以这样做:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">headers</span>
<span class="go">{&#39;content-length&#39;: &#39;56170&#39;, &#39;x-content-type-options&#39;: &#39;nosniff&#39;, &#39;x-cache&#39;:</span>
<span class="go">&#39;HIT from cp1006.eqiad.wmnet, MISS from cp1010.eqiad.wmnet&#39;, &#39;content-encoding&#39;:</span>
<span class="go">&#39;gzip&#39;, &#39;age&#39;: &#39;3080&#39;, &#39;content-language&#39;: &#39;en&#39;, &#39;vary&#39;: &#39;Accept-Encoding,Cookie&#39;,</span>
<span class="go">&#39;server&#39;: &#39;Apache&#39;, &#39;last-modified&#39;: &#39;Wed, 13 Jun 2012 01:33:50 GMT&#39;,</span>
<span class="go">&#39;connection&#39;: &#39;close&#39;, &#39;cache-control&#39;: &#39;private, s-maxage=0, max-age=0,</span>
<span class="go">must-revalidate&#39;, &#39;date&#39;: &#39;Thu, 14 Jun 2012 12:59:39 GMT&#39;, &#39;content-type&#39;:</span>
<span class="go">&#39;text/html; charset=UTF-8&#39;, &#39;x-cache-lookup&#39;: &#39;HIT from cp1006.eqiad.wmnet:3128,</span>
<span class="go">MISS from cp1010.eqiad.wmnet:80&#39;}</span>
</pre></div>
</div>
<p>然而，如果想得到发送到服务器的请求的头部，我们可以简单地访问该请求，然后是该请求的头部:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">headers</span>
<span class="go">{&#39;Accept-Encoding&#39;: &#39;identity, deflate, compress, gzip&#39;,</span>
<span class="go">&#39;Accept&#39;: &#39;*/*&#39;, &#39;User-Agent&#39;: &#39;python-requests/0.13.1&#39;}</span>
</pre></div>
</div>
</div>
<div class="section" id="prepared-requests">
<h2>Prepared Requests<a class="headerlink" href="#prepared-requests" title="Permalink to this headline">¶</a></h2>
<p>Whenever you receive a <a class="reference internal" href="../api.html#requests.Response" title="requests.Response"><code class="xref py py-class docutils literal"><span class="pre">Response</span></code></a> object
from an API call or a Session call, the <code class="docutils literal"><span class="pre">request</span></code> attribute is actually the
<code class="docutils literal"><span class="pre">PreparedRequest</span></code> that was used. In some cases you may wish to do some extra
work to the body or headers (or anything else really) before sending a
request. The simple recipe for this is the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">requests</span> <span class="kn">import</span> <span class="n">Request</span><span class="p">,</span> <span class="n">Session</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Session</span><span class="p">()</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span>
    <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
    <span class="n">headers</span><span class="o">=</span><span class="n">header</span>
<span class="p">)</span>
<span class="n">prepped</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>

<span class="c"># do something with prepped.body</span>
<span class="c"># do something with prepped.headers</span>

<span class="n">resp</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">prepped</span><span class="p">,</span>
    <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span>
    <span class="n">verify</span><span class="o">=</span><span class="n">verify</span><span class="p">,</span>
    <span class="n">proxies</span><span class="o">=</span><span class="n">proxies</span><span class="p">,</span>
    <span class="n">cert</span><span class="o">=</span><span class="n">cert</span><span class="p">,</span>
    <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span>
<span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</pre></div>
</div>
<p>Since you are not doing anything special with the <code class="docutils literal"><span class="pre">Request</span></code> object, you
prepare it immediately and modify the <code class="docutils literal"><span class="pre">PreparedRequest</span></code> object. You then
send that with the other parameters you would have sent to <code class="docutils literal"><span class="pre">requests.*</span></code> or
<code class="docutils literal"><span class="pre">Session.*</span></code>.</p>
<p>However, the above code will lose some of the advantages of having a Requests
<a class="reference internal" href="../api.html#requests.Session" title="requests.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> object. In particular,
<a class="reference internal" href="../api.html#requests.Session" title="requests.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>-level state such as cookies will
not get applied to your request. To get a
<a class="reference internal" href="../api.html#requests.PreparedRequest" title="requests.PreparedRequest"><code class="xref py py-class docutils literal"><span class="pre">PreparedRequest</span></code></a> with that state
applied, replace the call to <a class="reference internal" href="../api.html#requests.Request.prepare" title="requests.Request.prepare"><code class="xref py py-meth docutils literal"><span class="pre">Request.prepare()</span></code></a> with a call to
<code class="xref py py-meth docutils literal"><span class="pre">Session.prepare_request()</span></code>, like this:</p>
<div class="highlight-python"><div class="highlight"><pre>from requests import Request, Session

s = Session()
req = Request(&#39;GET&#39;,  url,
    data=data
    headers=headers
)

prepped = s.prepare_request(req)

# do something with prepped.body
# do something with prepped.headers

resp = s.send(prepped,
    stream=stream,
    verify=verify,
    proxies=proxies,
    cert=cert,
    timeout=timeout
)

print(resp.status_code)
</pre></div>
</div>
</div>
<div class="section" id="ssl">
<span id="verification"></span><h2>SSL证书验证<a class="headerlink" href="#ssl" title="Permalink to this headline">¶</a></h2>
<p>Requests可以为HTTPS请求验证SSL证书，就像web浏览器一样。要想检查某个主机的SSL证书，你可以使用 <code class="docutils literal"><span class="pre">verify</span></code> 参数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;https://kennethreitz.com&#39;</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">requests.exceptions.SSLError: hostname &#39;kennethreitz.com&#39; doesn&#39;t match either of &#39;*.herokuapp.com&#39;, &#39;herokuapp.com&#39;</span>
</pre></div>
</div>
<p>在该域名上我没有设置SSL，所以失败了。但Github设置了SSL:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;https://github.com&#39;</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&lt;Response [200]&gt;</span>
</pre></div>
</div>
<p>对于私有证书，你也可以传递一个CA_BUNDLE文件的路径给 <code class="docutils literal"><span class="pre">verify</span></code> 。你也可以设置 <code class="docutils literal"><span class="pre">REQUEST_CA_BUNDLE</span></code> 环境变量。</p>
<p>如果你将 <code class="docutils literal"><span class="pre">verify</span></code> 设置为False，Requests也能忽略对SSL证书的验证。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;https://kennethreitz.com&#39;</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">&lt;Response [200]&gt;</span>
</pre></div>
</div>
<p>默认情况下， <code class="docutils literal"><span class="pre">verify</span></code> 是设置为True的。选项 <code class="docutils literal"><span class="pre">verify</span></code> 仅应用于主机证书。</p>
<p>你也可以指定一个本地证书用作客户端证书，可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;https://kennethreitz.com&#39;</span><span class="p">,</span> <span class="n">cert</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;/path/server.crt&#39;</span><span class="p">,</span> <span class="s">&#39;/path/key&#39;</span><span class="p">))</span>
<span class="go">&lt;Response [200]&gt;</span>
</pre></div>
</div>
<p>如果你指定了一个错误路径或一个无效的证书:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;https://kennethreitz.com&#39;</span><span class="p">,</span> <span class="n">cert</span><span class="o">=</span><span class="s">&#39;/wrong_path/server.pem&#39;</span><span class="p">)</span>
<span class="go">SSLError: [Errno 336265225] _ssl.c:347: error:140B0009:SSL routines:SSL_CTX_use_PrivateKey_file:PEM lib</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>响应体内容工作流<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>默认情况下，当你进行网络请求后，响应体会立即被下载。你可以通过 <code class="docutils literal"><span class="pre">stream</span></code> 参数覆盖这个行为，推迟下载响应体直到访问 <code class="xref py py-class docutils literal"><span class="pre">Response.content</span></code> 属性:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tarball_url</span> <span class="o">=</span> <span class="s">&#39;https://github.com/kennethreitz/requests/tarball/master&#39;</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tarball_url</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>此时仅有响应头被下载下来了，连接保持打开状态，因此允许我们根据条件获取内容:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s">&#39;content-length&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">TOO_LONG</span><span class="p">:</span>
  <span class="n">content</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">content</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>你可以进一步使用 <a class="reference internal" href="../api.html#requests.Response.iter_content" title="requests.Response.iter_content"><code class="xref py py-class docutils literal"><span class="pre">Response.iter_content</span></code></a> 和 <a class="reference internal" href="../api.html#requests.Response.iter_lines" title="requests.Response.iter_lines"><code class="xref py py-class docutils literal"><span class="pre">Response.iter_lines</span></code></a> 方法来控制工作流，或者以 <a class="reference internal" href="../api.html#requests.Response.raw" title="requests.Response.raw"><code class="xref py py-class docutils literal"><span class="pre">Response.raw</span></code></a> 从底层urllib3的 <code class="xref py py-class docutils literal"><span class="pre">urllib3.HTTPResponse</span> <span class="pre">&lt;urllib3.response.HTTPResponse</span></code> 读取。</p>
<p>If you set <code class="docutils literal"><span class="pre">stream</span></code> to <code class="docutils literal"><span class="pre">True</span></code> when making a request, Requests cannot
release the connection back to the pool unless you consume all the data or call
<code class="xref py py-class docutils literal"><span class="pre">Response.close</span></code>. This can lead to
inefficiency with connections. If you find yourself partially reading request
bodies (or not reading them at all) while using <code class="docutils literal"><span class="pre">stream=True</span></code>, you should
consider using <code class="docutils literal"><span class="pre">contextlib.closing</span></code> (<a class="reference external" href="http://docs.python.org/2/library/contextlib.html#contextlib.closing">documented here</a>), like this:</p>
<div class="highlight-python"><div class="highlight"><pre>from contextlib import closing

with closing(requests.get(&#39;http://httpbin.org/get&#39;, stream=True)) as r:
    # Do things with the response here.
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>保持活动状态（持久连接）<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>好消息 - 归功于urllib3，同一会话内的持久连接是完全自动处理的！同一会话内你发出的任何请求都会自动复用恰当的连接！</p>
<p>注意：只有所有的响应体数据被读取完毕连接才会被释放为连接池；所以确保将 <code class="docutils literal"><span class="pre">stream</span></code> 设置为 <code class="docutils literal"><span class="pre">False</span></code> 或读取 <code class="docutils literal"><span class="pre">Response</span></code> 对象的 <code class="docutils literal"><span class="pre">content</span></code> 属性。</p>
</div>
<div class="section" id="id6">
<h2>流式上传<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>Requests支持流式上传，这允许你发送大的数据流或文件而无需先把它们读入内存。要使用流式上传，仅需为你的请求体提供一个类文件对象即可:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;massive-body&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s">&#39;http://some.url/streamed&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>块编码请求<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>对于出去和进来的请求，Requests也支持分块传输编码。要发送一个块编码的请求，仅需为你的请求体提供一个生成器（或任意没有具体长度(without a length)的迭代器）:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
    <span class="k">yield</span> <span class="s">&#39;hi&#39;</span>
    <span class="k">yield</span> <span class="s">&#39;there&#39;</span>

<span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s">&#39;http://some.url/chunked&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">gen</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="post-multiple-multipart-encoded-files">
<h2>POST Multiple Multipart-Encoded Files<a class="headerlink" href="#post-multiple-multipart-encoded-files" title="Permalink to this headline">¶</a></h2>
<p>You can send multiple files in one request. For example, suppose you want to
upload image files to an HTML form with a multiple file field &#8216;images&#8217;:</p>
<blockquote>
<div>&lt;input type=&#8221;file&#8221; name=&#8221;images&#8221; multiple=&#8221;true&#8221; required=&#8221;true&#8221;/&gt;</div></blockquote>
<p>To do that, just set files to a list of tuples of (form_field_name, file_info):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s">&#39;http://httpbin.org/post&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multiple_files</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;images&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;foo.png&#39;</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;foo.png&#39;</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">),</span> <span class="s">&#39;image/png&#39;</span><span class="p">)),</span>
<span class="go">                      (&#39;images&#39;, (&#39;bar.png&#39;, open(&#39;bar.png&#39;, &#39;rb&#39;), &#39;image/png&#39;))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="n">multiple_files</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">text</span>
<span class="go">{</span>
<span class="go">  ...</span>
<span class="go">  &#39;files&#39;: {&#39;images&#39;: &#39;data:image/png;base64,iVBORw ....&#39;}</span>
<span class="go">  &#39;Content-Type&#39;: &#39;multipart/form-data; boundary=3131623adb2043caaeb5538cc7aa0b3a&#39;,</span>
<span class="go">  ...</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>事件挂钩<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>Requests有一个钩子系统，你可以用来操控部分请求过程，或信号事件处理。</p>
<p>可用的钩子:</p>
<p><code class="docutils literal"><span class="pre">response</span></code>:</p>
<blockquote>
<div>从一个请求产生的响应</div></blockquote>
<p>你可以通过传递一个 <code class="docutils literal"><span class="pre">{hook_name:</span> <span class="pre">callback_function}</span></code> 字典给 <code class="docutils literal"><span class="pre">hooks</span></code> 请求参数
为每个请求分配一个钩子函数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">hooks</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">response</span><span class="o">=</span><span class="n">print_url</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">callback_function</span></code> 会接受一个数据块作为它的第一个参数。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">print_url</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
</pre></div>
</div>
<p>若执行你的回调函数期间发生错误，系统会给出一个警告。</p>
<p>若回调函数返回一个值，默认以该值替换传进来的数据。若函数未返回任何东西，
也没有什么其他的影响。</p>
<p>我们来在运行期间打印一些请求方法的参数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;http://httpbin.org&#39;</span><span class="p">,</span> <span class="n">hooks</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">response</span><span class="o">=</span><span class="n">print_url</span><span class="p">))</span>
<span class="go">http://httpbin.org</span>
<span class="go">&lt;Response [200]&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2>自定义身份验证<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>Requests允许你使用自己指定的身份验证机制。</p>
<p>任何传递给请求方法的 <code class="docutils literal"><span class="pre">auth</span></code> 参数的可调用对象，在请求发出之前都有机会修改请求。</p>
<p>自定义的身份验证机制是作为 <code class="docutils literal"><span class="pre">requests.auth.AuthBase</span></code> 的子类来实现的，也非常容易定义。</p>
<p>Requests在 <code class="docutils literal"><span class="pre">requests.auth</span></code> 中提供了两种常见的的身份验证方案： <code class="docutils literal"><span class="pre">HTTPBasicAuth</span></code> 和 <code class="docutils literal"><span class="pre">HTTPDigestAuth</span></code> 。</p>
<p>假设我们有一个web服务，仅在 <code class="docutils literal"><span class="pre">X-Pizza</span></code> 头被设置为一个密码值的情况下才会有响应。虽然这不太可能，
但就以它为例好了</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">requests.auth</span> <span class="kn">import</span> <span class="n">AuthBase</span>

<span class="k">class</span> <span class="nc">PizzaAuth</span><span class="p">(</span><span class="n">AuthBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Attaches HTTP Pizza Authentication to the given Request object.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="c"># setup any auth-related data here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">username</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="c"># modify and return the request</span>
        <span class="n">r</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s">&#39;X-Pizza&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">username</span>
        <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>然后就可以使用我们的PizzaAuth来进行网络请求:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;http://pizzabin.org/admin&#39;</span><span class="p">,</span> <span class="n">auth</span><span class="o">=</span><span class="n">PizzaAuth</span><span class="p">(</span><span class="s">&#39;kenneth&#39;</span><span class="p">))</span>
<span class="go">&lt;Response [200]&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="streaming-requests">
<span id="id10"></span><h2>流式请求<a class="headerlink" href="#streaming-requests" title="Permalink to this headline">¶</a></h2>
<p>使用 <a class="reference internal" href="../api.html#requests.Response.iter_lines" title="requests.Response.iter_lines"><code class="xref py py-class docutils literal"><span class="pre">requests.Response.iter_lines()</span></code></a> 你可以很方便地对流式API（例如 <a class="reference external" href="https://dev.twittercom/docs/streaming-api">Twitter的流式API</a> ）进行迭代。简单地设置 <code class="docutils literal"><span class="pre">stream</span></code> 为 <code class="docutils literal"><span class="pre">True</span></code> 便可以使用 <a class="reference internal" href="../api.html#requests.Response.iter_lines" title="requests.Response.iter_lines"><code class="xref py py-class docutils literal"><span class="pre">iter_lines()</span></code></a> 对相应进行迭代:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">requests</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;http://httpbin.org/stream/20&#39;</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">iter_lines</span><span class="p">():</span>

    <span class="c"># filter out keep-alive new lines</span>
    <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h2>代理<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>如果需要使用代理，你可以通过为任意请求方法提供 <code class="docutils literal"><span class="pre">proxies</span></code> 参数来配置单个请求:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">requests</span>

<span class="n">proxies</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">&quot;http&quot;</span><span class="p">:</span> <span class="s">&quot;http://10.10.1.10:3128&quot;</span><span class="p">,</span>
  <span class="s">&quot;https&quot;</span><span class="p">:</span> <span class="s">&quot;http://10.10.1.10:1080&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;http://example.org&quot;</span><span class="p">,</span> <span class="n">proxies</span><span class="o">=</span><span class="n">proxies</span><span class="p">)</span>
</pre></div>
</div>
<p>你也可以通过环境变量 <code class="docutils literal"><span class="pre">HTTP_PROXY</span></code> 和 <code class="docutils literal"><span class="pre">HTTPS_PROXY</span></code> 来配置代理。</p>
<div class="highlight-python"><div class="highlight"><pre>$ export HTTP_PROXY=&quot;http://10.10.1.10:3128&quot;
$ export HTTPS_PROXY=&quot;http://10.10.1.10:1080&quot;
$ python
&gt;&gt;&gt; import requests
&gt;&gt;&gt; requests.get(&quot;http://example.org&quot;)
</pre></div>
</div>
<p>若你的代理需要使用HTTP Basic Auth，可以使用 <cite>http://user:password&#64;host/</cite> 语法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">proxies</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&quot;http&quot;</span><span class="p">:</span> <span class="s">&quot;http://user:pass@10.10.1.10:3128/&quot;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h2>合规性<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>Requests符合所有相关的规范和RFC，这样不会为用户造成不必要的困难。但这种对规范的考虑
导致一些行为对于不熟悉相关规范的人来说看似有点奇怪。</p>
<div class="section" id="id13">
<h3>编码方式<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>当你收到一个响应时，Requests会猜测响应的编码方式，用于在你调用 <code class="docutils literal"><span class="pre">Response.text</span></code> 方法时
对响应进行解码。Requests首先在HTTP头部检测是否存在指定的编码方式，如果不存在，则会使用
<a class="reference external" href="http://pypi.python.org/pypi/charade">charade</a> 来尝试猜测编码方式。</p>
<p>只有当HTTP头部不存在明确指定的字符集，并且 <code class="docutils literal"><span class="pre">Content-Type</span></code> 头部字段包含 <code class="docutils literal"><span class="pre">text</span></code> 值之时，
Requests才不去猜测编码方式。</p>
<p>在这种情况下，
<a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.7.1">RFC 2616</a> 指定默认字符集
必须是 <code class="docutils literal"><span class="pre">ISO-8859-1</span></code> 。Requests遵从这一规范。如果你需要一种不同的编码方式，你可以手动设置
<code class="docutils literal"><span class="pre">Response.encoding</span></code> 属性，或使用原始的 <code class="docutils literal"><span class="pre">Response.content</span></code> 。</p>
</div>
</div>
<div class="section" id="http">
<h2>HTTP动词<a class="headerlink" href="#http" title="Permalink to this headline">¶</a></h2>
<p>Requests提供了几乎所有HTTP动词的功能：GET，OPTIONS， HEAD，POST，PUT，PATCH和DELETE。
以下内容为使用Requests中的这些动词以及Github API提供了详细示例。</p>
<p>我将从最常使用的动词GET开始。HTTP GET是一个幂等的方法，从给定的URL返回一个资源。因而，
当你试图从一个web位置获取数据之时，你应该使用这个动词。一个使用示例是尝试从Github上获取
关于一个特定commit的信息。假设我们想获取Requests的commit <code class="docutils literal"><span class="pre">a050faf</span></code> 的信息。我们可以
这样去做:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">requests</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;https://api.github.com/repos/kennethreitz/requests/git/commits/a050faf084662f3a352dd1a941f2c7c9f886d4ad&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>我们应该确认Github是否正确响应。如果正确响应，我们想弄清响应内容是什么类型的。像这样去做:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">status_code</span> <span class="o">==</span> <span class="n">requests</span><span class="o">.</span><span class="n">codes</span><span class="o">.</span><span class="n">ok</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">r</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s">&#39;content-type&#39;</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">application/json; charset=utf-8</span>
</pre></div>
</div>
<p>可见，GitHub返回了JSON数据，非常好，这样就可以使用 <code class="docutils literal"><span class="pre">r.json</span></code> 方法把这个返回的数据解析成Python对象。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">commit_data</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">commit_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[u&#39;committer&#39;, u&#39;author&#39;, u&#39;url&#39;, u&#39;tree&#39;, u&#39;sha&#39;, u&#39;parents&#39;, u&#39;message&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">commit_data</span><span class="p">[</span><span class="s">u&#39;committer&#39;</span><span class="p">]</span>
<span class="go">{u&#39;date&#39;: u&#39;2012-05-10T11:10:50-07:00&#39;, u&#39;email&#39;: u&#39;me@kennethreitz.com&#39;, u&#39;name&#39;: u&#39;Kenneth Reitz&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">commit_data</span><span class="p">[</span><span class="s">u&#39;message&#39;</span><span class="p">]</span>
<span class="go">makin&#39; history</span>
</pre></div>
</div>
<p>到目前为止，一切都非常简单。嗯，我们来研究一下GitHub的API。我们可以去看看文档，
但如果使用Requests来研究也许会更有意思一点。我们可以借助Requests的OPTIONS动词来看看我们刚使用过的url
支持哪些HTTP方法。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">verbs</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verbs</span><span class="o">.</span><span class="n">status_code</span>
<span class="go">500</span>
</pre></div>
</div>
<p>额，这是怎么回事？毫无帮助嘛！原来GitHub，与许多API提供方一样，实际上并未实现OPTIONS方法。
这是一个恼人的疏忽，但没关系，那我们可以使用枯燥的文档。然而，如果GitHub正确实现了OPTIONS，
那么服务器应该在响应头中返回允许用户使用的HTTP方法，例如</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">verbs</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="s">&#39;http://a-good-website.com/api/cats&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">verbs</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s">&#39;allow&#39;</span><span class="p">]</span>
<span class="go">GET,HEAD,POST,OPTIONS</span>
</pre></div>
</div>
<p>转而去查看文档，我们看到对于提交信息，另一个允许的方法是POST，它会创建一个新的提交。
由于我们正在使用Requests代码库，我们应尽可能避免对它发送笨拙的POST。作为替代，我们来
玩玩GitHub的Issue特性。</p>
<p>本篇文档是回应Issue #482而添加的。鉴于该问题已经存在，我们就以它为例。先获取它。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;https://api.github.com/repos/kennethreitz/requests/issues/482&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">status_code</span>
<span class="go">200</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">issue</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">issue</span><span class="p">[</span><span class="s">u&#39;title&#39;</span><span class="p">]</span>
<span class="go">Feature any http verb in docs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">issue</span><span class="p">[</span><span class="s">u&#39;comments&#39;</span><span class="p">]</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Cool，有3个评论。我们来看一下最后一个评论。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">url</span> <span class="o">+</span> <span class="s">u&#39;/comments&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">status_code</span>
<span class="go">200</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comments</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">comments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[u&#39;body&#39;, u&#39;url&#39;, u&#39;created_at&#39;, u&#39;updated_at&#39;, u&#39;user&#39;, u&#39;id&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">comments</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">u&#39;body&#39;</span><span class="p">]</span>
<span class="go">Probably in the &quot;advanced&quot; section</span>
</pre></div>
</div>
<p>嗯，那看起来似乎是个愚蠢之处。我们发表个评论来告诉这个评论者他自己的愚蠢。那么，这个评论者是谁呢？</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">comments</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">u&#39;user&#39;</span><span class="p">][</span><span class="s">u&#39;login&#39;</span><span class="p">]</span>
<span class="go">kennethreitz</span>
</pre></div>
</div>
<p>好，我们来告诉这个叫肯尼思的家伙，这个例子应该放在快速上手指南中。根据GitHub API文档，
其方法是POST到该话题。我们来试试看。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">body</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s">u&quot;body&quot;</span><span class="p">:</span> <span class="s">u&quot;Sounds great! I&#39;ll get right on it!&quot;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s">u&quot;https://api.github.com/repos/kennethreitz/requests/issues/482/comments&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">body</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">status_code</span>
<span class="go">404</span>
</pre></div>
</div>
<p>额，这有点古怪哈。可能我们需要验证身份。那就有点纠结了，对吧？不对。Requests简化了多种身份验证形式的使用，
包括非常常见的Basic Auth。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">requests.auth</span> <span class="kn">import</span> <span class="n">HTTPBasicAuth</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">auth</span> <span class="o">=</span> <span class="n">HTTPBasicAuth</span><span class="p">(</span><span class="s">&#39;fake@example.com&#39;</span><span class="p">,</span> <span class="s">&#39;not_a_real_password&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">body</span><span class="p">,</span> <span class="n">auth</span><span class="o">=</span><span class="n">auth</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">status_code</span>
<span class="go">201</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">content</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">content</span><span class="p">[</span><span class="s">u&#39;body&#39;</span><span class="p">])</span>
<span class="go">Sounds great! I&#39;ll get right on it.</span>
</pre></div>
</div>
<p>精彩！噢，不！我原本是想说等我一会，因为我得去喂一下我的猫。如果我能够编辑这条评论那就好了！
幸运的是，GitHub允许我们使用另一个HTTP动词，PATCH，来编辑评论。我们来试试。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">content</span><span class="p">[</span><span class="s">u&quot;id&quot;</span><span class="p">])</span>
<span class="go">5804413</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">body</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s">u&quot;body&quot;</span><span class="p">:</span> <span class="s">u&quot;Sounds great! I&#39;ll get right on it once I feed my cat.&quot;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s">u&quot;https://api.github.com/repos/kennethreitz/requests/issues/comments/5804413&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">body</span><span class="p">,</span> <span class="n">auth</span><span class="o">=</span><span class="n">auth</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">status_code</span>
<span class="go">200</span>
</pre></div>
</div>
<p>非常好。现在，我们来折磨一下这个叫肯尼思的家伙，我决定要让他急得团团转，也不告诉他是我在捣蛋。
这意味着我想删除这条评论。GitHub允许我们使用完全名副其实的DELETE方法来删除评论。我们来清除该评论。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span> <span class="n">auth</span><span class="o">=</span><span class="n">auth</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">status_code</span>
<span class="go">204</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s">&#39;status&#39;</span><span class="p">]</span>
<span class="go">&#39;204 No Content&#39;</span>
</pre></div>
</div>
<p>很好。不见了。最后一件我想知道的事情是我已经使用了多少限额（ratelimit）。查查看，GitHub在响应头部发送这个信息，
因此不必下载整个网页，我将使用一个HEAD请求来获取响应头。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span> <span class="n">auth</span><span class="o">=</span><span class="n">auth</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">r</span><span class="o">.</span><span class="n">headers</span>
<span class="gp">...</span>
<span class="go">&#39;x-ratelimit-remaining&#39;: &#39;4995&#39;</span>
<span class="go">&#39;x-ratelimit-limit&#39;: &#39;5000&#39;</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>很好。是时候写个Python程序以各种刺激的方式滥用GitHub的API，还可以使用4995次呢。</p>
</div>
<div class="section" id="id14">
<h2>响应头链接字段<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<p>许多HTTP API都有响应头链接字段的特性，它们使得API能够更好地自我描述和自我显露。</p>
<p>GitHub在API中为 <a class="reference external" href="http://developer.github.com/v3/#pagination">分页</a> 使用这些特性，例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s">&#39;https://api.github.com/users/kennethreitz/repos?page=1&amp;per_page=10&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s">&#39;link&#39;</span><span class="p">]</span>
<span class="go">&#39;&lt;https://api.github.com/users/kennethreitz/repos?page=2&amp;per_page=10&gt;; rel=&quot;next&quot;, &lt;https://api.github.com/users/kennethreitz/repos?page=6&amp;per_page=10&gt;; rel=&quot;last&quot;&#39;</span>
</pre></div>
</div>
<p>Requests会自动解析这些响应头链接字段，并使得它们非常易于使用:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="s">&quot;next&quot;</span><span class="p">]</span>
<span class="go">{&#39;url&#39;: &#39;https://api.github.com/users/kennethreitz/repos?page=2&amp;per_page=10&#39;, &#39;rel&#39;: &#39;next&#39;}</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="s">&quot;last&quot;</span><span class="p">]</span>
<span class="go">{&#39;url&#39;: &#39;https://api.github.com/users/kennethreitz/repos?page=7&amp;per_page=10&#39;, &#39;rel&#39;: &#39;last&#39;}</span>
</pre></div>
</div>
</div>
<div class="section" id="transport-adapters">
<h2>Transport Adapters<a class="headerlink" href="#transport-adapters" title="Permalink to this headline">¶</a></h2>
<p>As of v1.0.0, Requests has moved to a modular internal design. Part of the
reason this was done was to implement Transport Adapters, originally
<a class="reference external" href="http://www.kennethreitz.org/essays/the-future-of-python-http">described here</a>. Transport Adapters provide a mechanism to define interaction
methods for an HTTP service. In particular, they allow you to apply per-service
configuration.</p>
<p>Requests ships with a single Transport Adapter, the <code class="xref py py-class docutils literal"><span class="pre">HTTPAdapter</span></code>. This adapter provides the default Requests
interaction with HTTP and HTTPS using the powerful <a class="reference external" href="https://github.com/shazow/urllib3">urllib3</a> library. Whenever
a Requests <a class="reference internal" href="../api.html#requests.Session" title="requests.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> is initialized, one of these is
attached to the <a class="reference internal" href="../api.html#requests.Session" title="requests.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> object for HTTP, and one
for HTTPS.</p>
<p>Requests enables users to create and use their own Transport Adapters that
provide specific functionality. Once created, a Transport Adapter can be
mounted to a Session object, along with an indication of which web services
it should apply to.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="s">&#39;http://www.github.com&#39;</span><span class="p">,</span> <span class="n">MyAdapter</span><span class="p">())</span>
</pre></div>
</div>
<p>The mount call registers a specific instance of a Transport Adapter to a
prefix. Once mounted, any HTTP request made using that session whose URL starts
with the given prefix will use the given Transport Adapter.</p>
<p>Many of the details of implementing a Transport Adapter are beyond the scope of
this documentation, but take a look at the next example for a simple SSL use-
case. For more than that, you might look at subclassing
<code class="docutils literal"><span class="pre">requests.adapters.BaseAdapter</span></code>.</p>
<div class="section" id="example-specific-ssl-version">
<h3>Example: Specific SSL Version<a class="headerlink" href="#example-specific-ssl-version" title="Permalink to this headline">¶</a></h3>
<p>The Requests team has made a specific choice to use whatever SSL version is
default in the underlying library (<a class="reference external" href="https://github.com/shazow/urllib3">urllib3</a>). Normally this is fine, but from
time to time, you might find yourself needing to connect to a service-endpoint
that uses a version that isn&#8217;t compatible with the default.</p>
<p>You can use Transport Adapters for this by taking most of the existing
implementation of HTTPAdapter, and adding a parameter <em>ssl_version</em> that gets
passed-through to <cite>urllib3</cite>. We&#8217;ll make a TA that instructs the library to use
SSLv3:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">ssl</span>

<span class="kn">from</span> <span class="nn">requests.adapters</span> <span class="kn">import</span> <span class="n">HTTPAdapter</span>
<span class="kn">from</span> <span class="nn">requests.packages.urllib3.poolmanager</span> <span class="kn">import</span> <span class="n">PoolManager</span>


<span class="k">class</span> <span class="nc">Ssl3HttpAdapter</span><span class="p">(</span><span class="n">HTTPAdapter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&quot;Transport adapter&quot; that allows us to use SSLv3.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">init_poolmanager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connections</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poolmanager</span> <span class="o">=</span> <span class="n">PoolManager</span><span class="p">(</span><span class="n">num_pools</span><span class="o">=</span><span class="n">connections</span><span class="p">,</span>
                                       <span class="n">maxsize</span><span class="o">=</span><span class="n">maxsize</span><span class="p">,</span>
                                       <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
                                       <span class="n">ssl_version</span><span class="o">=</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_SSLv3</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="blocking-or-non-blocking">
<h2>Blocking Or Non-Blocking?<a class="headerlink" href="#blocking-or-non-blocking" title="Permalink to this headline">¶</a></h2>
<p>With the default Transport Adapter in place, Requests does not provide any kind
of non-blocking IO. The <a class="reference internal" href="../api.html#requests.Response.content" title="requests.Response.content"><code class="xref py py-attr docutils literal"><span class="pre">Response.content</span></code></a>
property will block until the entire response has been downloaded. If
you require more granularity, the streaming features of the library (see
<a class="reference internal" href="#streaming-requests"><span>流式请求</span></a>) allow you to retrieve smaller quantities of the
response at a time. However, these calls will still block.</p>
<p>If you are concerned about the use of blocking IO, there are lots of projects
out there that combine Requests with one of Python&#8217;s asynchronicity frameworks.
Two excellent examples are <a class="reference external" href="https://github.com/kennethreitz/grequests">grequests</a> and <a class="reference external" href="https://github.com/ross/requests-futures">requests-futures</a>.</p>
</div>
<div class="section" id="timeouts">
<h2>Timeouts<a class="headerlink" href="#timeouts" title="Permalink to this headline">¶</a></h2>
<p>Most requests to external servers should have a timeout attached, in case the
server is not responding in a timely manner. Without a timeout, your code may
hang for minutes or more.</p>
<p>The <strong>connect</strong> timeout is the number of seconds Requests will wait for your
client to establish a connection to a remote machine (corresponding to the
<a class="reference external" href="http://linux.die.net/man/2/connect">connect()</a>) call on the socket. It&#8217;s a good practice to set connect timeouts
to slightly larger than a multiple of 3, which is the default <a class="reference external" href="http://www.hjp.at/doc/rfc/rfc2988.txt">TCP packet
retransmission window</a>.</p>
<p>Once your client has connected to the server and sent the HTTP request, the
<strong>read</strong> timeout is the number of seconds the client will wait for the server
to send a response. (Specifically, it&#8217;s the number of seconds that the client
will wait <em>between</em> bytes sent from the server. In 99.9% of cases, this is the
time before the server sends the first byte).</p>
<p>If you specify a single value for the timeout, like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;https://github.com&#39;</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>The timeout value will be applied to both the <code class="docutils literal"><span class="pre">connect</span></code> and the <code class="docutils literal"><span class="pre">read</span></code>
timeouts. Specify a tuple if you would like to set the values separately:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;https://github.com&#39;</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="p">(</span><span class="mf">3.05</span><span class="p">,</span> <span class="mi">27</span><span class="p">))</span>
</pre></div>
</div>
<p>If the remote server is very slow, you can tell Requests to wait forever for
a response, by passing None as a timeout value and then retrieving a cup of
coffee.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;https://github.com&#39;</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="ca-certificates">
<h2>CA Certificates<a class="headerlink" href="#ca-certificates" title="Permalink to this headline">¶</a></h2>
<p>By default Requests bundles a set of root CAs that it trusts, sourced from the
<a class="reference external" href="https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt">Mozilla trust store</a>. However, these are only updated once for each Requests
version. This means that if you pin a Requests version your certificates can
become extremely out of date.</p>
<p>From Requests version 2.4.0 onwards, Requests will attempt to use certificates
from <a class="reference external" href="http://certifi.io/">certifi</a> if it is present on the system. This allows for users to update
their trusted certificates without having to change the code that runs on their
system.</p>
<p>For the sake of security we recommend upgrading certifi frequently!</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/requests-sidebar.png" alt="Logo"/>
  </a>
</p>
<p>
<iframe src="http://ghbtns.com/github-btn.html?user=kennethreitz&repo=requests&type=watch&count=true&size=large"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>

<p>
  Requests is an elegant and simple HTTP library for Python, built for
  human beings. You are currently looking at the documentation of the
  development release.
</p>

<h3>Donate</h3>
<p>
    If you love Requests, consider supporting the author <a href="https://www.gittip.com/kennethreitz/">on Gittip</a>:
</p>
<p>
  <iframe style="border: 0; margin: 0; padding: 0;"
      src="https://www.gittip.com/kennethreitz/widget.html"
      width="48pt" height="20pt"></iframe>
</p>

<p>
    If your organization uses Requests, consider financial support:

</p>

<p>
  <a href="http://gum.co/RRZc" class="gumroad-button">Requests Pro</a><script type="text/javascript" src="https://gumroad.com/js/gumroad-button.js"></script>
</p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">高级用法</a><ul>
<li><a class="reference internal" href="#id2">会话对象</a></li>
<li><a class="reference internal" href="#id3">请求与响应对象</a></li>
<li><a class="reference internal" href="#prepared-requests">Prepared Requests</a></li>
<li><a class="reference internal" href="#ssl">SSL证书验证</a></li>
<li><a class="reference internal" href="#id4">响应体内容工作流</a></li>
<li><a class="reference internal" href="#id5">保持活动状态（持久连接）</a></li>
<li><a class="reference internal" href="#id6">流式上传</a></li>
<li><a class="reference internal" href="#id7">块编码请求</a></li>
<li><a class="reference internal" href="#post-multiple-multipart-encoded-files">POST Multiple Multipart-Encoded Files</a></li>
<li><a class="reference internal" href="#id8">事件挂钩</a></li>
<li><a class="reference internal" href="#id9">自定义身份验证</a></li>
<li><a class="reference internal" href="#streaming-requests">流式请求</a></li>
<li><a class="reference internal" href="#id11">代理</a></li>
<li><a class="reference internal" href="#id12">合规性</a><ul>
<li><a class="reference internal" href="#id13">编码方式</a></li>
</ul>
</li>
<li><a class="reference internal" href="#http">HTTP动词</a></li>
<li><a class="reference internal" href="#id14">响应头链接字段</a></li>
<li><a class="reference internal" href="#transport-adapters">Transport Adapters</a><ul>
<li><a class="reference internal" href="#example-specific-ssl-version">Example: Specific SSL Version</a></li>
</ul>
</li>
<li><a class="reference internal" href="#blocking-or-non-blocking">Blocking Or Non-Blocking?</a></li>
<li><a class="reference internal" href="#timeouts">Timeouts</a></li>
<li><a class="reference internal" href="#ca-certificates">CA Certificates</a></li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="quickstart.html" title="previous chapter">快速上手</a></li>
      <li>Next: <a href="authentication.html" title="next chapter">身份认证</a></li>
  </ul></li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy; Copyright 2013. A <a href="http://kennethreitz.com/pages/open-projects.html">Kenneth Reitz</a> Project.
    </div>
    <a href="https://github.com/kennethreitz/requests" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    <script type="text/javascript">
    /* <![CDATA[ */
        (function() {
            var s = document.createElement('script'), t = document.getElementsByTagName('script')[0];
            s.type = 'text/javascript';
            s.async = true;
            s.src = 'http://api.flattr.com/js/0.6/load.js?mode=auto';
            t.parentNode.insertBefore(s, t);
        })();
    /* ]]> */
    </script>
        <script type="text/javascript">
    setTimeout(function(){var a=document.createElement("script");
    var b=document.getElementsByTagName("script")[0];
    a.src=document.location.protocol+"//dnn506yrbagrg.cloudfront.net/pages/scripts/0013/7219.js?"+Math.floor(new Date().getTime()/3600000);
    a.async=true;a.type="text/javascript";b.parentNode.insertBefore(a,b)}, 1);
    </script>

    <script type="text/javascript">
        new HelloBar(36402,48802);
    </script>


    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-8742933-11']);
      _gaq.push(['_setDomainName', 'none']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>

    <script type="text/javascript">
      (function() {
        var t   = document.createElement('script');
        t.type  = 'text/javascript';
        t.async = true;
        t.id    = 'gauges-tracker';
        t.setAttribute('data-site-id',
                       '4ddc27f6613f5d186d000007');
        t.src = '//secure.gaug.es/track.js';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(t, s);
      })();
    </script>
  </body>
</html>